#include <erl_nif.h>
#include "nif_utils.hpp"
using namespace evision::nif;
//================================================================================
// AKAZE (Generic)
//================================================================================

// GetSet (AKAZE)



// Methods (AKAZE)

static ERL_NIF_TERM evision_cv_akaze_compute(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AKAZE> * self1 = 0;
    if (!evision_AKAZE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AKAZE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AKAZE> _self_ = *(self1);

    {
    Mat image;
    vector_KeyPoint keypoints;
    Mat descriptors;

    // const char* keywords[] = { "image", "keypoints", "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints"), keypoints, ArgInfo("keypoints", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute(image, keypoints, descriptors), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }
    

    {
    UMat image;
    vector_KeyPoint keypoints;
    UMat descriptors;

    // const char* keywords[] = { "image", "keypoints", "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints"), keypoints, ArgInfo("keypoints", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute(image, keypoints, descriptors), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }
    

    {
    vector_Mat images;
    vector_vector_KeyPoint keypoints;
    vector_Mat descriptors;

    // const char* keywords[] = { "images", "keypoints", "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints"), keypoints, ArgInfo("keypoints", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute(images, keypoints, descriptors), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }
    

    {
    vector_UMat images;
    vector_vector_KeyPoint keypoints;
    vector_UMat descriptors;

    // const char* keywords[] = { "images", "keypoints", "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints"), keypoints, ArgInfo("keypoints", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute(images, keypoints, descriptors), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_akaze_create_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    std::underlying_type_t<AKAZE_DescriptorType> descriptor_type=static_cast<std::underlying_type_t<AKAZE_DescriptorType>>(AKAZE::DESCRIPTOR_MLDB);
    int descriptor_size=0;
    int descriptor_channels=3;
    float threshold=0.001f;
    int nOctaves=4;
    int nOctaveLayers=4;
    std::underlying_type_t<KAZE_DiffusivityType> diffusivity=static_cast<std::underlying_type_t<KAZE_DiffusivityType>>(KAZE::DIFF_PM_G2);
    Ptr<AKAZE> retval;

    // const char* keywords[] = { "descriptor_type", "descriptor_size", "descriptor_channels", "threshold", "nOctaves", "nOctaveLayers", "diffusivity", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptor_type"), descriptor_type, ArgInfo("descriptor_type", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptor_size"), descriptor_size, ArgInfo("descriptor_size", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptor_channels"), descriptor_channels, ArgInfo("descriptor_channels", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "threshold"), threshold, ArgInfo("threshold", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nOctaves"), nOctaves, ArgInfo("nOctaves", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nOctaveLayers"), nOctaveLayers, ArgInfo("nOctaveLayers", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "diffusivity"), diffusivity, ArgInfo("diffusivity", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::AKAZE::create(static_cast<AKAZE_DescriptorType>(descriptor_type), descriptor_size, descriptor_channels, threshold, nOctaves, nOctaveLayers, static_cast<KAZE_DiffusivityType>(diffusivity)), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_akaze_defaultNorm(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AKAZE> * self1 = 0;
    if (!evision_AKAZE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AKAZE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AKAZE> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->defaultNorm(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_akaze_descriptorSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AKAZE> * self1 = 0;
    if (!evision_AKAZE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AKAZE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AKAZE> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->descriptorSize(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_akaze_descriptorType(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AKAZE> * self1 = 0;
    if (!evision_AKAZE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AKAZE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AKAZE> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->descriptorType(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_akaze_detect(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AKAZE> * self1 = 0;
    if (!evision_AKAZE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AKAZE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AKAZE> _self_ = *(self1);

    {
    Mat image;
    vector_KeyPoint keypoints;
    Mat mask;

    // const char* keywords[] = { "image", "mask", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(image, keypoints, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, keypoints);
        }
    }

    }
    

    {
    UMat image;
    vector_KeyPoint keypoints;
    UMat mask;

    // const char* keywords[] = { "image", "mask", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(image, keypoints, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, keypoints);
        }
    }

    }
    

    {
    vector_Mat images;
    vector_vector_KeyPoint keypoints;
    vector_Mat masks;

    // const char* keywords[] = { "images", "masks", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "masks"), masks, ArgInfo("masks", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(images, keypoints, masks), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, keypoints);
        }
    }

    }
    

    {
    vector_UMat images;
    vector_vector_KeyPoint keypoints;
    vector_UMat masks;

    // const char* keywords[] = { "images", "masks", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "masks"), masks, ArgInfo("masks", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(images, keypoints, masks), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, keypoints);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_akaze_detectAndCompute(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AKAZE> * self1 = 0;
    if (!evision_AKAZE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AKAZE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AKAZE> _self_ = *(self1);

    {
    Mat image;
    Mat mask;
    vector_KeyPoint keypoints;
    Mat descriptors;
    bool useProvidedKeypoints=false;

    // const char* keywords[] = { "image", "mask", "descriptors", "useProvidedKeypoints", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "useProvidedKeypoints"), useProvidedKeypoints, ArgInfo("useProvidedKeypoints", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detectAndCompute(image, mask, keypoints, descriptors, useProvidedKeypoints), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }
    

    {
    UMat image;
    UMat mask;
    vector_KeyPoint keypoints;
    UMat descriptors;
    bool useProvidedKeypoints=false;

    // const char* keywords[] = { "image", "mask", "descriptors", "useProvidedKeypoints", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "useProvidedKeypoints"), useProvidedKeypoints, ArgInfo("useProvidedKeypoints", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detectAndCompute(image, mask, keypoints, descriptors, useProvidedKeypoints), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_akaze_empty(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AKAZE> * self1 = 0;
    if (!evision_AKAZE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AKAZE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AKAZE> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->empty(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_akaze_getDefaultName(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AKAZE> * self1 = 0;
    if (!evision_AKAZE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AKAZE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AKAZE> _self_ = *(self1);
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getDefaultName(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_akaze_getDescriptorChannels(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AKAZE> * self1 = 0;
    if (!evision_AKAZE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AKAZE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AKAZE> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getDescriptorChannels(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_akaze_getDescriptorSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AKAZE> * self1 = 0;
    if (!evision_AKAZE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AKAZE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AKAZE> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getDescriptorSize(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_akaze_getDescriptorType(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AKAZE> * self1 = 0;
    if (!evision_AKAZE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AKAZE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AKAZE> _self_ = *(self1);
    AKAZE::DescriptorType retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getDescriptorType(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_akaze_getDiffusivity(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AKAZE> * self1 = 0;
    if (!evision_AKAZE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AKAZE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AKAZE> _self_ = *(self1);
    KAZE::DiffusivityType retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getDiffusivity(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_akaze_getNOctaveLayers(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AKAZE> * self1 = 0;
    if (!evision_AKAZE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AKAZE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AKAZE> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getNOctaveLayers(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_akaze_getNOctaves(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AKAZE> * self1 = 0;
    if (!evision_AKAZE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AKAZE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AKAZE> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getNOctaves(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_akaze_getThreshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AKAZE> * self1 = 0;
    if (!evision_AKAZE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AKAZE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AKAZE> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getThreshold(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_akaze_read(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AKAZE> * self1 = 0;
    if (!evision_AKAZE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AKAZE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AKAZE> _self_ = *(self1);

    {
    String fileName;

    // const char* keywords[] = { "fileName", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fileName"), fileName, ArgInfo("fileName", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->read(fileName), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "AKAZE", success);
        }
    }

    }
    

    {
    FileNode arg1;

    // const char* keywords[] = { "arg1", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "arg1"), arg1, ArgInfo("arg1", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->read(arg1), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "AKAZE", success);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_akaze_setDescriptorChannels(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AKAZE> * self1 = 0;
    if (!evision_AKAZE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AKAZE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AKAZE> _self_ = *(self1);
    int dch=0;

    // const char* keywords[] = { "dch", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "dch"), dch, ArgInfo("dch", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setDescriptorChannels(dch), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "AKAZE", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_akaze_setDescriptorSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AKAZE> * self1 = 0;
    if (!evision_AKAZE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AKAZE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AKAZE> _self_ = *(self1);
    int dsize=0;

    // const char* keywords[] = { "dsize", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "dsize"), dsize, ArgInfo("dsize", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setDescriptorSize(dsize), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "AKAZE", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_akaze_setDescriptorType(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AKAZE> * self1 = 0;
    if (!evision_AKAZE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AKAZE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AKAZE> _self_ = *(self1);
    std::underlying_type_t<AKAZE_DescriptorType> dtype=static_cast<std::underlying_type_t<AKAZE_DescriptorType>>(static_cast<AKAZE_DescriptorType>(0));

    // const char* keywords[] = { "dtype", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "dtype"), dtype, ArgInfo("dtype", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setDescriptorType(static_cast<AKAZE_DescriptorType>(dtype)), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "AKAZE", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_akaze_setDiffusivity(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AKAZE> * self1 = 0;
    if (!evision_AKAZE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AKAZE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AKAZE> _self_ = *(self1);
    std::underlying_type_t<KAZE_DiffusivityType> diff=static_cast<std::underlying_type_t<KAZE_DiffusivityType>>(static_cast<KAZE_DiffusivityType>(0));

    // const char* keywords[] = { "diff", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "diff"), diff, ArgInfo("diff", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setDiffusivity(static_cast<KAZE_DiffusivityType>(diff)), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "AKAZE", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_akaze_setNOctaveLayers(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AKAZE> * self1 = 0;
    if (!evision_AKAZE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AKAZE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AKAZE> _self_ = *(self1);
    int octaveLayers=0;

    // const char* keywords[] = { "octaveLayers", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "octaveLayers"), octaveLayers, ArgInfo("octaveLayers", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setNOctaveLayers(octaveLayers), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "AKAZE", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_akaze_setNOctaves(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AKAZE> * self1 = 0;
    if (!evision_AKAZE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AKAZE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AKAZE> _self_ = *(self1);
    int octaves=0;

    // const char* keywords[] = { "octaves", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "octaves"), octaves, ArgInfo("octaves", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setNOctaves(octaves), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "AKAZE", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_akaze_setThreshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AKAZE> * self1 = 0;
    if (!evision_AKAZE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AKAZE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AKAZE> _self_ = *(self1);
    double threshold=0;

    // const char* keywords[] = { "threshold", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "threshold"), threshold, ArgInfo("threshold", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setThreshold(threshold), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "AKAZE", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_akaze_write(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AKAZE> * self1 = 0;
    if (!evision_AKAZE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AKAZE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AKAZE> _self_ = *(self1);

    {
    String fileName;

    // const char* keywords[] = { "fileName", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fileName"), fileName, ArgInfo("fileName", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->write(fileName), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "AKAZE", success);
        }
    }

    }
    

    {
    Ptr<FileStorage> fs;
    String name;

    // const char* keywords[] = { "fs", "name", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fs"), fs, ArgInfo("fs", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "name"), name, ArgInfo("name", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->write(fs, name), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "AKAZE", success);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (AKAZE)

template<>
struct Evision_Converter< Ptr<cv::AKAZE> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::AKAZE>& r)
    {
        return evision_AKAZE_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::AKAZE>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::AKAZE> * dst_ = nullptr;
        if (evision_AKAZE_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::AKAZE> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// AffineFeature (Generic)
//================================================================================

// GetSet (AffineFeature)



// Methods (AffineFeature)

static ERL_NIF_TERM evision_cv_affineFeature_compute(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AffineFeature> * self1 = 0;
    if (!evision_AffineFeature_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AffineFeature>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AffineFeature> _self_ = *(self1);

    {
    Mat image;
    vector_KeyPoint keypoints;
    Mat descriptors;

    // const char* keywords[] = { "image", "keypoints", "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints"), keypoints, ArgInfo("keypoints", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute(image, keypoints, descriptors), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }
    

    {
    UMat image;
    vector_KeyPoint keypoints;
    UMat descriptors;

    // const char* keywords[] = { "image", "keypoints", "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints"), keypoints, ArgInfo("keypoints", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute(image, keypoints, descriptors), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }
    

    {
    vector_Mat images;
    vector_vector_KeyPoint keypoints;
    vector_Mat descriptors;

    // const char* keywords[] = { "images", "keypoints", "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints"), keypoints, ArgInfo("keypoints", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute(images, keypoints, descriptors), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }
    

    {
    vector_UMat images;
    vector_vector_KeyPoint keypoints;
    vector_UMat descriptors;

    // const char* keywords[] = { "images", "keypoints", "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints"), keypoints, ArgInfo("keypoints", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute(images, keypoints, descriptors), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_affineFeature_create_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    Ptr<Feature2D> backend;
    int maxTilt=5;
    int minTilt=0;
    float tiltStep=1.4142135623730951f;
    float rotateStepBase=72;
    Ptr<AffineFeature> retval;

    // const char* keywords[] = { "backend", "maxTilt", "minTilt", "tiltStep", "rotateStepBase", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "backend"), backend, ArgInfo("backend", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxTilt"), maxTilt, ArgInfo("maxTilt", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minTilt"), minTilt, ArgInfo("minTilt", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tiltStep"), tiltStep, ArgInfo("tiltStep", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rotateStepBase"), rotateStepBase, ArgInfo("rotateStepBase", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::AffineFeature::create(backend, maxTilt, minTilt, tiltStep, rotateStepBase), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_affineFeature_defaultNorm(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AffineFeature> * self1 = 0;
    if (!evision_AffineFeature_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AffineFeature>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AffineFeature> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->defaultNorm(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_affineFeature_descriptorSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AffineFeature> * self1 = 0;
    if (!evision_AffineFeature_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AffineFeature>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AffineFeature> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->descriptorSize(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_affineFeature_descriptorType(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AffineFeature> * self1 = 0;
    if (!evision_AffineFeature_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AffineFeature>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AffineFeature> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->descriptorType(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_affineFeature_detect(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AffineFeature> * self1 = 0;
    if (!evision_AffineFeature_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AffineFeature>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AffineFeature> _self_ = *(self1);

    {
    Mat image;
    vector_KeyPoint keypoints;
    Mat mask;

    // const char* keywords[] = { "image", "mask", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(image, keypoints, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, keypoints);
        }
    }

    }
    

    {
    UMat image;
    vector_KeyPoint keypoints;
    UMat mask;

    // const char* keywords[] = { "image", "mask", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(image, keypoints, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, keypoints);
        }
    }

    }
    

    {
    vector_Mat images;
    vector_vector_KeyPoint keypoints;
    vector_Mat masks;

    // const char* keywords[] = { "images", "masks", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "masks"), masks, ArgInfo("masks", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(images, keypoints, masks), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, keypoints);
        }
    }

    }
    

    {
    vector_UMat images;
    vector_vector_KeyPoint keypoints;
    vector_UMat masks;

    // const char* keywords[] = { "images", "masks", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "masks"), masks, ArgInfo("masks", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(images, keypoints, masks), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, keypoints);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_affineFeature_detectAndCompute(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AffineFeature> * self1 = 0;
    if (!evision_AffineFeature_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AffineFeature>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AffineFeature> _self_ = *(self1);

    {
    Mat image;
    Mat mask;
    vector_KeyPoint keypoints;
    Mat descriptors;
    bool useProvidedKeypoints=false;

    // const char* keywords[] = { "image", "mask", "descriptors", "useProvidedKeypoints", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "useProvidedKeypoints"), useProvidedKeypoints, ArgInfo("useProvidedKeypoints", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detectAndCompute(image, mask, keypoints, descriptors, useProvidedKeypoints), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }
    

    {
    UMat image;
    UMat mask;
    vector_KeyPoint keypoints;
    UMat descriptors;
    bool useProvidedKeypoints=false;

    // const char* keywords[] = { "image", "mask", "descriptors", "useProvidedKeypoints", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "useProvidedKeypoints"), useProvidedKeypoints, ArgInfo("useProvidedKeypoints", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detectAndCompute(image, mask, keypoints, descriptors, useProvidedKeypoints), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_affineFeature_empty(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AffineFeature> * self1 = 0;
    if (!evision_AffineFeature_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AffineFeature>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AffineFeature> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->empty(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_affineFeature_getDefaultName(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AffineFeature> * self1 = 0;
    if (!evision_AffineFeature_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AffineFeature>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AffineFeature> _self_ = *(self1);
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getDefaultName(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_affineFeature_getViewParams(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AffineFeature> * self1 = 0;
    if (!evision_AffineFeature_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AffineFeature>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AffineFeature> _self_ = *(self1);
    vector_float tilts;
    vector_float rolls;

    // const char* keywords[] = { "tilts", "rolls", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "tilts"), tilts, ArgInfo("tilts", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rolls"), rolls, ArgInfo("rolls", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->getViewParams(tilts, rolls), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "AffineFeature", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_affineFeature_read(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AffineFeature> * self1 = 0;
    if (!evision_AffineFeature_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AffineFeature>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AffineFeature> _self_ = *(self1);

    {
    String fileName;

    // const char* keywords[] = { "fileName", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fileName"), fileName, ArgInfo("fileName", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->read(fileName), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "AffineFeature", success);
        }
    }

    }
    

    {
    FileNode arg1;

    // const char* keywords[] = { "arg1", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "arg1"), arg1, ArgInfo("arg1", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->read(arg1), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "AffineFeature", success);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_affineFeature_setViewParams(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AffineFeature> * self1 = 0;
    if (!evision_AffineFeature_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AffineFeature>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AffineFeature> _self_ = *(self1);
    vector_float tilts;
    vector_float rolls;

    // const char* keywords[] = { "tilts", "rolls", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "tilts"), tilts, ArgInfo("tilts", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rolls"), rolls, ArgInfo("rolls", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setViewParams(tilts, rolls), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "AffineFeature", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_affineFeature_write(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AffineFeature> * self1 = 0;
    if (!evision_AffineFeature_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AffineFeature>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AffineFeature> _self_ = *(self1);

    {
    String fileName;

    // const char* keywords[] = { "fileName", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fileName"), fileName, ArgInfo("fileName", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->write(fileName), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "AffineFeature", success);
        }
    }

    }
    

    {
    Ptr<FileStorage> fs;
    String name;

    // const char* keywords[] = { "fs", "name", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fs"), fs, ArgInfo("fs", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "name"), name, ArgInfo("name", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->write(fs, name), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "AffineFeature", success);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (AffineFeature)

template<>
struct Evision_Converter< Ptr<cv::AffineFeature> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::AffineFeature>& r)
    {
        return evision_AffineFeature_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::AffineFeature>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::AffineFeature> * dst_ = nullptr;
        if (evision_AffineFeature_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::AffineFeature> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// AgastFeatureDetector (Generic)
//================================================================================

// GetSet (AgastFeatureDetector)



// Methods (AgastFeatureDetector)

static ERL_NIF_TERM evision_cv_agastFeatureDetector_compute(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AgastFeatureDetector> * self1 = 0;
    if (!evision_AgastFeatureDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AgastFeatureDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AgastFeatureDetector> _self_ = *(self1);

    {
    Mat image;
    vector_KeyPoint keypoints;
    Mat descriptors;

    // const char* keywords[] = { "image", "keypoints", "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints"), keypoints, ArgInfo("keypoints", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute(image, keypoints, descriptors), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }
    

    {
    UMat image;
    vector_KeyPoint keypoints;
    UMat descriptors;

    // const char* keywords[] = { "image", "keypoints", "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints"), keypoints, ArgInfo("keypoints", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute(image, keypoints, descriptors), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }
    

    {
    vector_Mat images;
    vector_vector_KeyPoint keypoints;
    vector_Mat descriptors;

    // const char* keywords[] = { "images", "keypoints", "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints"), keypoints, ArgInfo("keypoints", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute(images, keypoints, descriptors), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }
    

    {
    vector_UMat images;
    vector_vector_KeyPoint keypoints;
    vector_UMat descriptors;

    // const char* keywords[] = { "images", "keypoints", "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints"), keypoints, ArgInfo("keypoints", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute(images, keypoints, descriptors), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_agastFeatureDetector_create_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    int threshold=10;
    bool nonmaxSuppression=true;
    std::underlying_type_t<AgastFeatureDetector_DetectorType> type=static_cast<std::underlying_type_t<AgastFeatureDetector_DetectorType>>(AgastFeatureDetector::OAST_9_16);
    Ptr<AgastFeatureDetector> retval;

    // const char* keywords[] = { "threshold", "nonmaxSuppression", "type", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "threshold"), threshold, ArgInfo("threshold", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nonmaxSuppression"), nonmaxSuppression, ArgInfo("nonmaxSuppression", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "type"), type, ArgInfo("type", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::AgastFeatureDetector::create(threshold, nonmaxSuppression, static_cast<AgastFeatureDetector_DetectorType>(type)), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_agastFeatureDetector_defaultNorm(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AgastFeatureDetector> * self1 = 0;
    if (!evision_AgastFeatureDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AgastFeatureDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AgastFeatureDetector> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->defaultNorm(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_agastFeatureDetector_descriptorSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AgastFeatureDetector> * self1 = 0;
    if (!evision_AgastFeatureDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AgastFeatureDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AgastFeatureDetector> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->descriptorSize(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_agastFeatureDetector_descriptorType(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AgastFeatureDetector> * self1 = 0;
    if (!evision_AgastFeatureDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AgastFeatureDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AgastFeatureDetector> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->descriptorType(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_agastFeatureDetector_detect(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AgastFeatureDetector> * self1 = 0;
    if (!evision_AgastFeatureDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AgastFeatureDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AgastFeatureDetector> _self_ = *(self1);

    {
    Mat image;
    vector_KeyPoint keypoints;
    Mat mask;

    // const char* keywords[] = { "image", "mask", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(image, keypoints, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, keypoints);
        }
    }

    }
    

    {
    UMat image;
    vector_KeyPoint keypoints;
    UMat mask;

    // const char* keywords[] = { "image", "mask", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(image, keypoints, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, keypoints);
        }
    }

    }
    

    {
    vector_Mat images;
    vector_vector_KeyPoint keypoints;
    vector_Mat masks;

    // const char* keywords[] = { "images", "masks", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "masks"), masks, ArgInfo("masks", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(images, keypoints, masks), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, keypoints);
        }
    }

    }
    

    {
    vector_UMat images;
    vector_vector_KeyPoint keypoints;
    vector_UMat masks;

    // const char* keywords[] = { "images", "masks", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "masks"), masks, ArgInfo("masks", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(images, keypoints, masks), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, keypoints);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_agastFeatureDetector_detectAndCompute(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AgastFeatureDetector> * self1 = 0;
    if (!evision_AgastFeatureDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AgastFeatureDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AgastFeatureDetector> _self_ = *(self1);

    {
    Mat image;
    Mat mask;
    vector_KeyPoint keypoints;
    Mat descriptors;
    bool useProvidedKeypoints=false;

    // const char* keywords[] = { "image", "mask", "descriptors", "useProvidedKeypoints", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "useProvidedKeypoints"), useProvidedKeypoints, ArgInfo("useProvidedKeypoints", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detectAndCompute(image, mask, keypoints, descriptors, useProvidedKeypoints), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }
    

    {
    UMat image;
    UMat mask;
    vector_KeyPoint keypoints;
    UMat descriptors;
    bool useProvidedKeypoints=false;

    // const char* keywords[] = { "image", "mask", "descriptors", "useProvidedKeypoints", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "useProvidedKeypoints"), useProvidedKeypoints, ArgInfo("useProvidedKeypoints", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detectAndCompute(image, mask, keypoints, descriptors, useProvidedKeypoints), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_agastFeatureDetector_empty(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AgastFeatureDetector> * self1 = 0;
    if (!evision_AgastFeatureDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AgastFeatureDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AgastFeatureDetector> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->empty(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_agastFeatureDetector_getDefaultName(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AgastFeatureDetector> * self1 = 0;
    if (!evision_AgastFeatureDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AgastFeatureDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AgastFeatureDetector> _self_ = *(self1);
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getDefaultName(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_agastFeatureDetector_getNonmaxSuppression(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AgastFeatureDetector> * self1 = 0;
    if (!evision_AgastFeatureDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AgastFeatureDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AgastFeatureDetector> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getNonmaxSuppression(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_agastFeatureDetector_getThreshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AgastFeatureDetector> * self1 = 0;
    if (!evision_AgastFeatureDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AgastFeatureDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AgastFeatureDetector> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getThreshold(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_agastFeatureDetector_getType(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AgastFeatureDetector> * self1 = 0;
    if (!evision_AgastFeatureDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AgastFeatureDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AgastFeatureDetector> _self_ = *(self1);
    AgastFeatureDetector::DetectorType retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getType(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_agastFeatureDetector_read(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AgastFeatureDetector> * self1 = 0;
    if (!evision_AgastFeatureDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AgastFeatureDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AgastFeatureDetector> _self_ = *(self1);

    {
    String fileName;

    // const char* keywords[] = { "fileName", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fileName"), fileName, ArgInfo("fileName", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->read(fileName), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "AgastFeatureDetector", success);
        }
    }

    }
    

    {
    FileNode arg1;

    // const char* keywords[] = { "arg1", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "arg1"), arg1, ArgInfo("arg1", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->read(arg1), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "AgastFeatureDetector", success);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_agastFeatureDetector_setNonmaxSuppression(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AgastFeatureDetector> * self1 = 0;
    if (!evision_AgastFeatureDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AgastFeatureDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AgastFeatureDetector> _self_ = *(self1);
    bool f=0;

    // const char* keywords[] = { "f", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "f"), f, ArgInfo("f", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setNonmaxSuppression(f), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "AgastFeatureDetector", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_agastFeatureDetector_setThreshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AgastFeatureDetector> * self1 = 0;
    if (!evision_AgastFeatureDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AgastFeatureDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AgastFeatureDetector> _self_ = *(self1);
    int threshold=0;

    // const char* keywords[] = { "threshold", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "threshold"), threshold, ArgInfo("threshold", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setThreshold(threshold), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "AgastFeatureDetector", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_agastFeatureDetector_setType(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AgastFeatureDetector> * self1 = 0;
    if (!evision_AgastFeatureDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AgastFeatureDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AgastFeatureDetector> _self_ = *(self1);
    std::underlying_type_t<AgastFeatureDetector_DetectorType> type=static_cast<std::underlying_type_t<AgastFeatureDetector_DetectorType>>(static_cast<AgastFeatureDetector_DetectorType>(0));

    // const char* keywords[] = { "type", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "type"), type, ArgInfo("type", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setType(static_cast<AgastFeatureDetector_DetectorType>(type)), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "AgastFeatureDetector", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_agastFeatureDetector_write(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AgastFeatureDetector> * self1 = 0;
    if (!evision_AgastFeatureDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AgastFeatureDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AgastFeatureDetector> _self_ = *(self1);

    {
    String fileName;

    // const char* keywords[] = { "fileName", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fileName"), fileName, ArgInfo("fileName", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->write(fileName), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "AgastFeatureDetector", success);
        }
    }

    }
    

    {
    Ptr<FileStorage> fs;
    String name;

    // const char* keywords[] = { "fs", "name", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fs"), fs, ArgInfo("fs", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "name"), name, ArgInfo("name", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->write(fs, name), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "AgastFeatureDetector", success);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (AgastFeatureDetector)

template<>
struct Evision_Converter< Ptr<cv::AgastFeatureDetector> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::AgastFeatureDetector>& r)
    {
        return evision_AgastFeatureDetector_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::AgastFeatureDetector>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::AgastFeatureDetector> * dst_ = nullptr;
        if (evision_AgastFeatureDetector_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::AgastFeatureDetector> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// Algorithm (Generic)
//================================================================================

// GetSet (Algorithm)



// Methods (Algorithm)

static ERL_NIF_TERM evision_cv_algorithm_clear(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Algorithm> * self1 = 0;
    if (!evision_Algorithm_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Algorithm>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Algorithm> _self_ = *(self1);

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::clear(), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Algorithm", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_algorithm_empty(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Algorithm> * self1 = 0;
    if (!evision_Algorithm_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Algorithm>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Algorithm> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->Algorithm::empty(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_algorithm_getDefaultName(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Algorithm> * self1 = 0;
    if (!evision_Algorithm_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Algorithm>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Algorithm> _self_ = *(self1);
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->Algorithm::getDefaultName(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_algorithm_read(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Algorithm> * self1 = 0;
    if (!evision_Algorithm_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Algorithm>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Algorithm> _self_ = *(self1);
    FileNode fn_;

    // const char* keywords[] = { "fn_", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fn_"), fn_, ArgInfo("fn_", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::read(fn_), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Algorithm", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_algorithm_save(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Algorithm> * self1 = 0;
    if (!evision_Algorithm_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Algorithm>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Algorithm> _self_ = *(self1);
    String filename;

    // const char* keywords[] = { "filename", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::save(filename), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Algorithm", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_algorithm_write(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Algorithm> * self1 = 0;
    if (!evision_Algorithm_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Algorithm>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Algorithm> _self_ = *(self1);
    Ptr<FileStorage> fs;
    String name;

    // const char* keywords[] = { "fs", "name", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fs"), fs, ArgInfo("fs", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "name"), name, ArgInfo("name", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::write(fs, name), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Algorithm", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (Algorithm)

template<>
struct Evision_Converter< Ptr<cv::Algorithm> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::Algorithm>& r)
    {
        return evision_Algorithm_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::Algorithm>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::Algorithm> * dst_ = nullptr;
        if (evision_Algorithm_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::Algorithm> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// AlignExposures (Generic)
//================================================================================

// GetSet (AlignExposures)



// Methods (AlignExposures)

static ERL_NIF_TERM evision_cv_alignExposures_clear(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AlignExposures> * self1 = 0;
    if (!evision_AlignExposures_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AlignExposures>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AlignExposures> _self_ = *(self1);

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::clear(), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "AlignExposures", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_alignExposures_empty(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AlignExposures> * self1 = 0;
    if (!evision_AlignExposures_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AlignExposures>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AlignExposures> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->Algorithm::empty(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_alignExposures_getDefaultName(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AlignExposures> * self1 = 0;
    if (!evision_AlignExposures_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AlignExposures>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AlignExposures> _self_ = *(self1);
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->Algorithm::getDefaultName(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_alignExposures_process(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AlignExposures> * self1 = 0;
    if (!evision_AlignExposures_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AlignExposures>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AlignExposures> _self_ = *(self1);

    {
    vector_Mat src;
    vector_Mat dst;
    Mat times;
    Mat response;

    // const char* keywords[] = { "src", "dst", "times", "response", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "times"), times, ArgInfo("times", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "response"), response, ArgInfo("response", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->process(src, dst, times, response), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "AlignExposures", success);
        }
    }

    }
    

    {
    vector_UMat src;
    vector_Mat dst;
    UMat times;
    UMat response;

    // const char* keywords[] = { "src", "dst", "times", "response", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "times"), times, ArgInfo("times", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "response"), response, ArgInfo("response", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->process(src, dst, times, response), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "AlignExposures", success);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_alignExposures_read(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AlignExposures> * self1 = 0;
    if (!evision_AlignExposures_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AlignExposures>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AlignExposures> _self_ = *(self1);
    FileNode fn_;

    // const char* keywords[] = { "fn_", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fn_"), fn_, ArgInfo("fn_", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::read(fn_), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "AlignExposures", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_alignExposures_save(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AlignExposures> * self1 = 0;
    if (!evision_AlignExposures_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AlignExposures>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AlignExposures> _self_ = *(self1);
    String filename;

    // const char* keywords[] = { "filename", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::save(filename), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "AlignExposures", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_alignExposures_write(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AlignExposures> * self1 = 0;
    if (!evision_AlignExposures_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AlignExposures>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AlignExposures> _self_ = *(self1);
    Ptr<FileStorage> fs;
    String name;

    // const char* keywords[] = { "fs", "name", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fs"), fs, ArgInfo("fs", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "name"), name, ArgInfo("name", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::write(fs, name), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "AlignExposures", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (AlignExposures)

template<>
struct Evision_Converter< Ptr<cv::AlignExposures> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::AlignExposures>& r)
    {
        return evision_AlignExposures_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::AlignExposures>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::AlignExposures> * dst_ = nullptr;
        if (evision_AlignExposures_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::AlignExposures> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// AlignMTB (Generic)
//================================================================================

// GetSet (AlignMTB)



// Methods (AlignMTB)

static ERL_NIF_TERM evision_cv_alignMTB_calculateShift(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AlignMTB> * self1 = 0;
    if (!evision_AlignMTB_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AlignMTB>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AlignMTB> _self_ = *(self1);

    {
    Mat img0;
    Mat img1;
    Point retval;

    // const char* keywords[] = { "img0", "img1", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "img0"), img0, ArgInfo("img0", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img1"), img1, ArgInfo("img1", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->calculateShift(img0, img1), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    UMat img0;
    UMat img1;
    Point retval;

    // const char* keywords[] = { "img0", "img1", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "img0"), img0, ArgInfo("img0", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img1"), img1, ArgInfo("img1", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->calculateShift(img0, img1), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_alignMTB_computeBitmaps(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AlignMTB> * self1 = 0;
    if (!evision_AlignMTB_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AlignMTB>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AlignMTB> _self_ = *(self1);

    {
    Mat img;
    Mat tb;
    Mat eb;

    // const char* keywords[] = { "img", "tb", "eb", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tb"), tb, ArgInfo("tb", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "eb"), eb, ArgInfo("eb", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->computeBitmaps(img, tb, eb), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, tb), evision_from(env, eb));
        }
    }

    }
    

    {
    UMat img;
    UMat tb;
    UMat eb;

    // const char* keywords[] = { "img", "tb", "eb", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tb"), tb, ArgInfo("tb", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "eb"), eb, ArgInfo("eb", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->computeBitmaps(img, tb, eb), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, tb), evision_from(env, eb));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_alignMTB_getCut(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AlignMTB> * self1 = 0;
    if (!evision_AlignMTB_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AlignMTB>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AlignMTB> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getCut(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_alignMTB_getExcludeRange(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AlignMTB> * self1 = 0;
    if (!evision_AlignMTB_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AlignMTB>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AlignMTB> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getExcludeRange(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_alignMTB_getMaxBits(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AlignMTB> * self1 = 0;
    if (!evision_AlignMTB_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AlignMTB>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AlignMTB> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getMaxBits(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_alignMTB_process(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AlignMTB> * self1 = 0;
    if (!evision_AlignMTB_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AlignMTB>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AlignMTB> _self_ = *(self1);

    {
    vector_Mat src;
    vector_Mat dst;
    Mat times;
    Mat response;

    // const char* keywords[] = { "src", "dst", "times", "response", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "times"), times, ArgInfo("times", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "response"), response, ArgInfo("response", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->process(src, dst, times, response), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "AlignMTB", success);
        }
    }

    }
    

    {
    vector_UMat src;
    vector_Mat dst;
    UMat times;
    UMat response;

    // const char* keywords[] = { "src", "dst", "times", "response", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "times"), times, ArgInfo("times", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "response"), response, ArgInfo("response", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->process(src, dst, times, response), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "AlignMTB", success);
        }
    }

    }
    

    {
    vector_Mat src;
    vector_Mat dst;

    // const char* keywords[] = { "src", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->process(src, dst), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "AlignMTB", success);
        }
    }

    }
    

    {
    vector_UMat src;
    vector_Mat dst;

    // const char* keywords[] = { "src", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->process(src, dst), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "AlignMTB", success);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_alignMTB_setCut(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AlignMTB> * self1 = 0;
    if (!evision_AlignMTB_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AlignMTB>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AlignMTB> _self_ = *(self1);
    bool value=0;

    // const char* keywords[] = { "value", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "value"), value, ArgInfo("value", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setCut(value), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "AlignMTB", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_alignMTB_setExcludeRange(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AlignMTB> * self1 = 0;
    if (!evision_AlignMTB_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AlignMTB>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AlignMTB> _self_ = *(self1);
    int exclude_range=0;

    // const char* keywords[] = { "exclude_range", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "exclude_range"), exclude_range, ArgInfo("exclude_range", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setExcludeRange(exclude_range), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "AlignMTB", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_alignMTB_setMaxBits(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AlignMTB> * self1 = 0;
    if (!evision_AlignMTB_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AlignMTB>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AlignMTB> _self_ = *(self1);
    int max_bits=0;

    // const char* keywords[] = { "max_bits", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "max_bits"), max_bits, ArgInfo("max_bits", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setMaxBits(max_bits), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "AlignMTB", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_alignMTB_shiftMat(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AlignMTB> * self1 = 0;
    if (!evision_AlignMTB_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AlignMTB>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AlignMTB> _self_ = *(self1);

    {
    Mat src;
    Mat dst;
    Point shift;

    // const char* keywords[] = { "src", "shift", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "shift"), shift, ArgInfo("shift", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->shiftMat(src, dst, shift), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    UMat src;
    UMat dst;
    Point shift;

    // const char* keywords[] = { "src", "shift", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "shift"), shift, ArgInfo("shift", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->shiftMat(src, dst, shift), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (AlignMTB)

template<>
struct Evision_Converter< Ptr<cv::AlignMTB> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::AlignMTB>& r)
    {
        return evision_AlignMTB_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::AlignMTB>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::AlignMTB> * dst_ = nullptr;
        if (evision_AlignMTB_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::AlignMTB> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// AsyncArray (Generic)
//================================================================================

// GetSet (AsyncArray)



// Methods (AsyncArray)

static ERL_NIF_TERM evision_cv_asyncArray_AsyncArray(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        evision_res<Ptr<cv::AsyncArray>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::AsyncArray>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::AsyncArray()), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::AsyncArray>>(env, self->val, ret, "AsyncArray", success);;
        }
    }

    return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_asyncArray_get(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AsyncArray> * self1 = 0;
    if (!evision_AsyncArray_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AsyncArray>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AsyncArray> _self_ = *(self1);

    {
    Mat dst;

    // const char* keywords[] = { "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->get(dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    UMat dst;

    // const char* keywords[] = { "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->get(dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Mat dst;
    double timeoutNs=0;
    bool retval;

    // const char* keywords[] = { "timeoutNs", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "timeoutNs"), timeoutNs, ArgInfo("timeoutNs", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->get(dst, timeoutNs), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_1_tuple_except_bool
                return evision_from(env, dst);
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    UMat dst;
    double timeoutNs=0;
    bool retval;

    // const char* keywords[] = { "timeoutNs", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "timeoutNs"), timeoutNs, ArgInfo("timeoutNs", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->get(dst, timeoutNs), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_1_tuple_except_bool
                return evision_from(env, dst);
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_asyncArray_release(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AsyncArray> * self1 = 0;
    if (!evision_AsyncArray_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AsyncArray>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AsyncArray> _self_ = *(self1);

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->release(), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "AsyncArray", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_asyncArray_valid(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AsyncArray> * self1 = 0;
    if (!evision_AsyncArray_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AsyncArray>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AsyncArray> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->valid(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_asyncArray_wait_for(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::AsyncArray> * self1 = 0;
    if (!evision_AsyncArray_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::AsyncArray>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::AsyncArray> _self_ = *(self1);
    double timeoutNs=0;
    bool retval;

    // const char* keywords[] = { "timeoutNs", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "timeoutNs"), timeoutNs, ArgInfo("timeoutNs", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->wait_for(timeoutNs), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (AsyncArray)

template<>
struct Evision_Converter< Ptr<cv::AsyncArray> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::AsyncArray>& r)
    {
        return evision_AsyncArray_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::AsyncArray>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::AsyncArray> * dst_ = nullptr;
        if (evision_AsyncArray_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::AsyncArray> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// BFMatcher (Generic)
//================================================================================

// GetSet (BFMatcher)



// Methods (BFMatcher)

static ERL_NIF_TERM evision_cv_bfMatcher_BFMatcher(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    int normType=NORM_L2;
    bool crossCheck=false;

    // const char* keywords[] = { "normType", "crossCheck", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "normType"), normType, ArgInfo("normType", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "crossCheck"), crossCheck, ArgInfo("crossCheck", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::BFMatcher>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::BFMatcher>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::BFMatcher(normType, crossCheck)), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::BFMatcher>>(env, self->val, ret, "BFMatcher", success);;
        }
    }

    return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_bfMatcher_add(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BFMatcher> * self1 = 0;
    if (!evision_BFMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BFMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BFMatcher> _self_ = *(self1);

    {
    vector_Mat descriptors;

    // const char* keywords[] = { "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::add(descriptors), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "BFMatcher", success);
        }
    }

    }
    

    {
    vector_UMat descriptors;

    // const char* keywords[] = { "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::add(descriptors), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "BFMatcher", success);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_bfMatcher_clear(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BFMatcher> * self1 = 0;
    if (!evision_BFMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BFMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BFMatcher> _self_ = *(self1);

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::clear(), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "BFMatcher", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_bfMatcher_clone(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BFMatcher> * self1 = 0;
    if (!evision_BFMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BFMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BFMatcher> _self_ = *(self1);
    bool emptyTrainData=false;
    Ptr<DescriptorMatcher> retval;

    // const char* keywords[] = { "emptyTrainData", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "emptyTrainData"), emptyTrainData, ArgInfo("emptyTrainData", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->clone(emptyTrainData), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_bfMatcher_create_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    int normType=NORM_L2;
    bool crossCheck=false;
    Ptr<BFMatcher> retval;

    // const char* keywords[] = { "normType", "crossCheck", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "normType"), normType, ArgInfo("normType", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "crossCheck"), crossCheck, ArgInfo("crossCheck", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::BFMatcher::create(normType, crossCheck), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_bfMatcher_empty(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BFMatcher> * self1 = 0;
    if (!evision_BFMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BFMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BFMatcher> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->DescriptorMatcher::empty(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_bfMatcher_getDefaultName(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BFMatcher> * self1 = 0;
    if (!evision_BFMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BFMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BFMatcher> _self_ = *(self1);
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->Algorithm::getDefaultName(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_bfMatcher_getTrainDescriptors(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BFMatcher> * self1 = 0;
    if (!evision_BFMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BFMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BFMatcher> _self_ = *(self1);
    std::vector<Mat> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->DescriptorMatcher::getTrainDescriptors(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_bfMatcher_isMaskSupported(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BFMatcher> * self1 = 0;
    if (!evision_BFMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BFMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BFMatcher> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->isMaskSupported(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_bfMatcher_knnMatch(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BFMatcher> * self1 = 0;
    if (!evision_BFMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BFMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BFMatcher> _self_ = *(self1);

    {
    Mat queryDescriptors;
    Mat trainDescriptors;
    vector_vector_DMatch matches;
    int k=0;
    Mat mask;
    bool compactResult=false;

    // const char* keywords[] = { "queryDescriptors", "trainDescriptors", "k", "mask", "compactResult", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "queryDescriptors"), queryDescriptors, ArgInfo("queryDescriptors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "trainDescriptors"), trainDescriptors, ArgInfo("trainDescriptors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), k, ArgInfo("k", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "compactResult"), compactResult, ArgInfo("compactResult", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::knnMatch(queryDescriptors, trainDescriptors, matches, k, mask, compactResult), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, matches);
        }
    }

    }
    

    {
    UMat queryDescriptors;
    UMat trainDescriptors;
    vector_vector_DMatch matches;
    int k=0;
    UMat mask;
    bool compactResult=false;

    // const char* keywords[] = { "queryDescriptors", "trainDescriptors", "k", "mask", "compactResult", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "queryDescriptors"), queryDescriptors, ArgInfo("queryDescriptors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "trainDescriptors"), trainDescriptors, ArgInfo("trainDescriptors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), k, ArgInfo("k", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "compactResult"), compactResult, ArgInfo("compactResult", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::knnMatch(queryDescriptors, trainDescriptors, matches, k, mask, compactResult), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, matches);
        }
    }

    }
    

    {
    Mat queryDescriptors;
    vector_vector_DMatch matches;
    int k=0;
    vector_Mat masks;
    bool compactResult=false;

    // const char* keywords[] = { "queryDescriptors", "k", "masks", "compactResult", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "queryDescriptors"), queryDescriptors, ArgInfo("queryDescriptors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), k, ArgInfo("k", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "masks"), masks, ArgInfo("masks", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "compactResult"), compactResult, ArgInfo("compactResult", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::knnMatch(queryDescriptors, matches, k, masks, compactResult), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, matches);
        }
    }

    }
    

    {
    UMat queryDescriptors;
    vector_vector_DMatch matches;
    int k=0;
    vector_UMat masks;
    bool compactResult=false;

    // const char* keywords[] = { "queryDescriptors", "k", "masks", "compactResult", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "queryDescriptors"), queryDescriptors, ArgInfo("queryDescriptors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), k, ArgInfo("k", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "masks"), masks, ArgInfo("masks", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "compactResult"), compactResult, ArgInfo("compactResult", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::knnMatch(queryDescriptors, matches, k, masks, compactResult), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, matches);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_bfMatcher_match(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BFMatcher> * self1 = 0;
    if (!evision_BFMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BFMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BFMatcher> _self_ = *(self1);

    {
    Mat queryDescriptors;
    Mat trainDescriptors;
    vector_DMatch matches;
    Mat mask;

    // const char* keywords[] = { "queryDescriptors", "trainDescriptors", "mask", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "queryDescriptors"), queryDescriptors, ArgInfo("queryDescriptors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "trainDescriptors"), trainDescriptors, ArgInfo("trainDescriptors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::match(queryDescriptors, trainDescriptors, matches, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, matches);
        }
    }

    }
    

    {
    UMat queryDescriptors;
    UMat trainDescriptors;
    vector_DMatch matches;
    UMat mask;

    // const char* keywords[] = { "queryDescriptors", "trainDescriptors", "mask", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "queryDescriptors"), queryDescriptors, ArgInfo("queryDescriptors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "trainDescriptors"), trainDescriptors, ArgInfo("trainDescriptors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::match(queryDescriptors, trainDescriptors, matches, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, matches);
        }
    }

    }
    

    {
    Mat queryDescriptors;
    vector_DMatch matches;
    vector_Mat masks;

    // const char* keywords[] = { "queryDescriptors", "masks", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "queryDescriptors"), queryDescriptors, ArgInfo("queryDescriptors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "masks"), masks, ArgInfo("masks", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::match(queryDescriptors, matches, masks), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, matches);
        }
    }

    }
    

    {
    UMat queryDescriptors;
    vector_DMatch matches;
    vector_UMat masks;

    // const char* keywords[] = { "queryDescriptors", "masks", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "queryDescriptors"), queryDescriptors, ArgInfo("queryDescriptors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "masks"), masks, ArgInfo("masks", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::match(queryDescriptors, matches, masks), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, matches);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_bfMatcher_radiusMatch(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BFMatcher> * self1 = 0;
    if (!evision_BFMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BFMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BFMatcher> _self_ = *(self1);

    {
    Mat queryDescriptors;
    Mat trainDescriptors;
    vector_vector_DMatch matches;
    float maxDistance=0.f;
    Mat mask;
    bool compactResult=false;

    // const char* keywords[] = { "queryDescriptors", "trainDescriptors", "maxDistance", "mask", "compactResult", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "queryDescriptors"), queryDescriptors, ArgInfo("queryDescriptors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "trainDescriptors"), trainDescriptors, ArgInfo("trainDescriptors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxDistance"), maxDistance, ArgInfo("maxDistance", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "compactResult"), compactResult, ArgInfo("compactResult", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::radiusMatch(queryDescriptors, trainDescriptors, matches, maxDistance, mask, compactResult), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, matches);
        }
    }

    }
    

    {
    UMat queryDescriptors;
    UMat trainDescriptors;
    vector_vector_DMatch matches;
    float maxDistance=0.f;
    UMat mask;
    bool compactResult=false;

    // const char* keywords[] = { "queryDescriptors", "trainDescriptors", "maxDistance", "mask", "compactResult", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "queryDescriptors"), queryDescriptors, ArgInfo("queryDescriptors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "trainDescriptors"), trainDescriptors, ArgInfo("trainDescriptors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxDistance"), maxDistance, ArgInfo("maxDistance", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "compactResult"), compactResult, ArgInfo("compactResult", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::radiusMatch(queryDescriptors, trainDescriptors, matches, maxDistance, mask, compactResult), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, matches);
        }
    }

    }
    

    {
    Mat queryDescriptors;
    vector_vector_DMatch matches;
    float maxDistance=0.f;
    vector_Mat masks;
    bool compactResult=false;

    // const char* keywords[] = { "queryDescriptors", "maxDistance", "masks", "compactResult", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "queryDescriptors"), queryDescriptors, ArgInfo("queryDescriptors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxDistance"), maxDistance, ArgInfo("maxDistance", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "masks"), masks, ArgInfo("masks", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "compactResult"), compactResult, ArgInfo("compactResult", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::radiusMatch(queryDescriptors, matches, maxDistance, masks, compactResult), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, matches);
        }
    }

    }
    

    {
    UMat queryDescriptors;
    vector_vector_DMatch matches;
    float maxDistance=0.f;
    vector_UMat masks;
    bool compactResult=false;

    // const char* keywords[] = { "queryDescriptors", "maxDistance", "masks", "compactResult", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "queryDescriptors"), queryDescriptors, ArgInfo("queryDescriptors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxDistance"), maxDistance, ArgInfo("maxDistance", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "masks"), masks, ArgInfo("masks", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "compactResult"), compactResult, ArgInfo("compactResult", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::radiusMatch(queryDescriptors, matches, maxDistance, masks, compactResult), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, matches);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_bfMatcher_read(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BFMatcher> * self1 = 0;
    if (!evision_BFMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BFMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BFMatcher> _self_ = *(self1);

    {
    String fileName;

    // const char* keywords[] = { "fileName", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fileName"), fileName, ArgInfo("fileName", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::read(fileName), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "BFMatcher", success);
        }
    }

    }
    

    {
    FileNode arg1;

    // const char* keywords[] = { "arg1", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "arg1"), arg1, ArgInfo("arg1", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::read(arg1), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "BFMatcher", success);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_bfMatcher_save(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BFMatcher> * self1 = 0;
    if (!evision_BFMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BFMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BFMatcher> _self_ = *(self1);
    String filename;

    // const char* keywords[] = { "filename", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::save(filename), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "BFMatcher", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_bfMatcher_train(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BFMatcher> * self1 = 0;
    if (!evision_BFMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BFMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BFMatcher> _self_ = *(self1);

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::train(), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "BFMatcher", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_bfMatcher_write(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BFMatcher> * self1 = 0;
    if (!evision_BFMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BFMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BFMatcher> _self_ = *(self1);

    {
    String fileName;

    // const char* keywords[] = { "fileName", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fileName"), fileName, ArgInfo("fileName", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::write(fileName), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "BFMatcher", success);
        }
    }

    }
    

    {
    Ptr<FileStorage> fs;
    String name;

    // const char* keywords[] = { "fs", "name", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fs"), fs, ArgInfo("fs", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "name"), name, ArgInfo("name", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::write(fs, name), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "BFMatcher", success);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (BFMatcher)

template<>
struct Evision_Converter< Ptr<cv::BFMatcher> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::BFMatcher>& r)
    {
        return evision_BFMatcher_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::BFMatcher>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::BFMatcher> * dst_ = nullptr;
        if (evision_BFMatcher_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::BFMatcher> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// BOWImgDescriptorExtractor (Generic)
//================================================================================

// GetSet (BOWImgDescriptorExtractor)



// Methods (BOWImgDescriptorExtractor)

static ERL_NIF_TERM evision_cv_bowImgDescriptorExtractor_BOWImgDescriptorExtractor(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    Ptr<DescriptorExtractor> dextractor;
    Ptr<DescriptorMatcher> dmatcher;

    // const char* keywords[] = { "dextractor", "dmatcher", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "dextractor"), dextractor, ArgInfo("dextractor", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dmatcher"), dmatcher, ArgInfo("dmatcher", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::BOWImgDescriptorExtractor>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::BOWImgDescriptorExtractor>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::BOWImgDescriptorExtractor(dextractor, dmatcher)), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::BOWImgDescriptorExtractor>>(env, self->val, ret, "BOWImgDescriptorExtractor", success);;
        }
    }

    return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_bowImgDescriptorExtractor_compute(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BOWImgDescriptorExtractor> * self1 = 0;
    if (!evision_BOWImgDescriptorExtractor_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BOWImgDescriptorExtractor>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BOWImgDescriptorExtractor> _self_ = *(self1);
    Mat image;
    vector_KeyPoint keypoints;
    Mat imgDescriptor;

    // const char* keywords[] = { "image", "keypoints", "imgDescriptor", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints"), keypoints, ArgInfo("keypoints", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imgDescriptor"), imgDescriptor, ArgInfo("imgDescriptor", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute2(image, keypoints, imgDescriptor), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, imgDescriptor);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_bowImgDescriptorExtractor_descriptorSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BOWImgDescriptorExtractor> * self1 = 0;
    if (!evision_BOWImgDescriptorExtractor_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BOWImgDescriptorExtractor>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BOWImgDescriptorExtractor> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->descriptorSize(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_bowImgDescriptorExtractor_descriptorType(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BOWImgDescriptorExtractor> * self1 = 0;
    if (!evision_BOWImgDescriptorExtractor_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BOWImgDescriptorExtractor>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BOWImgDescriptorExtractor> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->descriptorType(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_bowImgDescriptorExtractor_getVocabulary(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BOWImgDescriptorExtractor> * self1 = 0;
    if (!evision_BOWImgDescriptorExtractor_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BOWImgDescriptorExtractor>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BOWImgDescriptorExtractor> _self_ = *(self1);
    Mat retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getVocabulary(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_bowImgDescriptorExtractor_setVocabulary(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BOWImgDescriptorExtractor> * self1 = 0;
    if (!evision_BOWImgDescriptorExtractor_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BOWImgDescriptorExtractor>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BOWImgDescriptorExtractor> _self_ = *(self1);
    Mat vocabulary;

    // const char* keywords[] = { "vocabulary", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "vocabulary"), vocabulary, ArgInfo("vocabulary", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setVocabulary(vocabulary), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "BOWImgDescriptorExtractor", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (BOWImgDescriptorExtractor)

template<>
struct Evision_Converter< Ptr<cv::BOWImgDescriptorExtractor> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::BOWImgDescriptorExtractor>& r)
    {
        return evision_BOWImgDescriptorExtractor_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::BOWImgDescriptorExtractor>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::BOWImgDescriptorExtractor> * dst_ = nullptr;
        if (evision_BOWImgDescriptorExtractor_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::BOWImgDescriptorExtractor> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// BOWKMeansTrainer (Generic)
//================================================================================

// GetSet (BOWKMeansTrainer)



// Methods (BOWKMeansTrainer)

static ERL_NIF_TERM evision_cv_bowKMeansTrainer_BOWKMeansTrainer(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    int clusterCount=0;
    TermCriteria termcrit;
    int attempts=3;
    int flags=KMEANS_PP_CENTERS;

    // const char* keywords[] = { "clusterCount", "termcrit", "attempts", "flags", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "clusterCount"), clusterCount, ArgInfo("clusterCount", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "termcrit"), termcrit, ArgInfo("termcrit", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "attempts"), attempts, ArgInfo("attempts", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::BOWKMeansTrainer>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::BOWKMeansTrainer>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::BOWKMeansTrainer(clusterCount, termcrit, attempts, flags)), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::BOWKMeansTrainer>>(env, self->val, ret, "BOWKMeansTrainer", success);;
        }
    }

    return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_bowKMeansTrainer_cluster(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BOWKMeansTrainer> * self1 = 0;
    if (!evision_BOWKMeansTrainer_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BOWKMeansTrainer>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BOWKMeansTrainer> _self_ = *(self1);

    {
    Mat retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->cluster(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Mat descriptors;
    Mat retval;

    // const char* keywords[] = { "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->cluster(descriptors), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (BOWKMeansTrainer)

template<>
struct Evision_Converter< Ptr<cv::BOWKMeansTrainer> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::BOWKMeansTrainer>& r)
    {
        return evision_BOWKMeansTrainer_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::BOWKMeansTrainer>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::BOWKMeansTrainer> * dst_ = nullptr;
        if (evision_BOWKMeansTrainer_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::BOWKMeansTrainer> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// BOWTrainer (Generic)
//================================================================================

// GetSet (BOWTrainer)



// Methods (BOWTrainer)

static ERL_NIF_TERM evision_cv_bowTrainer_add(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BOWTrainer> * self1 = 0;
    if (!evision_BOWTrainer_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BOWTrainer>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BOWTrainer> _self_ = *(self1);
    Mat descriptors;

    // const char* keywords[] = { "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->add(descriptors), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "BOWTrainer", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_bowTrainer_clear(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BOWTrainer> * self1 = 0;
    if (!evision_BOWTrainer_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BOWTrainer>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BOWTrainer> _self_ = *(self1);

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->clear(), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "BOWTrainer", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_bowTrainer_cluster(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BOWTrainer> * self1 = 0;
    if (!evision_BOWTrainer_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BOWTrainer>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BOWTrainer> _self_ = *(self1);

    {
    Mat retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->cluster(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Mat descriptors;
    Mat retval;

    // const char* keywords[] = { "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->cluster(descriptors), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_bowTrainer_descriptorsCount(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BOWTrainer> * self1 = 0;
    if (!evision_BOWTrainer_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BOWTrainer>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BOWTrainer> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->descriptorsCount(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_bowTrainer_getDescriptors(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BOWTrainer> * self1 = 0;
    if (!evision_BOWTrainer_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BOWTrainer>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BOWTrainer> _self_ = *(self1);
    std::vector<Mat> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getDescriptors(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (BOWTrainer)

template<>
struct Evision_Converter< Ptr<cv::BOWTrainer> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::BOWTrainer>& r)
    {
        return evision_BOWTrainer_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::BOWTrainer>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::BOWTrainer> * dst_ = nullptr;
        if (evision_BOWTrainer_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::BOWTrainer> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// BRISK (Generic)
//================================================================================

// GetSet (BRISK)



// Methods (BRISK)

static ERL_NIF_TERM evision_cv_brisk_compute(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BRISK> * self1 = 0;
    if (!evision_BRISK_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BRISK>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BRISK> _self_ = *(self1);

    {
    Mat image;
    vector_KeyPoint keypoints;
    Mat descriptors;

    // const char* keywords[] = { "image", "keypoints", "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints"), keypoints, ArgInfo("keypoints", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute(image, keypoints, descriptors), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }
    

    {
    UMat image;
    vector_KeyPoint keypoints;
    UMat descriptors;

    // const char* keywords[] = { "image", "keypoints", "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints"), keypoints, ArgInfo("keypoints", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute(image, keypoints, descriptors), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }
    

    {
    vector_Mat images;
    vector_vector_KeyPoint keypoints;
    vector_Mat descriptors;

    // const char* keywords[] = { "images", "keypoints", "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints"), keypoints, ArgInfo("keypoints", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute(images, keypoints, descriptors), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }
    

    {
    vector_UMat images;
    vector_vector_KeyPoint keypoints;
    vector_UMat descriptors;

    // const char* keywords[] = { "images", "keypoints", "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints"), keypoints, ArgInfo("keypoints", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute(images, keypoints, descriptors), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_brisk_create_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    {
    int thresh=30;
    int octaves=3;
    float patternScale=1.0f;
    Ptr<BRISK> retval;

    // const char* keywords[] = { "thresh", "octaves", "patternScale", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "thresh"), thresh, ArgInfo("thresh", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "octaves"), octaves, ArgInfo("octaves", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "patternScale"), patternScale, ArgInfo("patternScale", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::BRISK::create(thresh, octaves, patternScale), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    vector_float radiusList;
    vector_int numberList;
    float dMax=5.85f;
    float dMin=8.2f;
    vector_int indexChange=std::vector<int>();
    Ptr<BRISK> retval;

    // const char* keywords[] = { "radiusList", "numberList", "dMax", "dMin", "indexChange", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "radiusList"), radiusList, ArgInfo("radiusList", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "numberList"), numberList, ArgInfo("numberList", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dMax"), dMax, ArgInfo("dMax", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dMin"), dMin, ArgInfo("dMin", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "indexChange"), indexChange, ArgInfo("indexChange", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::BRISK::create(radiusList, numberList, dMax, dMin, indexChange), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    int thresh=0;
    int octaves=0;
    vector_float radiusList;
    vector_int numberList;
    float dMax=5.85f;
    float dMin=8.2f;
    vector_int indexChange=std::vector<int>();
    Ptr<BRISK> retval;

    // const char* keywords[] = { "thresh", "octaves", "radiusList", "numberList", "dMax", "dMin", "indexChange", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "thresh"), thresh, ArgInfo("thresh", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "octaves"), octaves, ArgInfo("octaves", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "radiusList"), radiusList, ArgInfo("radiusList", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "numberList"), numberList, ArgInfo("numberList", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dMax"), dMax, ArgInfo("dMax", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dMin"), dMin, ArgInfo("dMin", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "indexChange"), indexChange, ArgInfo("indexChange", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::BRISK::create(thresh, octaves, radiusList, numberList, dMax, dMin, indexChange), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_brisk_defaultNorm(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BRISK> * self1 = 0;
    if (!evision_BRISK_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BRISK>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BRISK> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->defaultNorm(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_brisk_descriptorSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BRISK> * self1 = 0;
    if (!evision_BRISK_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BRISK>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BRISK> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->descriptorSize(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_brisk_descriptorType(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BRISK> * self1 = 0;
    if (!evision_BRISK_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BRISK>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BRISK> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->descriptorType(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_brisk_detect(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BRISK> * self1 = 0;
    if (!evision_BRISK_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BRISK>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BRISK> _self_ = *(self1);

    {
    Mat image;
    vector_KeyPoint keypoints;
    Mat mask;

    // const char* keywords[] = { "image", "mask", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(image, keypoints, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, keypoints);
        }
    }

    }
    

    {
    UMat image;
    vector_KeyPoint keypoints;
    UMat mask;

    // const char* keywords[] = { "image", "mask", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(image, keypoints, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, keypoints);
        }
    }

    }
    

    {
    vector_Mat images;
    vector_vector_KeyPoint keypoints;
    vector_Mat masks;

    // const char* keywords[] = { "images", "masks", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "masks"), masks, ArgInfo("masks", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(images, keypoints, masks), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, keypoints);
        }
    }

    }
    

    {
    vector_UMat images;
    vector_vector_KeyPoint keypoints;
    vector_UMat masks;

    // const char* keywords[] = { "images", "masks", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "masks"), masks, ArgInfo("masks", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(images, keypoints, masks), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, keypoints);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_brisk_detectAndCompute(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BRISK> * self1 = 0;
    if (!evision_BRISK_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BRISK>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BRISK> _self_ = *(self1);

    {
    Mat image;
    Mat mask;
    vector_KeyPoint keypoints;
    Mat descriptors;
    bool useProvidedKeypoints=false;

    // const char* keywords[] = { "image", "mask", "descriptors", "useProvidedKeypoints", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "useProvidedKeypoints"), useProvidedKeypoints, ArgInfo("useProvidedKeypoints", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detectAndCompute(image, mask, keypoints, descriptors, useProvidedKeypoints), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }
    

    {
    UMat image;
    UMat mask;
    vector_KeyPoint keypoints;
    UMat descriptors;
    bool useProvidedKeypoints=false;

    // const char* keywords[] = { "image", "mask", "descriptors", "useProvidedKeypoints", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "useProvidedKeypoints"), useProvidedKeypoints, ArgInfo("useProvidedKeypoints", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detectAndCompute(image, mask, keypoints, descriptors, useProvidedKeypoints), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_brisk_empty(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BRISK> * self1 = 0;
    if (!evision_BRISK_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BRISK>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BRISK> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->empty(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_brisk_getDefaultName(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BRISK> * self1 = 0;
    if (!evision_BRISK_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BRISK>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BRISK> _self_ = *(self1);
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getDefaultName(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_brisk_getOctaves(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BRISK> * self1 = 0;
    if (!evision_BRISK_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BRISK>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BRISK> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getOctaves(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_brisk_getThreshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BRISK> * self1 = 0;
    if (!evision_BRISK_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BRISK>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BRISK> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getThreshold(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_brisk_read(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BRISK> * self1 = 0;
    if (!evision_BRISK_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BRISK>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BRISK> _self_ = *(self1);

    {
    String fileName;

    // const char* keywords[] = { "fileName", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fileName"), fileName, ArgInfo("fileName", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->read(fileName), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "BRISK", success);
        }
    }

    }
    

    {
    FileNode arg1;

    // const char* keywords[] = { "arg1", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "arg1"), arg1, ArgInfo("arg1", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->read(arg1), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "BRISK", success);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_brisk_setOctaves(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BRISK> * self1 = 0;
    if (!evision_BRISK_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BRISK>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BRISK> _self_ = *(self1);
    int octaves=0;

    // const char* keywords[] = { "octaves", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "octaves"), octaves, ArgInfo("octaves", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setOctaves(octaves), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "BRISK", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_brisk_setThreshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BRISK> * self1 = 0;
    if (!evision_BRISK_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BRISK>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BRISK> _self_ = *(self1);
    int threshold=0;

    // const char* keywords[] = { "threshold", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "threshold"), threshold, ArgInfo("threshold", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setThreshold(threshold), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "BRISK", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_brisk_write(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BRISK> * self1 = 0;
    if (!evision_BRISK_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BRISK>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BRISK> _self_ = *(self1);

    {
    String fileName;

    // const char* keywords[] = { "fileName", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fileName"), fileName, ArgInfo("fileName", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->write(fileName), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "BRISK", success);
        }
    }

    }
    

    {
    Ptr<FileStorage> fs;
    String name;

    // const char* keywords[] = { "fs", "name", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fs"), fs, ArgInfo("fs", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "name"), name, ArgInfo("name", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->write(fs, name), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "BRISK", success);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (BRISK)

template<>
struct Evision_Converter< Ptr<cv::BRISK> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::BRISK>& r)
    {
        return evision_BRISK_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::BRISK>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::BRISK> * dst_ = nullptr;
        if (evision_BRISK_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::BRISK> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// BackgroundSubtractor (Generic)
//================================================================================

// GetSet (BackgroundSubtractor)



// Methods (BackgroundSubtractor)

static ERL_NIF_TERM evision_cv_backgroundSubtractor_apply(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BackgroundSubtractor> * self1 = 0;
    if (!evision_BackgroundSubtractor_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BackgroundSubtractor>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BackgroundSubtractor> _self_ = *(self1);

    {
    Mat image;
    Mat fgmask;
    double learningRate=-1;

    // const char* keywords[] = { "image", "fgmask", "learningRate", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "fgmask"), fgmask, ArgInfo("fgmask", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "learningRate"), learningRate, ArgInfo("learningRate", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->apply(image, fgmask, learningRate), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, fgmask);
        }
    }

    }
    

    {
    UMat image;
    UMat fgmask;
    double learningRate=-1;

    // const char* keywords[] = { "image", "fgmask", "learningRate", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "fgmask"), fgmask, ArgInfo("fgmask", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "learningRate"), learningRate, ArgInfo("learningRate", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->apply(image, fgmask, learningRate), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, fgmask);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_backgroundSubtractor_clear(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BackgroundSubtractor> * self1 = 0;
    if (!evision_BackgroundSubtractor_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BackgroundSubtractor>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BackgroundSubtractor> _self_ = *(self1);

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::clear(), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "BackgroundSubtractor", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_backgroundSubtractor_empty(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BackgroundSubtractor> * self1 = 0;
    if (!evision_BackgroundSubtractor_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BackgroundSubtractor>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BackgroundSubtractor> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->Algorithm::empty(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_backgroundSubtractor_getBackgroundImage(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BackgroundSubtractor> * self1 = 0;
    if (!evision_BackgroundSubtractor_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BackgroundSubtractor>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BackgroundSubtractor> _self_ = *(self1);

    {
    Mat backgroundImage;

    // const char* keywords[] = { "backgroundImage", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "backgroundImage"), backgroundImage, ArgInfo("backgroundImage", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->getBackgroundImage(backgroundImage), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, backgroundImage);
        }
    }

    }
    

    {
    UMat backgroundImage;

    // const char* keywords[] = { "backgroundImage", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "backgroundImage"), backgroundImage, ArgInfo("backgroundImage", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->getBackgroundImage(backgroundImage), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, backgroundImage);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_backgroundSubtractor_getDefaultName(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BackgroundSubtractor> * self1 = 0;
    if (!evision_BackgroundSubtractor_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BackgroundSubtractor>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BackgroundSubtractor> _self_ = *(self1);
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->Algorithm::getDefaultName(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_backgroundSubtractor_read(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BackgroundSubtractor> * self1 = 0;
    if (!evision_BackgroundSubtractor_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BackgroundSubtractor>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BackgroundSubtractor> _self_ = *(self1);
    FileNode fn_;

    // const char* keywords[] = { "fn_", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fn_"), fn_, ArgInfo("fn_", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::read(fn_), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "BackgroundSubtractor", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_backgroundSubtractor_save(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BackgroundSubtractor> * self1 = 0;
    if (!evision_BackgroundSubtractor_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BackgroundSubtractor>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BackgroundSubtractor> _self_ = *(self1);
    String filename;

    // const char* keywords[] = { "filename", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::save(filename), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "BackgroundSubtractor", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_backgroundSubtractor_write(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BackgroundSubtractor> * self1 = 0;
    if (!evision_BackgroundSubtractor_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BackgroundSubtractor>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BackgroundSubtractor> _self_ = *(self1);
    Ptr<FileStorage> fs;
    String name;

    // const char* keywords[] = { "fs", "name", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fs"), fs, ArgInfo("fs", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "name"), name, ArgInfo("name", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::write(fs, name), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "BackgroundSubtractor", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (BackgroundSubtractor)

template<>
struct Evision_Converter< Ptr<cv::BackgroundSubtractor> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::BackgroundSubtractor>& r)
    {
        return evision_BackgroundSubtractor_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::BackgroundSubtractor>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::BackgroundSubtractor> * dst_ = nullptr;
        if (evision_BackgroundSubtractor_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::BackgroundSubtractor> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// BackgroundSubtractorKNN (Generic)
//================================================================================

// GetSet (BackgroundSubtractorKNN)



// Methods (BackgroundSubtractorKNN)

static ERL_NIF_TERM evision_cv_backgroundSubtractorKNN_getDetectShadows(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BackgroundSubtractorKNN> * self1 = 0;
    if (!evision_BackgroundSubtractorKNN_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BackgroundSubtractorKNN>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BackgroundSubtractorKNN> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getDetectShadows(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_backgroundSubtractorKNN_getDist2Threshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BackgroundSubtractorKNN> * self1 = 0;
    if (!evision_BackgroundSubtractorKNN_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BackgroundSubtractorKNN>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BackgroundSubtractorKNN> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getDist2Threshold(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_backgroundSubtractorKNN_getHistory(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BackgroundSubtractorKNN> * self1 = 0;
    if (!evision_BackgroundSubtractorKNN_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BackgroundSubtractorKNN>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BackgroundSubtractorKNN> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getHistory(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_backgroundSubtractorKNN_getNSamples(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BackgroundSubtractorKNN> * self1 = 0;
    if (!evision_BackgroundSubtractorKNN_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BackgroundSubtractorKNN>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BackgroundSubtractorKNN> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getNSamples(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_backgroundSubtractorKNN_getShadowThreshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BackgroundSubtractorKNN> * self1 = 0;
    if (!evision_BackgroundSubtractorKNN_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BackgroundSubtractorKNN>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BackgroundSubtractorKNN> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getShadowThreshold(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_backgroundSubtractorKNN_getShadowValue(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BackgroundSubtractorKNN> * self1 = 0;
    if (!evision_BackgroundSubtractorKNN_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BackgroundSubtractorKNN>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BackgroundSubtractorKNN> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getShadowValue(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_backgroundSubtractorKNN_getkNNSamples(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BackgroundSubtractorKNN> * self1 = 0;
    if (!evision_BackgroundSubtractorKNN_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BackgroundSubtractorKNN>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BackgroundSubtractorKNN> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getkNNSamples(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_backgroundSubtractorKNN_setDetectShadows(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BackgroundSubtractorKNN> * self1 = 0;
    if (!evision_BackgroundSubtractorKNN_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BackgroundSubtractorKNN>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BackgroundSubtractorKNN> _self_ = *(self1);
    bool detectShadows=0;

    // const char* keywords[] = { "detectShadows", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "detectShadows"), detectShadows, ArgInfo("detectShadows", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setDetectShadows(detectShadows), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "BackgroundSubtractorKNN", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_backgroundSubtractorKNN_setDist2Threshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BackgroundSubtractorKNN> * self1 = 0;
    if (!evision_BackgroundSubtractorKNN_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BackgroundSubtractorKNN>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BackgroundSubtractorKNN> _self_ = *(self1);
    double _dist2Threshold=0;

    // const char* keywords[] = { "_dist2Threshold", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "dist2Threshold"), _dist2Threshold, ArgInfo("_dist2Threshold", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setDist2Threshold(_dist2Threshold), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "BackgroundSubtractorKNN", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_backgroundSubtractorKNN_setHistory(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BackgroundSubtractorKNN> * self1 = 0;
    if (!evision_BackgroundSubtractorKNN_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BackgroundSubtractorKNN>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BackgroundSubtractorKNN> _self_ = *(self1);
    int history=0;

    // const char* keywords[] = { "history", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "history"), history, ArgInfo("history", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setHistory(history), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "BackgroundSubtractorKNN", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_backgroundSubtractorKNN_setNSamples(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BackgroundSubtractorKNN> * self1 = 0;
    if (!evision_BackgroundSubtractorKNN_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BackgroundSubtractorKNN>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BackgroundSubtractorKNN> _self_ = *(self1);
    int _nN=0;

    // const char* keywords[] = { "_nN", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "nN"), _nN, ArgInfo("_nN", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setNSamples(_nN), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "BackgroundSubtractorKNN", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_backgroundSubtractorKNN_setShadowThreshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BackgroundSubtractorKNN> * self1 = 0;
    if (!evision_BackgroundSubtractorKNN_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BackgroundSubtractorKNN>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BackgroundSubtractorKNN> _self_ = *(self1);
    double threshold=0;

    // const char* keywords[] = { "threshold", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "threshold"), threshold, ArgInfo("threshold", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setShadowThreshold(threshold), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "BackgroundSubtractorKNN", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_backgroundSubtractorKNN_setShadowValue(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BackgroundSubtractorKNN> * self1 = 0;
    if (!evision_BackgroundSubtractorKNN_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BackgroundSubtractorKNN>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BackgroundSubtractorKNN> _self_ = *(self1);
    int value=0;

    // const char* keywords[] = { "value", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "value"), value, ArgInfo("value", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setShadowValue(value), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "BackgroundSubtractorKNN", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_backgroundSubtractorKNN_setkNNSamples(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BackgroundSubtractorKNN> * self1 = 0;
    if (!evision_BackgroundSubtractorKNN_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BackgroundSubtractorKNN>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BackgroundSubtractorKNN> _self_ = *(self1);
    int _nkNN=0;

    // const char* keywords[] = { "_nkNN", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "nkNN"), _nkNN, ArgInfo("_nkNN", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setkNNSamples(_nkNN), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "BackgroundSubtractorKNN", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (BackgroundSubtractorKNN)

template<>
struct Evision_Converter< Ptr<cv::BackgroundSubtractorKNN> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::BackgroundSubtractorKNN>& r)
    {
        return evision_BackgroundSubtractorKNN_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::BackgroundSubtractorKNN>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::BackgroundSubtractorKNN> * dst_ = nullptr;
        if (evision_BackgroundSubtractorKNN_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::BackgroundSubtractorKNN> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// BackgroundSubtractorMOG2 (Generic)
//================================================================================

// GetSet (BackgroundSubtractorMOG2)



// Methods (BackgroundSubtractorMOG2)

static ERL_NIF_TERM evision_cv_backgroundSubtractorMOG2_apply(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BackgroundSubtractorMOG2> * self1 = 0;
    if (!evision_BackgroundSubtractorMOG2_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BackgroundSubtractorMOG2>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BackgroundSubtractorMOG2> _self_ = *(self1);

    {
    Mat image;
    Mat fgmask;
    double learningRate=-1;

    // const char* keywords[] = { "image", "fgmask", "learningRate", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "fgmask"), fgmask, ArgInfo("fgmask", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "learningRate"), learningRate, ArgInfo("learningRate", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->apply(image, fgmask, learningRate), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, fgmask);
        }
    }

    }
    

    {
    UMat image;
    UMat fgmask;
    double learningRate=-1;

    // const char* keywords[] = { "image", "fgmask", "learningRate", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "fgmask"), fgmask, ArgInfo("fgmask", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "learningRate"), learningRate, ArgInfo("learningRate", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->apply(image, fgmask, learningRate), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, fgmask);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_backgroundSubtractorMOG2_getBackgroundRatio(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BackgroundSubtractorMOG2> * self1 = 0;
    if (!evision_BackgroundSubtractorMOG2_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BackgroundSubtractorMOG2>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BackgroundSubtractorMOG2> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getBackgroundRatio(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_backgroundSubtractorMOG2_getComplexityReductionThreshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BackgroundSubtractorMOG2> * self1 = 0;
    if (!evision_BackgroundSubtractorMOG2_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BackgroundSubtractorMOG2>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BackgroundSubtractorMOG2> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getComplexityReductionThreshold(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_backgroundSubtractorMOG2_getDetectShadows(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BackgroundSubtractorMOG2> * self1 = 0;
    if (!evision_BackgroundSubtractorMOG2_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BackgroundSubtractorMOG2>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BackgroundSubtractorMOG2> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getDetectShadows(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_backgroundSubtractorMOG2_getHistory(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BackgroundSubtractorMOG2> * self1 = 0;
    if (!evision_BackgroundSubtractorMOG2_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BackgroundSubtractorMOG2>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BackgroundSubtractorMOG2> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getHistory(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_backgroundSubtractorMOG2_getNMixtures(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BackgroundSubtractorMOG2> * self1 = 0;
    if (!evision_BackgroundSubtractorMOG2_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BackgroundSubtractorMOG2>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BackgroundSubtractorMOG2> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getNMixtures(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_backgroundSubtractorMOG2_getShadowThreshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BackgroundSubtractorMOG2> * self1 = 0;
    if (!evision_BackgroundSubtractorMOG2_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BackgroundSubtractorMOG2>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BackgroundSubtractorMOG2> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getShadowThreshold(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_backgroundSubtractorMOG2_getShadowValue(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BackgroundSubtractorMOG2> * self1 = 0;
    if (!evision_BackgroundSubtractorMOG2_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BackgroundSubtractorMOG2>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BackgroundSubtractorMOG2> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getShadowValue(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_backgroundSubtractorMOG2_getVarInit(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BackgroundSubtractorMOG2> * self1 = 0;
    if (!evision_BackgroundSubtractorMOG2_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BackgroundSubtractorMOG2>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BackgroundSubtractorMOG2> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getVarInit(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_backgroundSubtractorMOG2_getVarMax(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BackgroundSubtractorMOG2> * self1 = 0;
    if (!evision_BackgroundSubtractorMOG2_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BackgroundSubtractorMOG2>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BackgroundSubtractorMOG2> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getVarMax(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_backgroundSubtractorMOG2_getVarMin(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BackgroundSubtractorMOG2> * self1 = 0;
    if (!evision_BackgroundSubtractorMOG2_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BackgroundSubtractorMOG2>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BackgroundSubtractorMOG2> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getVarMin(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_backgroundSubtractorMOG2_getVarThreshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BackgroundSubtractorMOG2> * self1 = 0;
    if (!evision_BackgroundSubtractorMOG2_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BackgroundSubtractorMOG2>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BackgroundSubtractorMOG2> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getVarThreshold(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_backgroundSubtractorMOG2_getVarThresholdGen(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BackgroundSubtractorMOG2> * self1 = 0;
    if (!evision_BackgroundSubtractorMOG2_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BackgroundSubtractorMOG2>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BackgroundSubtractorMOG2> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getVarThresholdGen(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_backgroundSubtractorMOG2_setBackgroundRatio(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BackgroundSubtractorMOG2> * self1 = 0;
    if (!evision_BackgroundSubtractorMOG2_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BackgroundSubtractorMOG2>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BackgroundSubtractorMOG2> _self_ = *(self1);
    double ratio=0;

    // const char* keywords[] = { "ratio", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "ratio"), ratio, ArgInfo("ratio", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setBackgroundRatio(ratio), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "BackgroundSubtractorMOG2", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_backgroundSubtractorMOG2_setComplexityReductionThreshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BackgroundSubtractorMOG2> * self1 = 0;
    if (!evision_BackgroundSubtractorMOG2_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BackgroundSubtractorMOG2>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BackgroundSubtractorMOG2> _self_ = *(self1);
    double ct=0;

    // const char* keywords[] = { "ct", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "ct"), ct, ArgInfo("ct", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setComplexityReductionThreshold(ct), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "BackgroundSubtractorMOG2", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_backgroundSubtractorMOG2_setDetectShadows(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BackgroundSubtractorMOG2> * self1 = 0;
    if (!evision_BackgroundSubtractorMOG2_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BackgroundSubtractorMOG2>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BackgroundSubtractorMOG2> _self_ = *(self1);
    bool detectShadows=0;

    // const char* keywords[] = { "detectShadows", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "detectShadows"), detectShadows, ArgInfo("detectShadows", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setDetectShadows(detectShadows), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "BackgroundSubtractorMOG2", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_backgroundSubtractorMOG2_setHistory(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BackgroundSubtractorMOG2> * self1 = 0;
    if (!evision_BackgroundSubtractorMOG2_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BackgroundSubtractorMOG2>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BackgroundSubtractorMOG2> _self_ = *(self1);
    int history=0;

    // const char* keywords[] = { "history", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "history"), history, ArgInfo("history", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setHistory(history), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "BackgroundSubtractorMOG2", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_backgroundSubtractorMOG2_setNMixtures(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BackgroundSubtractorMOG2> * self1 = 0;
    if (!evision_BackgroundSubtractorMOG2_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BackgroundSubtractorMOG2>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BackgroundSubtractorMOG2> _self_ = *(self1);
    int nmixtures=0;

    // const char* keywords[] = { "nmixtures", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "nmixtures"), nmixtures, ArgInfo("nmixtures", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setNMixtures(nmixtures), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "BackgroundSubtractorMOG2", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_backgroundSubtractorMOG2_setShadowThreshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BackgroundSubtractorMOG2> * self1 = 0;
    if (!evision_BackgroundSubtractorMOG2_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BackgroundSubtractorMOG2>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BackgroundSubtractorMOG2> _self_ = *(self1);
    double threshold=0;

    // const char* keywords[] = { "threshold", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "threshold"), threshold, ArgInfo("threshold", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setShadowThreshold(threshold), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "BackgroundSubtractorMOG2", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_backgroundSubtractorMOG2_setShadowValue(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BackgroundSubtractorMOG2> * self1 = 0;
    if (!evision_BackgroundSubtractorMOG2_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BackgroundSubtractorMOG2>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BackgroundSubtractorMOG2> _self_ = *(self1);
    int value=0;

    // const char* keywords[] = { "value", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "value"), value, ArgInfo("value", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setShadowValue(value), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "BackgroundSubtractorMOG2", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_backgroundSubtractorMOG2_setVarInit(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BackgroundSubtractorMOG2> * self1 = 0;
    if (!evision_BackgroundSubtractorMOG2_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BackgroundSubtractorMOG2>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BackgroundSubtractorMOG2> _self_ = *(self1);
    double varInit=0;

    // const char* keywords[] = { "varInit", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "varInit"), varInit, ArgInfo("varInit", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setVarInit(varInit), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "BackgroundSubtractorMOG2", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_backgroundSubtractorMOG2_setVarMax(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BackgroundSubtractorMOG2> * self1 = 0;
    if (!evision_BackgroundSubtractorMOG2_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BackgroundSubtractorMOG2>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BackgroundSubtractorMOG2> _self_ = *(self1);
    double varMax=0;

    // const char* keywords[] = { "varMax", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "varMax"), varMax, ArgInfo("varMax", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setVarMax(varMax), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "BackgroundSubtractorMOG2", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_backgroundSubtractorMOG2_setVarMin(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BackgroundSubtractorMOG2> * self1 = 0;
    if (!evision_BackgroundSubtractorMOG2_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BackgroundSubtractorMOG2>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BackgroundSubtractorMOG2> _self_ = *(self1);
    double varMin=0;

    // const char* keywords[] = { "varMin", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "varMin"), varMin, ArgInfo("varMin", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setVarMin(varMin), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "BackgroundSubtractorMOG2", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_backgroundSubtractorMOG2_setVarThreshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BackgroundSubtractorMOG2> * self1 = 0;
    if (!evision_BackgroundSubtractorMOG2_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BackgroundSubtractorMOG2>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BackgroundSubtractorMOG2> _self_ = *(self1);
    double varThreshold=0;

    // const char* keywords[] = { "varThreshold", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "varThreshold"), varThreshold, ArgInfo("varThreshold", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setVarThreshold(varThreshold), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "BackgroundSubtractorMOG2", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_backgroundSubtractorMOG2_setVarThresholdGen(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BackgroundSubtractorMOG2> * self1 = 0;
    if (!evision_BackgroundSubtractorMOG2_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BackgroundSubtractorMOG2>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BackgroundSubtractorMOG2> _self_ = *(self1);
    double varThresholdGen=0;

    // const char* keywords[] = { "varThresholdGen", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "varThresholdGen"), varThresholdGen, ArgInfo("varThresholdGen", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setVarThresholdGen(varThresholdGen), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "BackgroundSubtractorMOG2", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (BackgroundSubtractorMOG2)

template<>
struct Evision_Converter< Ptr<cv::BackgroundSubtractorMOG2> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::BackgroundSubtractorMOG2>& r)
    {
        return evision_BackgroundSubtractorMOG2_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::BackgroundSubtractorMOG2>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::BackgroundSubtractorMOG2> * dst_ = nullptr;
        if (evision_BackgroundSubtractorMOG2_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::BackgroundSubtractorMOG2> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// BaseCascadeClassifier (Generic)
//================================================================================

// GetSet (BaseCascadeClassifier)



// Methods (BaseCascadeClassifier)

static ERL_NIF_TERM evision_cv_baseCascadeClassifier_clear(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BaseCascadeClassifier> * self1 = 0;
    if (!evision_BaseCascadeClassifier_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BaseCascadeClassifier>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BaseCascadeClassifier> _self_ = *(self1);

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::clear(), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "BaseCascadeClassifier", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_baseCascadeClassifier_empty(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BaseCascadeClassifier> * self1 = 0;
    if (!evision_BaseCascadeClassifier_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BaseCascadeClassifier>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BaseCascadeClassifier> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->Algorithm::empty(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_baseCascadeClassifier_getDefaultName(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BaseCascadeClassifier> * self1 = 0;
    if (!evision_BaseCascadeClassifier_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BaseCascadeClassifier>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BaseCascadeClassifier> _self_ = *(self1);
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->Algorithm::getDefaultName(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_baseCascadeClassifier_read(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BaseCascadeClassifier> * self1 = 0;
    if (!evision_BaseCascadeClassifier_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BaseCascadeClassifier>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BaseCascadeClassifier> _self_ = *(self1);
    FileNode fn_;

    // const char* keywords[] = { "fn_", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fn_"), fn_, ArgInfo("fn_", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::read(fn_), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "BaseCascadeClassifier", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_baseCascadeClassifier_save(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BaseCascadeClassifier> * self1 = 0;
    if (!evision_BaseCascadeClassifier_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BaseCascadeClassifier>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BaseCascadeClassifier> _self_ = *(self1);
    String filename;

    // const char* keywords[] = { "filename", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::save(filename), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "BaseCascadeClassifier", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_baseCascadeClassifier_write(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::BaseCascadeClassifier> * self1 = 0;
    if (!evision_BaseCascadeClassifier_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::BaseCascadeClassifier>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::BaseCascadeClassifier> _self_ = *(self1);
    Ptr<FileStorage> fs;
    String name;

    // const char* keywords[] = { "fs", "name", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fs"), fs, ArgInfo("fs", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "name"), name, ArgInfo("name", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::write(fs, name), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "BaseCascadeClassifier", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (BaseCascadeClassifier)

template<>
struct Evision_Converter< Ptr<cv::BaseCascadeClassifier> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::BaseCascadeClassifier>& r)
    {
        return evision_BaseCascadeClassifier_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::BaseCascadeClassifier>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::BaseCascadeClassifier> * dst_ = nullptr;
        if (evision_BaseCascadeClassifier_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::BaseCascadeClassifier> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// CLAHE (Generic)
//================================================================================

// GetSet (CLAHE)



// Methods (CLAHE)

static ERL_NIF_TERM evision_cv_clahe_apply(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::CLAHE> * self1 = 0;
    if (!evision_CLAHE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::CLAHE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::CLAHE> _self_ = *(self1);

    {
    Mat src;
    Mat dst;

    // const char* keywords[] = { "src", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->apply(src, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    UMat src;
    UMat dst;

    // const char* keywords[] = { "src", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->apply(src, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_clahe_clear(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::CLAHE> * self1 = 0;
    if (!evision_CLAHE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::CLAHE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::CLAHE> _self_ = *(self1);

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::clear(), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "CLAHE", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_clahe_collectGarbage(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::CLAHE> * self1 = 0;
    if (!evision_CLAHE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::CLAHE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::CLAHE> _self_ = *(self1);

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->collectGarbage(), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "CLAHE", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_clahe_empty(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::CLAHE> * self1 = 0;
    if (!evision_CLAHE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::CLAHE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::CLAHE> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->Algorithm::empty(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_clahe_getClipLimit(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::CLAHE> * self1 = 0;
    if (!evision_CLAHE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::CLAHE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::CLAHE> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getClipLimit(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_clahe_getDefaultName(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::CLAHE> * self1 = 0;
    if (!evision_CLAHE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::CLAHE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::CLAHE> _self_ = *(self1);
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->Algorithm::getDefaultName(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_clahe_getTilesGridSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::CLAHE> * self1 = 0;
    if (!evision_CLAHE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::CLAHE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::CLAHE> _self_ = *(self1);
    Size retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getTilesGridSize(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_clahe_read(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::CLAHE> * self1 = 0;
    if (!evision_CLAHE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::CLAHE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::CLAHE> _self_ = *(self1);
    FileNode fn_;

    // const char* keywords[] = { "fn_", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fn_"), fn_, ArgInfo("fn_", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::read(fn_), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "CLAHE", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_clahe_save(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::CLAHE> * self1 = 0;
    if (!evision_CLAHE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::CLAHE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::CLAHE> _self_ = *(self1);
    String filename;

    // const char* keywords[] = { "filename", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::save(filename), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "CLAHE", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_clahe_setClipLimit(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::CLAHE> * self1 = 0;
    if (!evision_CLAHE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::CLAHE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::CLAHE> _self_ = *(self1);
    double clipLimit=0;

    // const char* keywords[] = { "clipLimit", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "clipLimit"), clipLimit, ArgInfo("clipLimit", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setClipLimit(clipLimit), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "CLAHE", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_clahe_setTilesGridSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::CLAHE> * self1 = 0;
    if (!evision_CLAHE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::CLAHE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::CLAHE> _self_ = *(self1);
    Size tileGridSize;

    // const char* keywords[] = { "tileGridSize", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "tileGridSize"), tileGridSize, ArgInfo("tileGridSize", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setTilesGridSize(tileGridSize), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "CLAHE", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_clahe_write(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::CLAHE> * self1 = 0;
    if (!evision_CLAHE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::CLAHE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::CLAHE> _self_ = *(self1);
    Ptr<FileStorage> fs;
    String name;

    // const char* keywords[] = { "fs", "name", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fs"), fs, ArgInfo("fs", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "name"), name, ArgInfo("name", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::write(fs, name), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "CLAHE", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (CLAHE)

template<>
struct Evision_Converter< Ptr<cv::CLAHE> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::CLAHE>& r)
    {
        return evision_CLAHE_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::CLAHE>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::CLAHE> * dst_ = nullptr;
        if (evision_CLAHE_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::CLAHE> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// CalibrateCRF (Generic)
//================================================================================

// GetSet (CalibrateCRF)



// Methods (CalibrateCRF)

static ERL_NIF_TERM evision_cv_calibrateCRF_clear(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::CalibrateCRF> * self1 = 0;
    if (!evision_CalibrateCRF_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::CalibrateCRF>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::CalibrateCRF> _self_ = *(self1);

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::clear(), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "CalibrateCRF", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_calibrateCRF_empty(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::CalibrateCRF> * self1 = 0;
    if (!evision_CalibrateCRF_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::CalibrateCRF>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::CalibrateCRF> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->Algorithm::empty(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_calibrateCRF_getDefaultName(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::CalibrateCRF> * self1 = 0;
    if (!evision_CalibrateCRF_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::CalibrateCRF>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::CalibrateCRF> _self_ = *(self1);
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->Algorithm::getDefaultName(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_calibrateCRF_process(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::CalibrateCRF> * self1 = 0;
    if (!evision_CalibrateCRF_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::CalibrateCRF>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::CalibrateCRF> _self_ = *(self1);

    {
    vector_Mat src;
    Mat dst;
    Mat times;

    // const char* keywords[] = { "src", "times", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "times"), times, ArgInfo("times", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->process(src, dst, times), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    vector_UMat src;
    UMat dst;
    UMat times;

    // const char* keywords[] = { "src", "times", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "times"), times, ArgInfo("times", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->process(src, dst, times), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_calibrateCRF_read(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::CalibrateCRF> * self1 = 0;
    if (!evision_CalibrateCRF_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::CalibrateCRF>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::CalibrateCRF> _self_ = *(self1);
    FileNode fn_;

    // const char* keywords[] = { "fn_", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fn_"), fn_, ArgInfo("fn_", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::read(fn_), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "CalibrateCRF", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_calibrateCRF_save(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::CalibrateCRF> * self1 = 0;
    if (!evision_CalibrateCRF_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::CalibrateCRF>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::CalibrateCRF> _self_ = *(self1);
    String filename;

    // const char* keywords[] = { "filename", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::save(filename), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "CalibrateCRF", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_calibrateCRF_write(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::CalibrateCRF> * self1 = 0;
    if (!evision_CalibrateCRF_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::CalibrateCRF>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::CalibrateCRF> _self_ = *(self1);
    Ptr<FileStorage> fs;
    String name;

    // const char* keywords[] = { "fs", "name", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fs"), fs, ArgInfo("fs", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "name"), name, ArgInfo("name", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::write(fs, name), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "CalibrateCRF", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (CalibrateCRF)

template<>
struct Evision_Converter< Ptr<cv::CalibrateCRF> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::CalibrateCRF>& r)
    {
        return evision_CalibrateCRF_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::CalibrateCRF>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::CalibrateCRF> * dst_ = nullptr;
        if (evision_CalibrateCRF_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::CalibrateCRF> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// CalibrateDebevec (Generic)
//================================================================================

// GetSet (CalibrateDebevec)



// Methods (CalibrateDebevec)

static ERL_NIF_TERM evision_cv_calibrateDebevec_clear(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::CalibrateDebevec> * self1 = 0;
    if (!evision_CalibrateDebevec_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::CalibrateDebevec>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::CalibrateDebevec> _self_ = *(self1);

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::clear(), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "CalibrateDebevec", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_calibrateDebevec_empty(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::CalibrateDebevec> * self1 = 0;
    if (!evision_CalibrateDebevec_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::CalibrateDebevec>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::CalibrateDebevec> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->Algorithm::empty(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_calibrateDebevec_getDefaultName(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::CalibrateDebevec> * self1 = 0;
    if (!evision_CalibrateDebevec_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::CalibrateDebevec>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::CalibrateDebevec> _self_ = *(self1);
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->Algorithm::getDefaultName(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_calibrateDebevec_getLambda(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::CalibrateDebevec> * self1 = 0;
    if (!evision_CalibrateDebevec_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::CalibrateDebevec>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::CalibrateDebevec> _self_ = *(self1);
    float retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getLambda(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_calibrateDebevec_getRandom(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::CalibrateDebevec> * self1 = 0;
    if (!evision_CalibrateDebevec_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::CalibrateDebevec>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::CalibrateDebevec> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getRandom(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_calibrateDebevec_getSamples(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::CalibrateDebevec> * self1 = 0;
    if (!evision_CalibrateDebevec_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::CalibrateDebevec>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::CalibrateDebevec> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getSamples(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_calibrateDebevec_process(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::CalibrateDebevec> * self1 = 0;
    if (!evision_CalibrateDebevec_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::CalibrateDebevec>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::CalibrateDebevec> _self_ = *(self1);

    {
    vector_Mat src;
    Mat dst;
    Mat times;

    // const char* keywords[] = { "src", "times", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "times"), times, ArgInfo("times", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->process(src, dst, times), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    vector_UMat src;
    UMat dst;
    UMat times;

    // const char* keywords[] = { "src", "times", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "times"), times, ArgInfo("times", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->process(src, dst, times), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_calibrateDebevec_read(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::CalibrateDebevec> * self1 = 0;
    if (!evision_CalibrateDebevec_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::CalibrateDebevec>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::CalibrateDebevec> _self_ = *(self1);
    FileNode fn_;

    // const char* keywords[] = { "fn_", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fn_"), fn_, ArgInfo("fn_", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::read(fn_), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "CalibrateDebevec", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_calibrateDebevec_save(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::CalibrateDebevec> * self1 = 0;
    if (!evision_CalibrateDebevec_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::CalibrateDebevec>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::CalibrateDebevec> _self_ = *(self1);
    String filename;

    // const char* keywords[] = { "filename", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::save(filename), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "CalibrateDebevec", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_calibrateDebevec_setLambda(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::CalibrateDebevec> * self1 = 0;
    if (!evision_CalibrateDebevec_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::CalibrateDebevec>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::CalibrateDebevec> _self_ = *(self1);
    float lambda=0.f;

    // const char* keywords[] = { "lambda", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "lambda"), lambda, ArgInfo("lambda", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setLambda(lambda), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "CalibrateDebevec", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_calibrateDebevec_setRandom(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::CalibrateDebevec> * self1 = 0;
    if (!evision_CalibrateDebevec_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::CalibrateDebevec>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::CalibrateDebevec> _self_ = *(self1);
    bool random=0;

    // const char* keywords[] = { "random", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "random"), random, ArgInfo("random", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setRandom(random), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "CalibrateDebevec", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_calibrateDebevec_setSamples(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::CalibrateDebevec> * self1 = 0;
    if (!evision_CalibrateDebevec_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::CalibrateDebevec>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::CalibrateDebevec> _self_ = *(self1);
    int samples=0;

    // const char* keywords[] = { "samples", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setSamples(samples), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "CalibrateDebevec", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_calibrateDebevec_write(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::CalibrateDebevec> * self1 = 0;
    if (!evision_CalibrateDebevec_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::CalibrateDebevec>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::CalibrateDebevec> _self_ = *(self1);
    Ptr<FileStorage> fs;
    String name;

    // const char* keywords[] = { "fs", "name", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fs"), fs, ArgInfo("fs", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "name"), name, ArgInfo("name", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::write(fs, name), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "CalibrateDebevec", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (CalibrateDebevec)

template<>
struct Evision_Converter< Ptr<cv::CalibrateDebevec> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::CalibrateDebevec>& r)
    {
        return evision_CalibrateDebevec_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::CalibrateDebevec>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::CalibrateDebevec> * dst_ = nullptr;
        if (evision_CalibrateDebevec_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::CalibrateDebevec> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// CalibrateRobertson (Generic)
//================================================================================

// GetSet (CalibrateRobertson)



// Methods (CalibrateRobertson)

static ERL_NIF_TERM evision_cv_calibrateRobertson_clear(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::CalibrateRobertson> * self1 = 0;
    if (!evision_CalibrateRobertson_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::CalibrateRobertson>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::CalibrateRobertson> _self_ = *(self1);

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::clear(), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "CalibrateRobertson", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_calibrateRobertson_empty(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::CalibrateRobertson> * self1 = 0;
    if (!evision_CalibrateRobertson_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::CalibrateRobertson>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::CalibrateRobertson> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->Algorithm::empty(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_calibrateRobertson_getDefaultName(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::CalibrateRobertson> * self1 = 0;
    if (!evision_CalibrateRobertson_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::CalibrateRobertson>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::CalibrateRobertson> _self_ = *(self1);
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->Algorithm::getDefaultName(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_calibrateRobertson_getMaxIter(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::CalibrateRobertson> * self1 = 0;
    if (!evision_CalibrateRobertson_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::CalibrateRobertson>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::CalibrateRobertson> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getMaxIter(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_calibrateRobertson_getRadiance(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::CalibrateRobertson> * self1 = 0;
    if (!evision_CalibrateRobertson_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::CalibrateRobertson>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::CalibrateRobertson> _self_ = *(self1);
    Mat retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getRadiance(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_calibrateRobertson_getThreshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::CalibrateRobertson> * self1 = 0;
    if (!evision_CalibrateRobertson_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::CalibrateRobertson>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::CalibrateRobertson> _self_ = *(self1);
    float retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getThreshold(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_calibrateRobertson_process(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::CalibrateRobertson> * self1 = 0;
    if (!evision_CalibrateRobertson_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::CalibrateRobertson>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::CalibrateRobertson> _self_ = *(self1);

    {
    vector_Mat src;
    Mat dst;
    Mat times;

    // const char* keywords[] = { "src", "times", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "times"), times, ArgInfo("times", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->process(src, dst, times), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    vector_UMat src;
    UMat dst;
    UMat times;

    // const char* keywords[] = { "src", "times", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "times"), times, ArgInfo("times", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->process(src, dst, times), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_calibrateRobertson_read(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::CalibrateRobertson> * self1 = 0;
    if (!evision_CalibrateRobertson_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::CalibrateRobertson>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::CalibrateRobertson> _self_ = *(self1);
    FileNode fn_;

    // const char* keywords[] = { "fn_", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fn_"), fn_, ArgInfo("fn_", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::read(fn_), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "CalibrateRobertson", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_calibrateRobertson_save(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::CalibrateRobertson> * self1 = 0;
    if (!evision_CalibrateRobertson_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::CalibrateRobertson>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::CalibrateRobertson> _self_ = *(self1);
    String filename;

    // const char* keywords[] = { "filename", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::save(filename), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "CalibrateRobertson", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_calibrateRobertson_setMaxIter(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::CalibrateRobertson> * self1 = 0;
    if (!evision_CalibrateRobertson_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::CalibrateRobertson>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::CalibrateRobertson> _self_ = *(self1);
    int max_iter=0;

    // const char* keywords[] = { "max_iter", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "max_iter"), max_iter, ArgInfo("max_iter", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setMaxIter(max_iter), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "CalibrateRobertson", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_calibrateRobertson_setThreshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::CalibrateRobertson> * self1 = 0;
    if (!evision_CalibrateRobertson_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::CalibrateRobertson>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::CalibrateRobertson> _self_ = *(self1);
    float threshold=0.f;

    // const char* keywords[] = { "threshold", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "threshold"), threshold, ArgInfo("threshold", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setThreshold(threshold), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "CalibrateRobertson", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_calibrateRobertson_write(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::CalibrateRobertson> * self1 = 0;
    if (!evision_CalibrateRobertson_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::CalibrateRobertson>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::CalibrateRobertson> _self_ = *(self1);
    Ptr<FileStorage> fs;
    String name;

    // const char* keywords[] = { "fs", "name", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fs"), fs, ArgInfo("fs", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "name"), name, ArgInfo("name", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::write(fs, name), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "CalibrateRobertson", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (CalibrateRobertson)

template<>
struct Evision_Converter< Ptr<cv::CalibrateRobertson> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::CalibrateRobertson>& r)
    {
        return evision_CalibrateRobertson_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::CalibrateRobertson>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::CalibrateRobertson> * dst_ = nullptr;
        if (evision_CalibrateRobertson_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::CalibrateRobertson> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// CascadeClassifier (Generic)
//================================================================================

// GetSet (CascadeClassifier)



// Methods (CascadeClassifier)

static ERL_NIF_TERM evision_cv_cascadeClassifier_CascadeClassifier(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    {

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        evision_res<Ptr<cv::CascadeClassifier>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::CascadeClassifier>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::CascadeClassifier()), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::CascadeClassifier>>(env, self->val, ret, "CascadeClassifier", success);;
        }
    }

    }
    

    {
    String filename;

    // const char* keywords[] = { "filename", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::CascadeClassifier>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::CascadeClassifier>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::CascadeClassifier(filename)), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::CascadeClassifier>>(env, self->val, ret, "CascadeClassifier", success);;
        }
    }

    }

    return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cascadeClassifier_convert_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    String oldcascade;
    String newcascade;
    bool retval;

    // const char* keywords[] = { "oldcascade", "newcascade", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "oldcascade"), oldcascade, ArgInfo("oldcascade", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "newcascade"), newcascade, ArgInfo("newcascade", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::CascadeClassifier::convert(oldcascade, newcascade), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cascadeClassifier_detectMultiScale(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::CascadeClassifier> * self1 = 0;
    if (!evision_CascadeClassifier_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::CascadeClassifier>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::CascadeClassifier> _self_ = *(self1);

    {
    Mat image;
    vector_Rect objects;
    double scaleFactor=1.1;
    int minNeighbors=3;
    int flags=0;
    Size minSize;
    Size maxSize;

    // const char* keywords[] = { "image", "scaleFactor", "minNeighbors", "flags", "minSize", "maxSize", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scaleFactor"), scaleFactor, ArgInfo("scaleFactor", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minNeighbors"), minNeighbors, ArgInfo("minNeighbors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minSize"), minSize, ArgInfo("minSize", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxSize"), maxSize, ArgInfo("maxSize", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detectMultiScale(image, objects, scaleFactor, minNeighbors, flags, minSize, maxSize), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, objects);
        }
    }

    }
    

    {
    UMat image;
    vector_Rect objects;
    double scaleFactor=1.1;
    int minNeighbors=3;
    int flags=0;
    Size minSize;
    Size maxSize;

    // const char* keywords[] = { "image", "scaleFactor", "minNeighbors", "flags", "minSize", "maxSize", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scaleFactor"), scaleFactor, ArgInfo("scaleFactor", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minNeighbors"), minNeighbors, ArgInfo("minNeighbors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minSize"), minSize, ArgInfo("minSize", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxSize"), maxSize, ArgInfo("maxSize", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detectMultiScale(image, objects, scaleFactor, minNeighbors, flags, minSize, maxSize), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, objects);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cascadeClassifier_detectMultiScale2(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::CascadeClassifier> * self1 = 0;
    if (!evision_CascadeClassifier_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::CascadeClassifier>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::CascadeClassifier> _self_ = *(self1);

    {
    Mat image;
    vector_Rect objects;
    vector_int numDetections;
    double scaleFactor=1.1;
    int minNeighbors=3;
    int flags=0;
    Size minSize;
    Size maxSize;

    // const char* keywords[] = { "image", "scaleFactor", "minNeighbors", "flags", "minSize", "maxSize", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scaleFactor"), scaleFactor, ArgInfo("scaleFactor", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minNeighbors"), minNeighbors, ArgInfo("minNeighbors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minSize"), minSize, ArgInfo("minSize", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxSize"), maxSize, ArgInfo("maxSize", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detectMultiScale(image, objects, numDetections, scaleFactor, minNeighbors, flags, minSize, maxSize), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, objects), evision_from(env, numDetections));
        }
    }

    }
    

    {
    UMat image;
    vector_Rect objects;
    vector_int numDetections;
    double scaleFactor=1.1;
    int minNeighbors=3;
    int flags=0;
    Size minSize;
    Size maxSize;

    // const char* keywords[] = { "image", "scaleFactor", "minNeighbors", "flags", "minSize", "maxSize", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scaleFactor"), scaleFactor, ArgInfo("scaleFactor", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minNeighbors"), minNeighbors, ArgInfo("minNeighbors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minSize"), minSize, ArgInfo("minSize", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxSize"), maxSize, ArgInfo("maxSize", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detectMultiScale(image, objects, numDetections, scaleFactor, minNeighbors, flags, minSize, maxSize), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, objects), evision_from(env, numDetections));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cascadeClassifier_detectMultiScale3(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::CascadeClassifier> * self1 = 0;
    if (!evision_CascadeClassifier_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::CascadeClassifier>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::CascadeClassifier> _self_ = *(self1);

    {
    Mat image;
    vector_Rect objects;
    vector_int rejectLevels;
    vector_double levelWeights;
    double scaleFactor=1.1;
    int minNeighbors=3;
    int flags=0;
    Size minSize;
    Size maxSize;
    bool outputRejectLevels=false;

    // const char* keywords[] = { "image", "scaleFactor", "minNeighbors", "flags", "minSize", "maxSize", "outputRejectLevels", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scaleFactor"), scaleFactor, ArgInfo("scaleFactor", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minNeighbors"), minNeighbors, ArgInfo("minNeighbors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minSize"), minSize, ArgInfo("minSize", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxSize"), maxSize, ArgInfo("maxSize", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "outputRejectLevels"), outputRejectLevels, ArgInfo("outputRejectLevels", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detectMultiScale(image, objects, rejectLevels, levelWeights, scaleFactor, minNeighbors, flags, minSize, maxSize, outputRejectLevels), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, objects), evision_from(env, rejectLevels), evision_from(env, levelWeights));
        }
    }

    }
    

    {
    UMat image;
    vector_Rect objects;
    vector_int rejectLevels;
    vector_double levelWeights;
    double scaleFactor=1.1;
    int minNeighbors=3;
    int flags=0;
    Size minSize;
    Size maxSize;
    bool outputRejectLevels=false;

    // const char* keywords[] = { "image", "scaleFactor", "minNeighbors", "flags", "minSize", "maxSize", "outputRejectLevels", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scaleFactor"), scaleFactor, ArgInfo("scaleFactor", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minNeighbors"), minNeighbors, ArgInfo("minNeighbors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minSize"), minSize, ArgInfo("minSize", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxSize"), maxSize, ArgInfo("maxSize", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "outputRejectLevels"), outputRejectLevels, ArgInfo("outputRejectLevels", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detectMultiScale(image, objects, rejectLevels, levelWeights, scaleFactor, minNeighbors, flags, minSize, maxSize, outputRejectLevels), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, objects), evision_from(env, rejectLevels), evision_from(env, levelWeights));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cascadeClassifier_empty(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::CascadeClassifier> * self1 = 0;
    if (!evision_CascadeClassifier_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::CascadeClassifier>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::CascadeClassifier> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->empty(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cascadeClassifier_getFeatureType(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::CascadeClassifier> * self1 = 0;
    if (!evision_CascadeClassifier_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::CascadeClassifier>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::CascadeClassifier> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getFeatureType(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cascadeClassifier_getOriginalWindowSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::CascadeClassifier> * self1 = 0;
    if (!evision_CascadeClassifier_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::CascadeClassifier>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::CascadeClassifier> _self_ = *(self1);
    Size retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getOriginalWindowSize(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cascadeClassifier_isOldFormatCascade(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::CascadeClassifier> * self1 = 0;
    if (!evision_CascadeClassifier_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::CascadeClassifier>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::CascadeClassifier> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->isOldFormatCascade(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cascadeClassifier_load(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::CascadeClassifier> * self1 = 0;
    if (!evision_CascadeClassifier_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::CascadeClassifier>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::CascadeClassifier> _self_ = *(self1);
    String filename;
    bool retval;

    // const char* keywords[] = { "filename", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->load(filename), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cascadeClassifier_read(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::CascadeClassifier> * self1 = 0;
    if (!evision_CascadeClassifier_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::CascadeClassifier>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::CascadeClassifier> _self_ = *(self1);
    FileNode node;
    bool retval;

    // const char* keywords[] = { "node", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "node"), node, ArgInfo("node", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->read(node), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (CascadeClassifier)

template<>
struct Evision_Converter< Ptr<cv::CascadeClassifier> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::CascadeClassifier>& r)
    {
        return evision_CascadeClassifier_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::CascadeClassifier>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::CascadeClassifier> * dst_ = nullptr;
        if (evision_CascadeClassifier_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::CascadeClassifier> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// CirclesGridFinderParameters (Generic)
//================================================================================

// GetSet (CirclesGridFinderParameters)


static ERL_NIF_TERM evision_CirclesGridFinderParameters_get_convexHullFactor(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::CirclesGridFinderParameters* self_ptr = 0;
    if (!evision_CirclesGridFinderParameters_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::CirclesGridFinderParameters` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->convexHullFactor);
}

static ERL_NIF_TERM evision_CirclesGridFinderParameters_set_convexHullFactor(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::CirclesGridFinderParameters* self_ptr = 0;

    if (!evision_CirclesGridFinderParameters_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::CirclesGridFinderParameters` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->convexHullFactor, ArgInfo("convexHullFactor", false))) {
        bool success;
        return evision_from_as_map<cv::CirclesGridFinderParameters>(env, *self_ptr, self, "CirclesGridFinderParameters", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_CirclesGridFinderParameters_get_densityNeighborhoodSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::CirclesGridFinderParameters* self_ptr = 0;
    if (!evision_CirclesGridFinderParameters_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::CirclesGridFinderParameters` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->densityNeighborhoodSize);
}

static ERL_NIF_TERM evision_CirclesGridFinderParameters_set_densityNeighborhoodSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::CirclesGridFinderParameters* self_ptr = 0;

    if (!evision_CirclesGridFinderParameters_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::CirclesGridFinderParameters` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->densityNeighborhoodSize, ArgInfo("densityNeighborhoodSize", false))) {
        bool success;
        return evision_from_as_map<cv::CirclesGridFinderParameters>(env, *self_ptr, self, "CirclesGridFinderParameters", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_CirclesGridFinderParameters_get_edgeGain(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::CirclesGridFinderParameters* self_ptr = 0;
    if (!evision_CirclesGridFinderParameters_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::CirclesGridFinderParameters` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->edgeGain);
}

static ERL_NIF_TERM evision_CirclesGridFinderParameters_set_edgeGain(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::CirclesGridFinderParameters* self_ptr = 0;

    if (!evision_CirclesGridFinderParameters_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::CirclesGridFinderParameters` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->edgeGain, ArgInfo("edgeGain", false))) {
        bool success;
        return evision_from_as_map<cv::CirclesGridFinderParameters>(env, *self_ptr, self, "CirclesGridFinderParameters", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_CirclesGridFinderParameters_get_edgePenalty(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::CirclesGridFinderParameters* self_ptr = 0;
    if (!evision_CirclesGridFinderParameters_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::CirclesGridFinderParameters` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->edgePenalty);
}

static ERL_NIF_TERM evision_CirclesGridFinderParameters_set_edgePenalty(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::CirclesGridFinderParameters* self_ptr = 0;

    if (!evision_CirclesGridFinderParameters_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::CirclesGridFinderParameters` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->edgePenalty, ArgInfo("edgePenalty", false))) {
        bool success;
        return evision_from_as_map<cv::CirclesGridFinderParameters>(env, *self_ptr, self, "CirclesGridFinderParameters", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_CirclesGridFinderParameters_get_existingVertexGain(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::CirclesGridFinderParameters* self_ptr = 0;
    if (!evision_CirclesGridFinderParameters_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::CirclesGridFinderParameters` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->existingVertexGain);
}

static ERL_NIF_TERM evision_CirclesGridFinderParameters_set_existingVertexGain(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::CirclesGridFinderParameters* self_ptr = 0;

    if (!evision_CirclesGridFinderParameters_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::CirclesGridFinderParameters` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->existingVertexGain, ArgInfo("existingVertexGain", false))) {
        bool success;
        return evision_from_as_map<cv::CirclesGridFinderParameters>(env, *self_ptr, self, "CirclesGridFinderParameters", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_CirclesGridFinderParameters_get_keypointScale(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::CirclesGridFinderParameters* self_ptr = 0;
    if (!evision_CirclesGridFinderParameters_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::CirclesGridFinderParameters` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->keypointScale);
}

static ERL_NIF_TERM evision_CirclesGridFinderParameters_set_keypointScale(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::CirclesGridFinderParameters* self_ptr = 0;

    if (!evision_CirclesGridFinderParameters_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::CirclesGridFinderParameters` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->keypointScale, ArgInfo("keypointScale", false))) {
        bool success;
        return evision_from_as_map<cv::CirclesGridFinderParameters>(env, *self_ptr, self, "CirclesGridFinderParameters", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_CirclesGridFinderParameters_get_kmeansAttempts(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::CirclesGridFinderParameters* self_ptr = 0;
    if (!evision_CirclesGridFinderParameters_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::CirclesGridFinderParameters` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->kmeansAttempts);
}

static ERL_NIF_TERM evision_CirclesGridFinderParameters_set_kmeansAttempts(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::CirclesGridFinderParameters* self_ptr = 0;

    if (!evision_CirclesGridFinderParameters_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::CirclesGridFinderParameters` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->kmeansAttempts, ArgInfo("kmeansAttempts", false))) {
        bool success;
        return evision_from_as_map<cv::CirclesGridFinderParameters>(env, *self_ptr, self, "CirclesGridFinderParameters", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_CirclesGridFinderParameters_get_maxRectifiedDistance(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::CirclesGridFinderParameters* self_ptr = 0;
    if (!evision_CirclesGridFinderParameters_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::CirclesGridFinderParameters` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->maxRectifiedDistance);
}

static ERL_NIF_TERM evision_CirclesGridFinderParameters_set_maxRectifiedDistance(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::CirclesGridFinderParameters* self_ptr = 0;

    if (!evision_CirclesGridFinderParameters_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::CirclesGridFinderParameters` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->maxRectifiedDistance, ArgInfo("maxRectifiedDistance", false))) {
        bool success;
        return evision_from_as_map<cv::CirclesGridFinderParameters>(env, *self_ptr, self, "CirclesGridFinderParameters", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_CirclesGridFinderParameters_get_minDensity(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::CirclesGridFinderParameters* self_ptr = 0;
    if (!evision_CirclesGridFinderParameters_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::CirclesGridFinderParameters` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->minDensity);
}

static ERL_NIF_TERM evision_CirclesGridFinderParameters_set_minDensity(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::CirclesGridFinderParameters* self_ptr = 0;

    if (!evision_CirclesGridFinderParameters_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::CirclesGridFinderParameters` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->minDensity, ArgInfo("minDensity", false))) {
        bool success;
        return evision_from_as_map<cv::CirclesGridFinderParameters>(env, *self_ptr, self, "CirclesGridFinderParameters", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_CirclesGridFinderParameters_get_minDistanceToAddKeypoint(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::CirclesGridFinderParameters* self_ptr = 0;
    if (!evision_CirclesGridFinderParameters_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::CirclesGridFinderParameters` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->minDistanceToAddKeypoint);
}

static ERL_NIF_TERM evision_CirclesGridFinderParameters_set_minDistanceToAddKeypoint(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::CirclesGridFinderParameters* self_ptr = 0;

    if (!evision_CirclesGridFinderParameters_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::CirclesGridFinderParameters` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->minDistanceToAddKeypoint, ArgInfo("minDistanceToAddKeypoint", false))) {
        bool success;
        return evision_from_as_map<cv::CirclesGridFinderParameters>(env, *self_ptr, self, "CirclesGridFinderParameters", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_CirclesGridFinderParameters_get_minGraphConfidence(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::CirclesGridFinderParameters* self_ptr = 0;
    if (!evision_CirclesGridFinderParameters_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::CirclesGridFinderParameters` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->minGraphConfidence);
}

static ERL_NIF_TERM evision_CirclesGridFinderParameters_set_minGraphConfidence(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::CirclesGridFinderParameters* self_ptr = 0;

    if (!evision_CirclesGridFinderParameters_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::CirclesGridFinderParameters` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->minGraphConfidence, ArgInfo("minGraphConfidence", false))) {
        bool success;
        return evision_from_as_map<cv::CirclesGridFinderParameters>(env, *self_ptr, self, "CirclesGridFinderParameters", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_CirclesGridFinderParameters_get_minRNGEdgeSwitchDist(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::CirclesGridFinderParameters* self_ptr = 0;
    if (!evision_CirclesGridFinderParameters_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::CirclesGridFinderParameters` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->minRNGEdgeSwitchDist);
}

static ERL_NIF_TERM evision_CirclesGridFinderParameters_set_minRNGEdgeSwitchDist(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::CirclesGridFinderParameters* self_ptr = 0;

    if (!evision_CirclesGridFinderParameters_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::CirclesGridFinderParameters` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->minRNGEdgeSwitchDist, ArgInfo("minRNGEdgeSwitchDist", false))) {
        bool success;
        return evision_from_as_map<cv::CirclesGridFinderParameters>(env, *self_ptr, self, "CirclesGridFinderParameters", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_CirclesGridFinderParameters_get_squareSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::CirclesGridFinderParameters* self_ptr = 0;
    if (!evision_CirclesGridFinderParameters_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::CirclesGridFinderParameters` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->squareSize);
}

static ERL_NIF_TERM evision_CirclesGridFinderParameters_set_squareSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::CirclesGridFinderParameters* self_ptr = 0;

    if (!evision_CirclesGridFinderParameters_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::CirclesGridFinderParameters` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->squareSize, ArgInfo("squareSize", false))) {
        bool success;
        return evision_from_as_map<cv::CirclesGridFinderParameters>(env, *self_ptr, self, "CirclesGridFinderParameters", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_CirclesGridFinderParameters_get_vertexGain(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::CirclesGridFinderParameters* self_ptr = 0;
    if (!evision_CirclesGridFinderParameters_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::CirclesGridFinderParameters` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->vertexGain);
}

static ERL_NIF_TERM evision_CirclesGridFinderParameters_set_vertexGain(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::CirclesGridFinderParameters* self_ptr = 0;

    if (!evision_CirclesGridFinderParameters_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::CirclesGridFinderParameters` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->vertexGain, ArgInfo("vertexGain", false))) {
        bool success;
        return evision_from_as_map<cv::CirclesGridFinderParameters>(env, *self_ptr, self, "CirclesGridFinderParameters", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_CirclesGridFinderParameters_get_vertexPenalty(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::CirclesGridFinderParameters* self_ptr = 0;
    if (!evision_CirclesGridFinderParameters_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::CirclesGridFinderParameters` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->vertexPenalty);
}

static ERL_NIF_TERM evision_CirclesGridFinderParameters_set_vertexPenalty(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::CirclesGridFinderParameters* self_ptr = 0;

    if (!evision_CirclesGridFinderParameters_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::CirclesGridFinderParameters` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->vertexPenalty, ArgInfo("vertexPenalty", false))) {
        bool success;
        return evision_from_as_map<cv::CirclesGridFinderParameters>(env, *self_ptr, self, "CirclesGridFinderParameters", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}


// Methods (CirclesGridFinderParameters)

static ERL_NIF_TERM evision_cv_circlesGridFinderParameters_CirclesGridFinderParameters(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        evision_res<cv::CirclesGridFinderParameters> * self = nullptr;
        if (alloc_resource(&self)) ERRWRAP2(new (&(self->val)) cv::CirclesGridFinderParameters(), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<cv::CirclesGridFinderParameters>(env, self->val, ret, "CirclesGridFinderParameters", success);;
        }
    }

    return enif_make_badarg(env);
}



// Converter (CirclesGridFinderParameters)

template<>
struct Evision_Converter< cv::CirclesGridFinderParameters >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const cv::CirclesGridFinderParameters& r)
    {
        return evision_CirclesGridFinderParameters_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, cv::CirclesGridFinderParameters& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        cv::CirclesGridFinderParameters * dst_ = nullptr;
        if (evision_CirclesGridFinderParameters_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected cv::CirclesGridFinderParameters for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// DISOpticalFlow (Generic)
//================================================================================

// GetSet (DISOpticalFlow)



// Methods (DISOpticalFlow)

static ERL_NIF_TERM evision_cv_disOpticalFlow_create_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    int preset=DISOpticalFlow::PRESET_FAST;
    Ptr<DISOpticalFlow> retval;

    // const char* keywords[] = { "preset", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "preset"), preset, ArgInfo("preset", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::DISOpticalFlow::create(preset), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_disOpticalFlow_getFinestScale(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::DISOpticalFlow> * self1 = 0;
    if (!evision_DISOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::DISOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::DISOpticalFlow> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getFinestScale(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_disOpticalFlow_getGradientDescentIterations(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::DISOpticalFlow> * self1 = 0;
    if (!evision_DISOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::DISOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::DISOpticalFlow> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getGradientDescentIterations(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_disOpticalFlow_getPatchSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::DISOpticalFlow> * self1 = 0;
    if (!evision_DISOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::DISOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::DISOpticalFlow> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getPatchSize(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_disOpticalFlow_getPatchStride(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::DISOpticalFlow> * self1 = 0;
    if (!evision_DISOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::DISOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::DISOpticalFlow> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getPatchStride(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_disOpticalFlow_getUseMeanNormalization(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::DISOpticalFlow> * self1 = 0;
    if (!evision_DISOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::DISOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::DISOpticalFlow> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getUseMeanNormalization(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_disOpticalFlow_getUseSpatialPropagation(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::DISOpticalFlow> * self1 = 0;
    if (!evision_DISOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::DISOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::DISOpticalFlow> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getUseSpatialPropagation(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_disOpticalFlow_getVariationalRefinementAlpha(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::DISOpticalFlow> * self1 = 0;
    if (!evision_DISOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::DISOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::DISOpticalFlow> _self_ = *(self1);
    float retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getVariationalRefinementAlpha(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_disOpticalFlow_getVariationalRefinementDelta(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::DISOpticalFlow> * self1 = 0;
    if (!evision_DISOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::DISOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::DISOpticalFlow> _self_ = *(self1);
    float retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getVariationalRefinementDelta(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_disOpticalFlow_getVariationalRefinementGamma(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::DISOpticalFlow> * self1 = 0;
    if (!evision_DISOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::DISOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::DISOpticalFlow> _self_ = *(self1);
    float retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getVariationalRefinementGamma(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_disOpticalFlow_getVariationalRefinementIterations(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::DISOpticalFlow> * self1 = 0;
    if (!evision_DISOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::DISOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::DISOpticalFlow> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getVariationalRefinementIterations(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_disOpticalFlow_setFinestScale(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::DISOpticalFlow> * self1 = 0;
    if (!evision_DISOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::DISOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::DISOpticalFlow> _self_ = *(self1);
    int val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setFinestScale(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "DISOpticalFlow", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_disOpticalFlow_setGradientDescentIterations(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::DISOpticalFlow> * self1 = 0;
    if (!evision_DISOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::DISOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::DISOpticalFlow> _self_ = *(self1);
    int val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setGradientDescentIterations(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "DISOpticalFlow", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_disOpticalFlow_setPatchSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::DISOpticalFlow> * self1 = 0;
    if (!evision_DISOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::DISOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::DISOpticalFlow> _self_ = *(self1);
    int val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setPatchSize(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "DISOpticalFlow", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_disOpticalFlow_setPatchStride(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::DISOpticalFlow> * self1 = 0;
    if (!evision_DISOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::DISOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::DISOpticalFlow> _self_ = *(self1);
    int val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setPatchStride(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "DISOpticalFlow", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_disOpticalFlow_setUseMeanNormalization(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::DISOpticalFlow> * self1 = 0;
    if (!evision_DISOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::DISOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::DISOpticalFlow> _self_ = *(self1);
    bool val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setUseMeanNormalization(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "DISOpticalFlow", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_disOpticalFlow_setUseSpatialPropagation(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::DISOpticalFlow> * self1 = 0;
    if (!evision_DISOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::DISOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::DISOpticalFlow> _self_ = *(self1);
    bool val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setUseSpatialPropagation(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "DISOpticalFlow", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_disOpticalFlow_setVariationalRefinementAlpha(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::DISOpticalFlow> * self1 = 0;
    if (!evision_DISOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::DISOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::DISOpticalFlow> _self_ = *(self1);
    float val=0.f;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setVariationalRefinementAlpha(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "DISOpticalFlow", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_disOpticalFlow_setVariationalRefinementDelta(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::DISOpticalFlow> * self1 = 0;
    if (!evision_DISOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::DISOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::DISOpticalFlow> _self_ = *(self1);
    float val=0.f;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setVariationalRefinementDelta(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "DISOpticalFlow", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_disOpticalFlow_setVariationalRefinementGamma(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::DISOpticalFlow> * self1 = 0;
    if (!evision_DISOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::DISOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::DISOpticalFlow> _self_ = *(self1);
    float val=0.f;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setVariationalRefinementGamma(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "DISOpticalFlow", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_disOpticalFlow_setVariationalRefinementIterations(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::DISOpticalFlow> * self1 = 0;
    if (!evision_DISOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::DISOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::DISOpticalFlow> _self_ = *(self1);
    int val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setVariationalRefinementIterations(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "DISOpticalFlow", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (DISOpticalFlow)

template<>
struct Evision_Converter< Ptr<cv::DISOpticalFlow> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::DISOpticalFlow>& r)
    {
        return evision_DISOpticalFlow_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::DISOpticalFlow>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::DISOpticalFlow> * dst_ = nullptr;
        if (evision_DISOpticalFlow_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::DISOpticalFlow> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// DMatch (Generic)
//================================================================================

// GetSet (DMatch)


static ERL_NIF_TERM evision_DMatch_get_distance(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::DMatch* self_ptr = 0;
    if (!evision_DMatch_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::DMatch` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->distance);
}

static ERL_NIF_TERM evision_DMatch_set_distance(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::DMatch* self_ptr = 0;

    if (!evision_DMatch_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::DMatch` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->distance, ArgInfo("distance", false))) {
        bool success;
        return evision_from_as_map<cv::DMatch>(env, *self_ptr, self, "DMatch", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_DMatch_get_imgIdx(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::DMatch* self_ptr = 0;
    if (!evision_DMatch_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::DMatch` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->imgIdx);
}

static ERL_NIF_TERM evision_DMatch_set_imgIdx(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::DMatch* self_ptr = 0;

    if (!evision_DMatch_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::DMatch` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->imgIdx, ArgInfo("imgIdx", false))) {
        bool success;
        return evision_from_as_map<cv::DMatch>(env, *self_ptr, self, "DMatch", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_DMatch_get_queryIdx(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::DMatch* self_ptr = 0;
    if (!evision_DMatch_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::DMatch` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->queryIdx);
}

static ERL_NIF_TERM evision_DMatch_set_queryIdx(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::DMatch* self_ptr = 0;

    if (!evision_DMatch_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::DMatch` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->queryIdx, ArgInfo("queryIdx", false))) {
        bool success;
        return evision_from_as_map<cv::DMatch>(env, *self_ptr, self, "DMatch", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_DMatch_get_trainIdx(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::DMatch* self_ptr = 0;
    if (!evision_DMatch_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::DMatch` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->trainIdx);
}

static ERL_NIF_TERM evision_DMatch_set_trainIdx(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::DMatch* self_ptr = 0;

    if (!evision_DMatch_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::DMatch` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->trainIdx, ArgInfo("trainIdx", false))) {
        bool success;
        return evision_from_as_map<cv::DMatch>(env, *self_ptr, self, "DMatch", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}


// Methods (DMatch)

static ERL_NIF_TERM evision_cv_dMatch_DMatch(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    {

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        evision_res<cv::DMatch> * self = nullptr;
        if (alloc_resource(&self)) ERRWRAP2(new (&(self->val)) cv::DMatch(), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<cv::DMatch>(env, self->val, ret, "DMatch", success);;
        }
    }

    }
    

    {
    int _queryIdx=0;
    int _trainIdx=0;
    float _distance=0.f;

    // const char* keywords[] = { "_queryIdx", "_trainIdx", "_distance", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "queryIdx"), _queryIdx, ArgInfo("_queryIdx", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "trainIdx"), _trainIdx, ArgInfo("_trainIdx", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distance"), _distance, ArgInfo("_distance", 0)) )
    {
        int error_flag = false;
        evision_res<cv::DMatch> * self = nullptr;
        if (alloc_resource(&self)) ERRWRAP2(new (&(self->val)) cv::DMatch(_queryIdx, _trainIdx, _distance), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<cv::DMatch>(env, self->val, ret, "DMatch", success);;
        }
    }

    }
    

    {
    int _queryIdx=0;
    int _trainIdx=0;
    int _imgIdx=0;
    float _distance=0.f;

    // const char* keywords[] = { "_queryIdx", "_trainIdx", "_imgIdx", "_distance", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "queryIdx"), _queryIdx, ArgInfo("_queryIdx", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "trainIdx"), _trainIdx, ArgInfo("_trainIdx", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imgIdx"), _imgIdx, ArgInfo("_imgIdx", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distance"), _distance, ArgInfo("_distance", 0)) )
    {
        int error_flag = false;
        evision_res<cv::DMatch> * self = nullptr;
        if (alloc_resource(&self)) ERRWRAP2(new (&(self->val)) cv::DMatch(_queryIdx, _trainIdx, _imgIdx, _distance), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<cv::DMatch>(env, self->val, ret, "DMatch", success);;
        }
    }

    }

    return enif_make_badarg(env);
}



// Converter (DMatch)

template<>
struct Evision_Converter< cv::DMatch >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const cv::DMatch& r)
    {
        return evision_DMatch_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, cv::DMatch& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        cv::DMatch * dst_ = nullptr;
        if (evision_DMatch_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected cv::DMatch for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// DenseOpticalFlow (Generic)
//================================================================================

// GetSet (DenseOpticalFlow)



// Methods (DenseOpticalFlow)

static ERL_NIF_TERM evision_cv_denseOpticalFlow_calc(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::DenseOpticalFlow> * self1 = 0;
    if (!evision_DenseOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::DenseOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::DenseOpticalFlow> _self_ = *(self1);

    {
    Mat I0;
    Mat I1;
    Mat flow;

    // const char* keywords[] = { "I0", "I1", "flow", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "i0"), I0, ArgInfo("I0", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "i1"), I1, ArgInfo("I1", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flow"), flow, ArgInfo("flow", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->calc(I0, I1, flow), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, flow);
        }
    }

    }
    

    {
    UMat I0;
    UMat I1;
    UMat flow;

    // const char* keywords[] = { "I0", "I1", "flow", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "i0"), I0, ArgInfo("I0", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "i1"), I1, ArgInfo("I1", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flow"), flow, ArgInfo("flow", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->calc(I0, I1, flow), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, flow);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_denseOpticalFlow_clear(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::DenseOpticalFlow> * self1 = 0;
    if (!evision_DenseOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::DenseOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::DenseOpticalFlow> _self_ = *(self1);

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::clear(), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "DenseOpticalFlow", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_denseOpticalFlow_collectGarbage(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::DenseOpticalFlow> * self1 = 0;
    if (!evision_DenseOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::DenseOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::DenseOpticalFlow> _self_ = *(self1);

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->collectGarbage(), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "DenseOpticalFlow", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_denseOpticalFlow_empty(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::DenseOpticalFlow> * self1 = 0;
    if (!evision_DenseOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::DenseOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::DenseOpticalFlow> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->Algorithm::empty(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_denseOpticalFlow_getDefaultName(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::DenseOpticalFlow> * self1 = 0;
    if (!evision_DenseOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::DenseOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::DenseOpticalFlow> _self_ = *(self1);
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->Algorithm::getDefaultName(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_denseOpticalFlow_read(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::DenseOpticalFlow> * self1 = 0;
    if (!evision_DenseOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::DenseOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::DenseOpticalFlow> _self_ = *(self1);
    FileNode fn_;

    // const char* keywords[] = { "fn_", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fn_"), fn_, ArgInfo("fn_", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::read(fn_), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "DenseOpticalFlow", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_denseOpticalFlow_save(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::DenseOpticalFlow> * self1 = 0;
    if (!evision_DenseOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::DenseOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::DenseOpticalFlow> _self_ = *(self1);
    String filename;

    // const char* keywords[] = { "filename", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::save(filename), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "DenseOpticalFlow", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_denseOpticalFlow_write(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::DenseOpticalFlow> * self1 = 0;
    if (!evision_DenseOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::DenseOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::DenseOpticalFlow> _self_ = *(self1);
    Ptr<FileStorage> fs;
    String name;

    // const char* keywords[] = { "fs", "name", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fs"), fs, ArgInfo("fs", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "name"), name, ArgInfo("name", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::write(fs, name), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "DenseOpticalFlow", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (DenseOpticalFlow)

template<>
struct Evision_Converter< Ptr<cv::DenseOpticalFlow> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::DenseOpticalFlow>& r)
    {
        return evision_DenseOpticalFlow_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::DenseOpticalFlow>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::DenseOpticalFlow> * dst_ = nullptr;
        if (evision_DenseOpticalFlow_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::DenseOpticalFlow> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// DescriptorMatcher (Generic)
//================================================================================

// GetSet (DescriptorMatcher)



// Methods (DescriptorMatcher)

static ERL_NIF_TERM evision_cv_descriptorMatcher_add(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::DescriptorMatcher> * self1 = 0;
    if (!evision_DescriptorMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::DescriptorMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::DescriptorMatcher> _self_ = *(self1);

    {
    vector_Mat descriptors;

    // const char* keywords[] = { "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::add(descriptors), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "DescriptorMatcher", success);
        }
    }

    }
    

    {
    vector_UMat descriptors;

    // const char* keywords[] = { "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::add(descriptors), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "DescriptorMatcher", success);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_descriptorMatcher_clear(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::DescriptorMatcher> * self1 = 0;
    if (!evision_DescriptorMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::DescriptorMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::DescriptorMatcher> _self_ = *(self1);

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::clear(), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "DescriptorMatcher", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_descriptorMatcher_clone(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::DescriptorMatcher> * self1 = 0;
    if (!evision_DescriptorMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::DescriptorMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::DescriptorMatcher> _self_ = *(self1);
    bool emptyTrainData=false;
    Ptr<DescriptorMatcher> retval;

    // const char* keywords[] = { "emptyTrainData", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "emptyTrainData"), emptyTrainData, ArgInfo("emptyTrainData", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->clone(emptyTrainData), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_descriptorMatcher_create_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    {
    String descriptorMatcherType;
    Ptr<DescriptorMatcher> retval;

    // const char* keywords[] = { "descriptorMatcherType", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptorMatcherType"), descriptorMatcherType, ArgInfo("descriptorMatcherType", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::DescriptorMatcher::create(descriptorMatcherType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    std::underlying_type_t<DescriptorMatcher_MatcherType> matcherType=static_cast<std::underlying_type_t<DescriptorMatcher_MatcherType>>(static_cast<DescriptorMatcher_MatcherType>(0));
    Ptr<DescriptorMatcher> retval;

    // const char* keywords[] = { "matcherType", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "matcherType"), matcherType, ArgInfo("matcherType", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::DescriptorMatcher::create(static_cast<DescriptorMatcher_MatcherType>(matcherType)), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_descriptorMatcher_empty(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::DescriptorMatcher> * self1 = 0;
    if (!evision_DescriptorMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::DescriptorMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::DescriptorMatcher> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->DescriptorMatcher::empty(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_descriptorMatcher_getDefaultName(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::DescriptorMatcher> * self1 = 0;
    if (!evision_DescriptorMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::DescriptorMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::DescriptorMatcher> _self_ = *(self1);
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->Algorithm::getDefaultName(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_descriptorMatcher_getTrainDescriptors(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::DescriptorMatcher> * self1 = 0;
    if (!evision_DescriptorMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::DescriptorMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::DescriptorMatcher> _self_ = *(self1);
    std::vector<Mat> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->DescriptorMatcher::getTrainDescriptors(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_descriptorMatcher_isMaskSupported(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::DescriptorMatcher> * self1 = 0;
    if (!evision_DescriptorMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::DescriptorMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::DescriptorMatcher> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->isMaskSupported(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_descriptorMatcher_knnMatch(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::DescriptorMatcher> * self1 = 0;
    if (!evision_DescriptorMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::DescriptorMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::DescriptorMatcher> _self_ = *(self1);

    {
    Mat queryDescriptors;
    Mat trainDescriptors;
    vector_vector_DMatch matches;
    int k=0;
    Mat mask;
    bool compactResult=false;

    // const char* keywords[] = { "queryDescriptors", "trainDescriptors", "k", "mask", "compactResult", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "queryDescriptors"), queryDescriptors, ArgInfo("queryDescriptors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "trainDescriptors"), trainDescriptors, ArgInfo("trainDescriptors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), k, ArgInfo("k", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "compactResult"), compactResult, ArgInfo("compactResult", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::knnMatch(queryDescriptors, trainDescriptors, matches, k, mask, compactResult), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, matches);
        }
    }

    }
    

    {
    UMat queryDescriptors;
    UMat trainDescriptors;
    vector_vector_DMatch matches;
    int k=0;
    UMat mask;
    bool compactResult=false;

    // const char* keywords[] = { "queryDescriptors", "trainDescriptors", "k", "mask", "compactResult", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "queryDescriptors"), queryDescriptors, ArgInfo("queryDescriptors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "trainDescriptors"), trainDescriptors, ArgInfo("trainDescriptors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), k, ArgInfo("k", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "compactResult"), compactResult, ArgInfo("compactResult", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::knnMatch(queryDescriptors, trainDescriptors, matches, k, mask, compactResult), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, matches);
        }
    }

    }
    

    {
    Mat queryDescriptors;
    vector_vector_DMatch matches;
    int k=0;
    vector_Mat masks;
    bool compactResult=false;

    // const char* keywords[] = { "queryDescriptors", "k", "masks", "compactResult", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "queryDescriptors"), queryDescriptors, ArgInfo("queryDescriptors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), k, ArgInfo("k", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "masks"), masks, ArgInfo("masks", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "compactResult"), compactResult, ArgInfo("compactResult", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::knnMatch(queryDescriptors, matches, k, masks, compactResult), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, matches);
        }
    }

    }
    

    {
    UMat queryDescriptors;
    vector_vector_DMatch matches;
    int k=0;
    vector_UMat masks;
    bool compactResult=false;

    // const char* keywords[] = { "queryDescriptors", "k", "masks", "compactResult", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "queryDescriptors"), queryDescriptors, ArgInfo("queryDescriptors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), k, ArgInfo("k", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "masks"), masks, ArgInfo("masks", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "compactResult"), compactResult, ArgInfo("compactResult", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::knnMatch(queryDescriptors, matches, k, masks, compactResult), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, matches);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_descriptorMatcher_match(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::DescriptorMatcher> * self1 = 0;
    if (!evision_DescriptorMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::DescriptorMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::DescriptorMatcher> _self_ = *(self1);

    {
    Mat queryDescriptors;
    Mat trainDescriptors;
    vector_DMatch matches;
    Mat mask;

    // const char* keywords[] = { "queryDescriptors", "trainDescriptors", "mask", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "queryDescriptors"), queryDescriptors, ArgInfo("queryDescriptors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "trainDescriptors"), trainDescriptors, ArgInfo("trainDescriptors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::match(queryDescriptors, trainDescriptors, matches, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, matches);
        }
    }

    }
    

    {
    UMat queryDescriptors;
    UMat trainDescriptors;
    vector_DMatch matches;
    UMat mask;

    // const char* keywords[] = { "queryDescriptors", "trainDescriptors", "mask", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "queryDescriptors"), queryDescriptors, ArgInfo("queryDescriptors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "trainDescriptors"), trainDescriptors, ArgInfo("trainDescriptors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::match(queryDescriptors, trainDescriptors, matches, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, matches);
        }
    }

    }
    

    {
    Mat queryDescriptors;
    vector_DMatch matches;
    vector_Mat masks;

    // const char* keywords[] = { "queryDescriptors", "masks", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "queryDescriptors"), queryDescriptors, ArgInfo("queryDescriptors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "masks"), masks, ArgInfo("masks", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::match(queryDescriptors, matches, masks), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, matches);
        }
    }

    }
    

    {
    UMat queryDescriptors;
    vector_DMatch matches;
    vector_UMat masks;

    // const char* keywords[] = { "queryDescriptors", "masks", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "queryDescriptors"), queryDescriptors, ArgInfo("queryDescriptors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "masks"), masks, ArgInfo("masks", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::match(queryDescriptors, matches, masks), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, matches);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_descriptorMatcher_radiusMatch(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::DescriptorMatcher> * self1 = 0;
    if (!evision_DescriptorMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::DescriptorMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::DescriptorMatcher> _self_ = *(self1);

    {
    Mat queryDescriptors;
    Mat trainDescriptors;
    vector_vector_DMatch matches;
    float maxDistance=0.f;
    Mat mask;
    bool compactResult=false;

    // const char* keywords[] = { "queryDescriptors", "trainDescriptors", "maxDistance", "mask", "compactResult", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "queryDescriptors"), queryDescriptors, ArgInfo("queryDescriptors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "trainDescriptors"), trainDescriptors, ArgInfo("trainDescriptors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxDistance"), maxDistance, ArgInfo("maxDistance", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "compactResult"), compactResult, ArgInfo("compactResult", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::radiusMatch(queryDescriptors, trainDescriptors, matches, maxDistance, mask, compactResult), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, matches);
        }
    }

    }
    

    {
    UMat queryDescriptors;
    UMat trainDescriptors;
    vector_vector_DMatch matches;
    float maxDistance=0.f;
    UMat mask;
    bool compactResult=false;

    // const char* keywords[] = { "queryDescriptors", "trainDescriptors", "maxDistance", "mask", "compactResult", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "queryDescriptors"), queryDescriptors, ArgInfo("queryDescriptors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "trainDescriptors"), trainDescriptors, ArgInfo("trainDescriptors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxDistance"), maxDistance, ArgInfo("maxDistance", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "compactResult"), compactResult, ArgInfo("compactResult", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::radiusMatch(queryDescriptors, trainDescriptors, matches, maxDistance, mask, compactResult), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, matches);
        }
    }

    }
    

    {
    Mat queryDescriptors;
    vector_vector_DMatch matches;
    float maxDistance=0.f;
    vector_Mat masks;
    bool compactResult=false;

    // const char* keywords[] = { "queryDescriptors", "maxDistance", "masks", "compactResult", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "queryDescriptors"), queryDescriptors, ArgInfo("queryDescriptors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxDistance"), maxDistance, ArgInfo("maxDistance", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "masks"), masks, ArgInfo("masks", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "compactResult"), compactResult, ArgInfo("compactResult", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::radiusMatch(queryDescriptors, matches, maxDistance, masks, compactResult), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, matches);
        }
    }

    }
    

    {
    UMat queryDescriptors;
    vector_vector_DMatch matches;
    float maxDistance=0.f;
    vector_UMat masks;
    bool compactResult=false;

    // const char* keywords[] = { "queryDescriptors", "maxDistance", "masks", "compactResult", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "queryDescriptors"), queryDescriptors, ArgInfo("queryDescriptors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxDistance"), maxDistance, ArgInfo("maxDistance", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "masks"), masks, ArgInfo("masks", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "compactResult"), compactResult, ArgInfo("compactResult", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::radiusMatch(queryDescriptors, matches, maxDistance, masks, compactResult), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, matches);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_descriptorMatcher_read(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::DescriptorMatcher> * self1 = 0;
    if (!evision_DescriptorMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::DescriptorMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::DescriptorMatcher> _self_ = *(self1);

    {
    String fileName;

    // const char* keywords[] = { "fileName", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fileName"), fileName, ArgInfo("fileName", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::read(fileName), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "DescriptorMatcher", success);
        }
    }

    }
    

    {
    FileNode arg1;

    // const char* keywords[] = { "arg1", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "arg1"), arg1, ArgInfo("arg1", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::read(arg1), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "DescriptorMatcher", success);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_descriptorMatcher_save(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::DescriptorMatcher> * self1 = 0;
    if (!evision_DescriptorMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::DescriptorMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::DescriptorMatcher> _self_ = *(self1);
    String filename;

    // const char* keywords[] = { "filename", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::save(filename), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "DescriptorMatcher", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_descriptorMatcher_train(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::DescriptorMatcher> * self1 = 0;
    if (!evision_DescriptorMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::DescriptorMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::DescriptorMatcher> _self_ = *(self1);

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::train(), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "DescriptorMatcher", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_descriptorMatcher_write(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::DescriptorMatcher> * self1 = 0;
    if (!evision_DescriptorMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::DescriptorMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::DescriptorMatcher> _self_ = *(self1);

    {
    String fileName;

    // const char* keywords[] = { "fileName", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fileName"), fileName, ArgInfo("fileName", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::write(fileName), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "DescriptorMatcher", success);
        }
    }

    }
    

    {
    Ptr<FileStorage> fs;
    String name;

    // const char* keywords[] = { "fs", "name", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fs"), fs, ArgInfo("fs", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "name"), name, ArgInfo("name", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::write(fs, name), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "DescriptorMatcher", success);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (DescriptorMatcher)

template<>
struct Evision_Converter< Ptr<cv::DescriptorMatcher> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::DescriptorMatcher>& r)
    {
        return evision_DescriptorMatcher_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::DescriptorMatcher>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::DescriptorMatcher> * dst_ = nullptr;
        if (evision_DescriptorMatcher_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::DescriptorMatcher> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// FaceDetectorYN (Generic)
//================================================================================

// GetSet (FaceDetectorYN)



// Methods (FaceDetectorYN)

static ERL_NIF_TERM evision_cv_faceDetectorYN_create_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    String model;
    String config;
    Size input_size;
    float score_threshold=0.9f;
    float nms_threshold=0.3f;
    int top_k=5000;
    int backend_id=0;
    int target_id=0;
    Ptr<FaceDetectorYN> retval;

    // const char* keywords[] = { "model", "config", "input_size", "score_threshold", "nms_threshold", "top_k", "backend_id", "target_id", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "model"), model, ArgInfo("model", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "config"), config, ArgInfo("config", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "input_size"), input_size, ArgInfo("input_size", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "score_threshold"), score_threshold, ArgInfo("score_threshold", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nms_threshold"), nms_threshold, ArgInfo("nms_threshold", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "top_k"), top_k, ArgInfo("top_k", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "backend_id"), backend_id, ArgInfo("backend_id", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "target_id"), target_id, ArgInfo("target_id", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::FaceDetectorYN::create(model, config, input_size, score_threshold, nms_threshold, top_k, backend_id, target_id), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_faceDetectorYN_detect(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FaceDetectorYN> * self1 = 0;
    if (!evision_FaceDetectorYN_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FaceDetectorYN>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FaceDetectorYN> _self_ = *(self1);

    {
    Mat image;
    Mat faces;
    int retval;

    // const char* keywords[] = { "image", "faces", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "faces"), faces, ArgInfo("faces", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->detect(image, faces), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, faces));
        }
    }

    }
    

    {
    UMat image;
    UMat faces;
    int retval;

    // const char* keywords[] = { "image", "faces", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "faces"), faces, ArgInfo("faces", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->detect(image, faces), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, faces));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_faceDetectorYN_getInputSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FaceDetectorYN> * self1 = 0;
    if (!evision_FaceDetectorYN_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FaceDetectorYN>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FaceDetectorYN> _self_ = *(self1);
    Size retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getInputSize(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_faceDetectorYN_getNMSThreshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FaceDetectorYN> * self1 = 0;
    if (!evision_FaceDetectorYN_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FaceDetectorYN>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FaceDetectorYN> _self_ = *(self1);
    float retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getNMSThreshold(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_faceDetectorYN_getScoreThreshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FaceDetectorYN> * self1 = 0;
    if (!evision_FaceDetectorYN_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FaceDetectorYN>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FaceDetectorYN> _self_ = *(self1);
    float retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getScoreThreshold(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_faceDetectorYN_getTopK(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FaceDetectorYN> * self1 = 0;
    if (!evision_FaceDetectorYN_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FaceDetectorYN>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FaceDetectorYN> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getTopK(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_faceDetectorYN_setInputSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FaceDetectorYN> * self1 = 0;
    if (!evision_FaceDetectorYN_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FaceDetectorYN>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FaceDetectorYN> _self_ = *(self1);
    Size input_size;

    // const char* keywords[] = { "input_size", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "input_size"), input_size, ArgInfo("input_size", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setInputSize(input_size), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "FaceDetectorYN", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_faceDetectorYN_setNMSThreshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FaceDetectorYN> * self1 = 0;
    if (!evision_FaceDetectorYN_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FaceDetectorYN>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FaceDetectorYN> _self_ = *(self1);
    float nms_threshold=0.f;

    // const char* keywords[] = { "nms_threshold", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "nms_threshold"), nms_threshold, ArgInfo("nms_threshold", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setNMSThreshold(nms_threshold), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "FaceDetectorYN", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_faceDetectorYN_setScoreThreshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FaceDetectorYN> * self1 = 0;
    if (!evision_FaceDetectorYN_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FaceDetectorYN>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FaceDetectorYN> _self_ = *(self1);
    float score_threshold=0.f;

    // const char* keywords[] = { "score_threshold", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "score_threshold"), score_threshold, ArgInfo("score_threshold", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setScoreThreshold(score_threshold), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "FaceDetectorYN", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_faceDetectorYN_setTopK(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FaceDetectorYN> * self1 = 0;
    if (!evision_FaceDetectorYN_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FaceDetectorYN>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FaceDetectorYN> _self_ = *(self1);
    int top_k=0;

    // const char* keywords[] = { "top_k", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "top_k"), top_k, ArgInfo("top_k", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setTopK(top_k), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "FaceDetectorYN", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (FaceDetectorYN)

template<>
struct Evision_Converter< Ptr<cv::FaceDetectorYN> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::FaceDetectorYN>& r)
    {
        return evision_FaceDetectorYN_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::FaceDetectorYN>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::FaceDetectorYN> * dst_ = nullptr;
        if (evision_FaceDetectorYN_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::FaceDetectorYN> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// FaceRecognizerSF (Generic)
//================================================================================

// GetSet (FaceRecognizerSF)



// Methods (FaceRecognizerSF)

static ERL_NIF_TERM evision_cv_faceRecognizerSF_alignCrop(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FaceRecognizerSF> * self1 = 0;
    if (!evision_FaceRecognizerSF_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FaceRecognizerSF>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FaceRecognizerSF> _self_ = *(self1);

    {
    Mat src_img;
    Mat face_box;
    Mat aligned_img;

    // const char* keywords[] = { "src_img", "face_box", "aligned_img", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "src_img"), src_img, ArgInfo("src_img", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "face_box"), face_box, ArgInfo("face_box", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "aligned_img"), aligned_img, ArgInfo("aligned_img", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->alignCrop(src_img, face_box, aligned_img), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, aligned_img);
        }
    }

    }
    

    {
    UMat src_img;
    UMat face_box;
    UMat aligned_img;

    // const char* keywords[] = { "src_img", "face_box", "aligned_img", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "src_img"), src_img, ArgInfo("src_img", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "face_box"), face_box, ArgInfo("face_box", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "aligned_img"), aligned_img, ArgInfo("aligned_img", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->alignCrop(src_img, face_box, aligned_img), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, aligned_img);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_faceRecognizerSF_create_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    String model;
    String config;
    int backend_id=0;
    int target_id=0;
    Ptr<FaceRecognizerSF> retval;

    // const char* keywords[] = { "model", "config", "backend_id", "target_id", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "model"), model, ArgInfo("model", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "config"), config, ArgInfo("config", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "backend_id"), backend_id, ArgInfo("backend_id", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "target_id"), target_id, ArgInfo("target_id", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::FaceRecognizerSF::create(model, config, backend_id, target_id), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_faceRecognizerSF_feature(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FaceRecognizerSF> * self1 = 0;
    if (!evision_FaceRecognizerSF_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FaceRecognizerSF>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FaceRecognizerSF> _self_ = *(self1);

    {
    Mat aligned_img;
    Mat face_feature;

    // const char* keywords[] = { "aligned_img", "face_feature", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "aligned_img"), aligned_img, ArgInfo("aligned_img", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "face_feature"), face_feature, ArgInfo("face_feature", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->feature(aligned_img, face_feature), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, face_feature);
        }
    }

    }
    

    {
    UMat aligned_img;
    UMat face_feature;

    // const char* keywords[] = { "aligned_img", "face_feature", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "aligned_img"), aligned_img, ArgInfo("aligned_img", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "face_feature"), face_feature, ArgInfo("face_feature", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->feature(aligned_img, face_feature), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, face_feature);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_faceRecognizerSF_match(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FaceRecognizerSF> * self1 = 0;
    if (!evision_FaceRecognizerSF_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FaceRecognizerSF>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FaceRecognizerSF> _self_ = *(self1);

    {
    Mat face_feature1;
    Mat face_feature2;
    int dis_type=FaceRecognizerSF::FR_COSINE;
    double retval;

    // const char* keywords[] = { "face_feature1", "face_feature2", "dis_type", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "face_feature1"), face_feature1, ArgInfo("face_feature1", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "face_feature2"), face_feature2, ArgInfo("face_feature2", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dis_type"), dis_type, ArgInfo("dis_type", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->match(face_feature1, face_feature2, dis_type), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    UMat face_feature1;
    UMat face_feature2;
    int dis_type=FaceRecognizerSF::FR_COSINE;
    double retval;

    // const char* keywords[] = { "face_feature1", "face_feature2", "dis_type", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "face_feature1"), face_feature1, ArgInfo("face_feature1", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "face_feature2"), face_feature2, ArgInfo("face_feature2", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dis_type"), dis_type, ArgInfo("dis_type", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->match(face_feature1, face_feature2, dis_type), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (FaceRecognizerSF)

template<>
struct Evision_Converter< Ptr<cv::FaceRecognizerSF> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::FaceRecognizerSF>& r)
    {
        return evision_FaceRecognizerSF_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::FaceRecognizerSF>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::FaceRecognizerSF> * dst_ = nullptr;
        if (evision_FaceRecognizerSF_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::FaceRecognizerSF> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// FarnebackOpticalFlow (Generic)
//================================================================================

// GetSet (FarnebackOpticalFlow)



// Methods (FarnebackOpticalFlow)

static ERL_NIF_TERM evision_cv_farnebackOpticalFlow_create_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    int numLevels=5;
    double pyrScale=0.5;
    bool fastPyramids=false;
    int winSize=13;
    int numIters=10;
    int polyN=5;
    double polySigma=1.1;
    int flags=0;
    Ptr<FarnebackOpticalFlow> retval;

    // const char* keywords[] = { "numLevels", "pyrScale", "fastPyramids", "winSize", "numIters", "polyN", "polySigma", "flags", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "numLevels"), numLevels, ArgInfo("numLevels", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pyrScale"), pyrScale, ArgInfo("pyrScale", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "fastPyramids"), fastPyramids, ArgInfo("fastPyramids", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "winSize"), winSize, ArgInfo("winSize", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "numIters"), numIters, ArgInfo("numIters", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "polyN"), polyN, ArgInfo("polyN", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "polySigma"), polySigma, ArgInfo("polySigma", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::FarnebackOpticalFlow::create(numLevels, pyrScale, fastPyramids, winSize, numIters, polyN, polySigma, flags), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_farnebackOpticalFlow_getFastPyramids(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FarnebackOpticalFlow> * self1 = 0;
    if (!evision_FarnebackOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FarnebackOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FarnebackOpticalFlow> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getFastPyramids(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_farnebackOpticalFlow_getFlags(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FarnebackOpticalFlow> * self1 = 0;
    if (!evision_FarnebackOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FarnebackOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FarnebackOpticalFlow> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getFlags(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_farnebackOpticalFlow_getNumIters(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FarnebackOpticalFlow> * self1 = 0;
    if (!evision_FarnebackOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FarnebackOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FarnebackOpticalFlow> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getNumIters(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_farnebackOpticalFlow_getNumLevels(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FarnebackOpticalFlow> * self1 = 0;
    if (!evision_FarnebackOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FarnebackOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FarnebackOpticalFlow> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getNumLevels(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_farnebackOpticalFlow_getPolyN(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FarnebackOpticalFlow> * self1 = 0;
    if (!evision_FarnebackOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FarnebackOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FarnebackOpticalFlow> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getPolyN(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_farnebackOpticalFlow_getPolySigma(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FarnebackOpticalFlow> * self1 = 0;
    if (!evision_FarnebackOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FarnebackOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FarnebackOpticalFlow> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getPolySigma(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_farnebackOpticalFlow_getPyrScale(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FarnebackOpticalFlow> * self1 = 0;
    if (!evision_FarnebackOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FarnebackOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FarnebackOpticalFlow> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getPyrScale(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_farnebackOpticalFlow_getWinSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FarnebackOpticalFlow> * self1 = 0;
    if (!evision_FarnebackOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FarnebackOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FarnebackOpticalFlow> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getWinSize(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_farnebackOpticalFlow_setFastPyramids(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FarnebackOpticalFlow> * self1 = 0;
    if (!evision_FarnebackOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FarnebackOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FarnebackOpticalFlow> _self_ = *(self1);
    bool fastPyramids=0;

    // const char* keywords[] = { "fastPyramids", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fastPyramids"), fastPyramids, ArgInfo("fastPyramids", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setFastPyramids(fastPyramids), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "FarnebackOpticalFlow", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_farnebackOpticalFlow_setFlags(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FarnebackOpticalFlow> * self1 = 0;
    if (!evision_FarnebackOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FarnebackOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FarnebackOpticalFlow> _self_ = *(self1);
    int flags=0;

    // const char* keywords[] = { "flags", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setFlags(flags), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "FarnebackOpticalFlow", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_farnebackOpticalFlow_setNumIters(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FarnebackOpticalFlow> * self1 = 0;
    if (!evision_FarnebackOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FarnebackOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FarnebackOpticalFlow> _self_ = *(self1);
    int numIters=0;

    // const char* keywords[] = { "numIters", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "numIters"), numIters, ArgInfo("numIters", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setNumIters(numIters), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "FarnebackOpticalFlow", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_farnebackOpticalFlow_setNumLevels(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FarnebackOpticalFlow> * self1 = 0;
    if (!evision_FarnebackOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FarnebackOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FarnebackOpticalFlow> _self_ = *(self1);
    int numLevels=0;

    // const char* keywords[] = { "numLevels", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "numLevels"), numLevels, ArgInfo("numLevels", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setNumLevels(numLevels), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "FarnebackOpticalFlow", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_farnebackOpticalFlow_setPolyN(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FarnebackOpticalFlow> * self1 = 0;
    if (!evision_FarnebackOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FarnebackOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FarnebackOpticalFlow> _self_ = *(self1);
    int polyN=0;

    // const char* keywords[] = { "polyN", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "polyN"), polyN, ArgInfo("polyN", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setPolyN(polyN), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "FarnebackOpticalFlow", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_farnebackOpticalFlow_setPolySigma(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FarnebackOpticalFlow> * self1 = 0;
    if (!evision_FarnebackOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FarnebackOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FarnebackOpticalFlow> _self_ = *(self1);
    double polySigma=0;

    // const char* keywords[] = { "polySigma", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "polySigma"), polySigma, ArgInfo("polySigma", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setPolySigma(polySigma), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "FarnebackOpticalFlow", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_farnebackOpticalFlow_setPyrScale(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FarnebackOpticalFlow> * self1 = 0;
    if (!evision_FarnebackOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FarnebackOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FarnebackOpticalFlow> _self_ = *(self1);
    double pyrScale=0;

    // const char* keywords[] = { "pyrScale", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "pyrScale"), pyrScale, ArgInfo("pyrScale", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setPyrScale(pyrScale), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "FarnebackOpticalFlow", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_farnebackOpticalFlow_setWinSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FarnebackOpticalFlow> * self1 = 0;
    if (!evision_FarnebackOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FarnebackOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FarnebackOpticalFlow> _self_ = *(self1);
    int winSize=0;

    // const char* keywords[] = { "winSize", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "winSize"), winSize, ArgInfo("winSize", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setWinSize(winSize), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "FarnebackOpticalFlow", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (FarnebackOpticalFlow)

template<>
struct Evision_Converter< Ptr<cv::FarnebackOpticalFlow> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::FarnebackOpticalFlow>& r)
    {
        return evision_FarnebackOpticalFlow_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::FarnebackOpticalFlow>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::FarnebackOpticalFlow> * dst_ = nullptr;
        if (evision_FarnebackOpticalFlow_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::FarnebackOpticalFlow> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// FastFeatureDetector (Generic)
//================================================================================

// GetSet (FastFeatureDetector)



// Methods (FastFeatureDetector)

static ERL_NIF_TERM evision_cv_fastFeatureDetector_compute(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FastFeatureDetector> * self1 = 0;
    if (!evision_FastFeatureDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FastFeatureDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FastFeatureDetector> _self_ = *(self1);

    {
    Mat image;
    vector_KeyPoint keypoints;
    Mat descriptors;

    // const char* keywords[] = { "image", "keypoints", "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints"), keypoints, ArgInfo("keypoints", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute(image, keypoints, descriptors), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }
    

    {
    UMat image;
    vector_KeyPoint keypoints;
    UMat descriptors;

    // const char* keywords[] = { "image", "keypoints", "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints"), keypoints, ArgInfo("keypoints", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute(image, keypoints, descriptors), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }
    

    {
    vector_Mat images;
    vector_vector_KeyPoint keypoints;
    vector_Mat descriptors;

    // const char* keywords[] = { "images", "keypoints", "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints"), keypoints, ArgInfo("keypoints", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute(images, keypoints, descriptors), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }
    

    {
    vector_UMat images;
    vector_vector_KeyPoint keypoints;
    vector_UMat descriptors;

    // const char* keywords[] = { "images", "keypoints", "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints"), keypoints, ArgInfo("keypoints", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute(images, keypoints, descriptors), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fastFeatureDetector_create_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    int threshold=10;
    bool nonmaxSuppression=true;
    std::underlying_type_t<FastFeatureDetector_DetectorType> type=static_cast<std::underlying_type_t<FastFeatureDetector_DetectorType>>(FastFeatureDetector::TYPE_9_16);
    Ptr<FastFeatureDetector> retval;

    // const char* keywords[] = { "threshold", "nonmaxSuppression", "type", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "threshold"), threshold, ArgInfo("threshold", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nonmaxSuppression"), nonmaxSuppression, ArgInfo("nonmaxSuppression", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "type"), type, ArgInfo("type", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::FastFeatureDetector::create(threshold, nonmaxSuppression, static_cast<FastFeatureDetector_DetectorType>(type)), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fastFeatureDetector_defaultNorm(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FastFeatureDetector> * self1 = 0;
    if (!evision_FastFeatureDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FastFeatureDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FastFeatureDetector> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->defaultNorm(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fastFeatureDetector_descriptorSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FastFeatureDetector> * self1 = 0;
    if (!evision_FastFeatureDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FastFeatureDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FastFeatureDetector> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->descriptorSize(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fastFeatureDetector_descriptorType(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FastFeatureDetector> * self1 = 0;
    if (!evision_FastFeatureDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FastFeatureDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FastFeatureDetector> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->descriptorType(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fastFeatureDetector_detect(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FastFeatureDetector> * self1 = 0;
    if (!evision_FastFeatureDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FastFeatureDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FastFeatureDetector> _self_ = *(self1);

    {
    Mat image;
    vector_KeyPoint keypoints;
    Mat mask;

    // const char* keywords[] = { "image", "mask", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(image, keypoints, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, keypoints);
        }
    }

    }
    

    {
    UMat image;
    vector_KeyPoint keypoints;
    UMat mask;

    // const char* keywords[] = { "image", "mask", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(image, keypoints, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, keypoints);
        }
    }

    }
    

    {
    vector_Mat images;
    vector_vector_KeyPoint keypoints;
    vector_Mat masks;

    // const char* keywords[] = { "images", "masks", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "masks"), masks, ArgInfo("masks", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(images, keypoints, masks), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, keypoints);
        }
    }

    }
    

    {
    vector_UMat images;
    vector_vector_KeyPoint keypoints;
    vector_UMat masks;

    // const char* keywords[] = { "images", "masks", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "masks"), masks, ArgInfo("masks", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(images, keypoints, masks), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, keypoints);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fastFeatureDetector_detectAndCompute(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FastFeatureDetector> * self1 = 0;
    if (!evision_FastFeatureDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FastFeatureDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FastFeatureDetector> _self_ = *(self1);

    {
    Mat image;
    Mat mask;
    vector_KeyPoint keypoints;
    Mat descriptors;
    bool useProvidedKeypoints=false;

    // const char* keywords[] = { "image", "mask", "descriptors", "useProvidedKeypoints", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "useProvidedKeypoints"), useProvidedKeypoints, ArgInfo("useProvidedKeypoints", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detectAndCompute(image, mask, keypoints, descriptors, useProvidedKeypoints), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }
    

    {
    UMat image;
    UMat mask;
    vector_KeyPoint keypoints;
    UMat descriptors;
    bool useProvidedKeypoints=false;

    // const char* keywords[] = { "image", "mask", "descriptors", "useProvidedKeypoints", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "useProvidedKeypoints"), useProvidedKeypoints, ArgInfo("useProvidedKeypoints", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detectAndCompute(image, mask, keypoints, descriptors, useProvidedKeypoints), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fastFeatureDetector_empty(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FastFeatureDetector> * self1 = 0;
    if (!evision_FastFeatureDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FastFeatureDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FastFeatureDetector> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->empty(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fastFeatureDetector_getDefaultName(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FastFeatureDetector> * self1 = 0;
    if (!evision_FastFeatureDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FastFeatureDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FastFeatureDetector> _self_ = *(self1);
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getDefaultName(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fastFeatureDetector_getNonmaxSuppression(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FastFeatureDetector> * self1 = 0;
    if (!evision_FastFeatureDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FastFeatureDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FastFeatureDetector> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getNonmaxSuppression(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fastFeatureDetector_getThreshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FastFeatureDetector> * self1 = 0;
    if (!evision_FastFeatureDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FastFeatureDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FastFeatureDetector> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getThreshold(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fastFeatureDetector_getType(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FastFeatureDetector> * self1 = 0;
    if (!evision_FastFeatureDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FastFeatureDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FastFeatureDetector> _self_ = *(self1);
    FastFeatureDetector::DetectorType retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getType(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fastFeatureDetector_read(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FastFeatureDetector> * self1 = 0;
    if (!evision_FastFeatureDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FastFeatureDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FastFeatureDetector> _self_ = *(self1);

    {
    String fileName;

    // const char* keywords[] = { "fileName", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fileName"), fileName, ArgInfo("fileName", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->read(fileName), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "FastFeatureDetector", success);
        }
    }

    }
    

    {
    FileNode arg1;

    // const char* keywords[] = { "arg1", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "arg1"), arg1, ArgInfo("arg1", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->read(arg1), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "FastFeatureDetector", success);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fastFeatureDetector_setNonmaxSuppression(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FastFeatureDetector> * self1 = 0;
    if (!evision_FastFeatureDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FastFeatureDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FastFeatureDetector> _self_ = *(self1);
    bool f=0;

    // const char* keywords[] = { "f", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "f"), f, ArgInfo("f", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setNonmaxSuppression(f), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "FastFeatureDetector", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fastFeatureDetector_setThreshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FastFeatureDetector> * self1 = 0;
    if (!evision_FastFeatureDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FastFeatureDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FastFeatureDetector> _self_ = *(self1);
    int threshold=0;

    // const char* keywords[] = { "threshold", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "threshold"), threshold, ArgInfo("threshold", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setThreshold(threshold), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "FastFeatureDetector", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fastFeatureDetector_setType(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FastFeatureDetector> * self1 = 0;
    if (!evision_FastFeatureDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FastFeatureDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FastFeatureDetector> _self_ = *(self1);
    std::underlying_type_t<FastFeatureDetector_DetectorType> type=static_cast<std::underlying_type_t<FastFeatureDetector_DetectorType>>(static_cast<FastFeatureDetector_DetectorType>(0));

    // const char* keywords[] = { "type", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "type"), type, ArgInfo("type", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setType(static_cast<FastFeatureDetector_DetectorType>(type)), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "FastFeatureDetector", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fastFeatureDetector_write(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FastFeatureDetector> * self1 = 0;
    if (!evision_FastFeatureDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FastFeatureDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FastFeatureDetector> _self_ = *(self1);

    {
    String fileName;

    // const char* keywords[] = { "fileName", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fileName"), fileName, ArgInfo("fileName", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->write(fileName), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "FastFeatureDetector", success);
        }
    }

    }
    

    {
    Ptr<FileStorage> fs;
    String name;

    // const char* keywords[] = { "fs", "name", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fs"), fs, ArgInfo("fs", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "name"), name, ArgInfo("name", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->write(fs, name), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "FastFeatureDetector", success);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (FastFeatureDetector)

template<>
struct Evision_Converter< Ptr<cv::FastFeatureDetector> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::FastFeatureDetector>& r)
    {
        return evision_FastFeatureDetector_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::FastFeatureDetector>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::FastFeatureDetector> * dst_ = nullptr;
        if (evision_FastFeatureDetector_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::FastFeatureDetector> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// Feature2D (Generic)
//================================================================================

// GetSet (Feature2D)



// Methods (Feature2D)

static ERL_NIF_TERM evision_cv_feature2D_compute(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Feature2D> * self1 = 0;
    if (!evision_Feature2D_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Feature2D>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Feature2D> _self_ = *(self1);

    {
    Mat image;
    vector_KeyPoint keypoints;
    Mat descriptors;

    // const char* keywords[] = { "image", "keypoints", "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints"), keypoints, ArgInfo("keypoints", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute(image, keypoints, descriptors), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }
    

    {
    UMat image;
    vector_KeyPoint keypoints;
    UMat descriptors;

    // const char* keywords[] = { "image", "keypoints", "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints"), keypoints, ArgInfo("keypoints", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute(image, keypoints, descriptors), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }
    

    {
    vector_Mat images;
    vector_vector_KeyPoint keypoints;
    vector_Mat descriptors;

    // const char* keywords[] = { "images", "keypoints", "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints"), keypoints, ArgInfo("keypoints", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute(images, keypoints, descriptors), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }
    

    {
    vector_UMat images;
    vector_vector_KeyPoint keypoints;
    vector_UMat descriptors;

    // const char* keywords[] = { "images", "keypoints", "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints"), keypoints, ArgInfo("keypoints", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute(images, keypoints, descriptors), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_feature2D_defaultNorm(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Feature2D> * self1 = 0;
    if (!evision_Feature2D_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Feature2D>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Feature2D> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->defaultNorm(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_feature2D_descriptorSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Feature2D> * self1 = 0;
    if (!evision_Feature2D_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Feature2D>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Feature2D> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->descriptorSize(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_feature2D_descriptorType(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Feature2D> * self1 = 0;
    if (!evision_Feature2D_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Feature2D>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Feature2D> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->descriptorType(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_feature2D_detect(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Feature2D> * self1 = 0;
    if (!evision_Feature2D_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Feature2D>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Feature2D> _self_ = *(self1);

    {
    Mat image;
    vector_KeyPoint keypoints;
    Mat mask;

    // const char* keywords[] = { "image", "mask", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(image, keypoints, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, keypoints);
        }
    }

    }
    

    {
    UMat image;
    vector_KeyPoint keypoints;
    UMat mask;

    // const char* keywords[] = { "image", "mask", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(image, keypoints, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, keypoints);
        }
    }

    }
    

    {
    vector_Mat images;
    vector_vector_KeyPoint keypoints;
    vector_Mat masks;

    // const char* keywords[] = { "images", "masks", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "masks"), masks, ArgInfo("masks", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(images, keypoints, masks), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, keypoints);
        }
    }

    }
    

    {
    vector_UMat images;
    vector_vector_KeyPoint keypoints;
    vector_UMat masks;

    // const char* keywords[] = { "images", "masks", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "masks"), masks, ArgInfo("masks", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(images, keypoints, masks), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, keypoints);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_feature2D_detectAndCompute(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Feature2D> * self1 = 0;
    if (!evision_Feature2D_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Feature2D>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Feature2D> _self_ = *(self1);

    {
    Mat image;
    Mat mask;
    vector_KeyPoint keypoints;
    Mat descriptors;
    bool useProvidedKeypoints=false;

    // const char* keywords[] = { "image", "mask", "descriptors", "useProvidedKeypoints", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "useProvidedKeypoints"), useProvidedKeypoints, ArgInfo("useProvidedKeypoints", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detectAndCompute(image, mask, keypoints, descriptors, useProvidedKeypoints), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }
    

    {
    UMat image;
    UMat mask;
    vector_KeyPoint keypoints;
    UMat descriptors;
    bool useProvidedKeypoints=false;

    // const char* keywords[] = { "image", "mask", "descriptors", "useProvidedKeypoints", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "useProvidedKeypoints"), useProvidedKeypoints, ArgInfo("useProvidedKeypoints", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detectAndCompute(image, mask, keypoints, descriptors, useProvidedKeypoints), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_feature2D_empty(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Feature2D> * self1 = 0;
    if (!evision_Feature2D_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Feature2D>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Feature2D> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->empty(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_feature2D_getDefaultName(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Feature2D> * self1 = 0;
    if (!evision_Feature2D_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Feature2D>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Feature2D> _self_ = *(self1);
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getDefaultName(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_feature2D_read(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Feature2D> * self1 = 0;
    if (!evision_Feature2D_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Feature2D>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Feature2D> _self_ = *(self1);

    {
    String fileName;

    // const char* keywords[] = { "fileName", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fileName"), fileName, ArgInfo("fileName", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->read(fileName), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Feature2D", success);
        }
    }

    }
    

    {
    FileNode arg1;

    // const char* keywords[] = { "arg1", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "arg1"), arg1, ArgInfo("arg1", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->read(arg1), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Feature2D", success);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_feature2D_write(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Feature2D> * self1 = 0;
    if (!evision_Feature2D_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Feature2D>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Feature2D> _self_ = *(self1);

    {
    String fileName;

    // const char* keywords[] = { "fileName", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fileName"), fileName, ArgInfo("fileName", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->write(fileName), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Feature2D", success);
        }
    }

    }
    

    {
    Ptr<FileStorage> fs;
    String name;

    // const char* keywords[] = { "fs", "name", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fs"), fs, ArgInfo("fs", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "name"), name, ArgInfo("name", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->write(fs, name), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Feature2D", success);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (Feature2D)

template<>
struct Evision_Converter< Ptr<cv::Feature2D> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::Feature2D>& r)
    {
        return evision_Feature2D_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::Feature2D>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::Feature2D> * dst_ = nullptr;
        if (evision_Feature2D_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::Feature2D> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// FileNode (Generic)
//================================================================================

// GetSet (FileNode)



// Methods (FileNode)

static ERL_NIF_TERM evision_cv_fileNode_FileNode(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        evision_res<cv::FileNode> * self = nullptr;
        if (alloc_resource(&self)) ERRWRAP2(new (&(self->val)) cv::FileNode(), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<cv::FileNode>(env, self->val, ret, "FileNode", success);;
        }
    }

    return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fileNode_at(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::FileNode * self1 = 0;
    if (!evision_FileNode_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::FileNode` from `self`: mismatched type or invalid resource?");
    }
    cv::FileNode* _self_ = (self1);
    int i=0;
    FileNode retval;

    // const char* keywords[] = { "i", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "i"), i, ArgInfo("i", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->operator[](i), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fileNode_empty(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::FileNode * self1 = 0;
    if (!evision_FileNode_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::FileNode` from `self`: mismatched type or invalid resource?");
    }
    cv::FileNode* _self_ = (self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->empty(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fileNode_getNode(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::FileNode * self1 = 0;
    if (!evision_FileNode_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::FileNode` from `self`: mismatched type or invalid resource?");
    }
    cv::FileNode* _self_ = (self1);
    char* nodename=(char*)"";
    FileNode retval;

    // const char* keywords[] = { "nodename", NULL }; // <- no more in use, left for debugging purpose
    if( convert_to_char(env, evision_get_kw(env, erl_terms, "nodename"), &nodename, ArgInfo("nodename", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->operator[](nodename), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fileNode_isInt(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::FileNode * self1 = 0;
    if (!evision_FileNode_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::FileNode` from `self`: mismatched type or invalid resource?");
    }
    cv::FileNode* _self_ = (self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->isInt(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fileNode_isMap(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::FileNode * self1 = 0;
    if (!evision_FileNode_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::FileNode` from `self`: mismatched type or invalid resource?");
    }
    cv::FileNode* _self_ = (self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->isMap(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fileNode_isNamed(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::FileNode * self1 = 0;
    if (!evision_FileNode_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::FileNode` from `self`: mismatched type or invalid resource?");
    }
    cv::FileNode* _self_ = (self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->isNamed(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fileNode_isNone(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::FileNode * self1 = 0;
    if (!evision_FileNode_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::FileNode` from `self`: mismatched type or invalid resource?");
    }
    cv::FileNode* _self_ = (self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->isNone(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fileNode_isReal(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::FileNode * self1 = 0;
    if (!evision_FileNode_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::FileNode` from `self`: mismatched type or invalid resource?");
    }
    cv::FileNode* _self_ = (self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->isReal(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fileNode_isSeq(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::FileNode * self1 = 0;
    if (!evision_FileNode_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::FileNode` from `self`: mismatched type or invalid resource?");
    }
    cv::FileNode* _self_ = (self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->isSeq(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fileNode_isString(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::FileNode * self1 = 0;
    if (!evision_FileNode_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::FileNode` from `self`: mismatched type or invalid resource?");
    }
    cv::FileNode* _self_ = (self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->isString(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fileNode_keys(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::FileNode * self1 = 0;
    if (!evision_FileNode_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::FileNode` from `self`: mismatched type or invalid resource?");
    }
    cv::FileNode* _self_ = (self1);
    std::vector<String> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->keys(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fileNode_mat(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::FileNode * self1 = 0;
    if (!evision_FileNode_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::FileNode` from `self`: mismatched type or invalid resource?");
    }
    cv::FileNode* _self_ = (self1);
    Mat retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->mat(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fileNode_name(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::FileNode * self1 = 0;
    if (!evision_FileNode_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::FileNode` from `self`: mismatched type or invalid resource?");
    }
    cv::FileNode* _self_ = (self1);
    std::string retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->name(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fileNode_rawSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::FileNode * self1 = 0;
    if (!evision_FileNode_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::FileNode` from `self`: mismatched type or invalid resource?");
    }
    cv::FileNode* _self_ = (self1);
    size_t retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->rawSize(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fileNode_real(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::FileNode * self1 = 0;
    if (!evision_FileNode_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::FileNode` from `self`: mismatched type or invalid resource?");
    }
    cv::FileNode* _self_ = (self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->real(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fileNode_size(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::FileNode * self1 = 0;
    if (!evision_FileNode_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::FileNode` from `self`: mismatched type or invalid resource?");
    }
    cv::FileNode* _self_ = (self1);
    size_t retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->size(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fileNode_string(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::FileNode * self1 = 0;
    if (!evision_FileNode_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::FileNode` from `self`: mismatched type or invalid resource?");
    }
    cv::FileNode* _self_ = (self1);
    std::string retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->string(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fileNode_type(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::FileNode * self1 = 0;
    if (!evision_FileNode_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::FileNode` from `self`: mismatched type or invalid resource?");
    }
    cv::FileNode* _self_ = (self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->type(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (FileNode)

template<>
struct Evision_Converter< cv::FileNode >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const cv::FileNode& r)
    {
        return evision_FileNode_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, cv::FileNode& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        cv::FileNode * dst_ = nullptr;
        if (evision_FileNode_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected cv::FileNode for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// FileStorage (Generic)
//================================================================================

// GetSet (FileStorage)



// Methods (FileStorage)

static ERL_NIF_TERM evision_cv_fileStorage_FileStorage(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    {

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        evision_res<Ptr<cv::FileStorage>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::FileStorage>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::FileStorage()), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::FileStorage>>(env, self->val, ret, "FileStorage", success);;
        }
    }

    }
    

    {
    String filename;
    int flags=0;
    String encoding;

    // const char* keywords[] = { "filename", "flags", "encoding", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "encoding"), encoding, ArgInfo("encoding", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::FileStorage>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::FileStorage>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::FileStorage(filename, flags, encoding)), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::FileStorage>>(env, self->val, ret, "FileStorage", success);;
        }
    }

    }

    return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fileStorage_endWriteStruct(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FileStorage> * self1 = 0;
    if (!evision_FileStorage_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FileStorage>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FileStorage> _self_ = *(self1);

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->endWriteStruct(), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "FileStorage", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fileStorage_getFirstTopLevelNode(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FileStorage> * self1 = 0;
    if (!evision_FileStorage_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FileStorage>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FileStorage> _self_ = *(self1);
    FileNode retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getFirstTopLevelNode(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fileStorage_getFormat(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FileStorage> * self1 = 0;
    if (!evision_FileStorage_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FileStorage>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FileStorage> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getFormat(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fileStorage_getNode(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FileStorage> * self1 = 0;
    if (!evision_FileStorage_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FileStorage>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FileStorage> _self_ = *(self1);
    char* nodename=(char*)"";
    FileNode retval;

    // const char* keywords[] = { "nodename", NULL }; // <- no more in use, left for debugging purpose
    if( convert_to_char(env, evision_get_kw(env, erl_terms, "nodename"), &nodename, ArgInfo("nodename", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->operator[](nodename), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fileStorage_isOpened(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FileStorage> * self1 = 0;
    if (!evision_FileStorage_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FileStorage>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FileStorage> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->isOpened(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fileStorage_open(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FileStorage> * self1 = 0;
    if (!evision_FileStorage_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FileStorage>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FileStorage> _self_ = *(self1);
    String filename;
    int flags=0;
    String encoding;
    bool retval;

    // const char* keywords[] = { "filename", "flags", "encoding", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "encoding"), encoding, ArgInfo("encoding", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->open(filename, flags, encoding), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fileStorage_release(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FileStorage> * self1 = 0;
    if (!evision_FileStorage_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FileStorage>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FileStorage> _self_ = *(self1);

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->release(), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "FileStorage", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fileStorage_releaseAndGetString(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FileStorage> * self1 = 0;
    if (!evision_FileStorage_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FileStorage>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FileStorage> _self_ = *(self1);
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->releaseAndGetString(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fileStorage_root(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FileStorage> * self1 = 0;
    if (!evision_FileStorage_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FileStorage>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FileStorage> _self_ = *(self1);
    int streamidx=0;
    FileNode retval;

    // const char* keywords[] = { "streamidx", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "streamidx"), streamidx, ArgInfo("streamidx", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->root(streamidx), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fileStorage_startWriteStruct(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FileStorage> * self1 = 0;
    if (!evision_FileStorage_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FileStorage>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FileStorage> _self_ = *(self1);
    String name;
    int flags=0;
    String typeName;

    // const char* keywords[] = { "name", "flags", "typeName", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "name"), name, ArgInfo("name", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "typeName"), typeName, ArgInfo("typeName", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->startWriteStruct(name, flags, typeName), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "FileStorage", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fileStorage_write(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FileStorage> * self1 = 0;
    if (!evision_FileStorage_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FileStorage>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FileStorage> _self_ = *(self1);

    {
    String name;
    int val=0;

    // const char* keywords[] = { "name", "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "name"), name, ArgInfo("name", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->write(name, val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "FileStorage", success);
        }
    }

    }
    

    {
    String name;
    double val=0;

    // const char* keywords[] = { "name", "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "name"), name, ArgInfo("name", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->write(name, val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "FileStorage", success);
        }
    }

    }
    

    {
    String name;
    String val;

    // const char* keywords[] = { "name", "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "name"), name, ArgInfo("name", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->write(name, val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "FileStorage", success);
        }
    }

    }
    

    {
    String name;
    Mat val;

    // const char* keywords[] = { "name", "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "name"), name, ArgInfo("name", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->write(name, val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "FileStorage", success);
        }
    }

    }
    

    {
    String name;
    vector_String val;

    // const char* keywords[] = { "name", "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "name"), name, ArgInfo("name", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->write(name, val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "FileStorage", success);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fileStorage_writeComment(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FileStorage> * self1 = 0;
    if (!evision_FileStorage_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FileStorage>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FileStorage> _self_ = *(self1);
    String comment;
    bool append=false;

    // const char* keywords[] = { "comment", "append", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "comment"), comment, ArgInfo("comment", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "append"), append, ArgInfo("append", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->writeComment(comment, append), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "FileStorage", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (FileStorage)

template<>
struct Evision_Converter< Ptr<cv::FileStorage> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::FileStorage>& r)
    {
        return evision_FileStorage_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::FileStorage>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::FileStorage> * dst_ = nullptr;
        if (evision_FileStorage_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::FileStorage> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// FlannBasedMatcher (Generic)
//================================================================================

// GetSet (FlannBasedMatcher)



// Methods (FlannBasedMatcher)

static ERL_NIF_TERM evision_cv_flannBasedMatcher_FlannBasedMatcher(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    Ptr<flann::IndexParams> indexParams=makePtr<flann::KDTreeIndexParams>();
    Ptr<flann::SearchParams> searchParams=makePtr<flann::SearchParams>();

    // const char* keywords[] = { "indexParams", "searchParams", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "indexParams"), indexParams, ArgInfo("indexParams", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "searchParams"), searchParams, ArgInfo("searchParams", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::FlannBasedMatcher>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::FlannBasedMatcher>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::FlannBasedMatcher(indexParams, searchParams)), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::FlannBasedMatcher>>(env, self->val, ret, "FlannBasedMatcher", success);;
        }
    }

    return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_flannBasedMatcher_add(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FlannBasedMatcher> * self1 = 0;
    if (!evision_FlannBasedMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FlannBasedMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FlannBasedMatcher> _self_ = *(self1);

    {
    vector_Mat descriptors;

    // const char* keywords[] = { "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::add(descriptors), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "FlannBasedMatcher", success);
        }
    }

    }
    

    {
    vector_UMat descriptors;

    // const char* keywords[] = { "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::add(descriptors), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "FlannBasedMatcher", success);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_flannBasedMatcher_clear(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FlannBasedMatcher> * self1 = 0;
    if (!evision_FlannBasedMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FlannBasedMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FlannBasedMatcher> _self_ = *(self1);

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::clear(), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "FlannBasedMatcher", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_flannBasedMatcher_clone(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FlannBasedMatcher> * self1 = 0;
    if (!evision_FlannBasedMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FlannBasedMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FlannBasedMatcher> _self_ = *(self1);
    bool emptyTrainData=false;
    Ptr<DescriptorMatcher> retval;

    // const char* keywords[] = { "emptyTrainData", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "emptyTrainData"), emptyTrainData, ArgInfo("emptyTrainData", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->clone(emptyTrainData), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_flannBasedMatcher_create_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    Ptr<FlannBasedMatcher> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::FlannBasedMatcher::create(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_flannBasedMatcher_empty(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FlannBasedMatcher> * self1 = 0;
    if (!evision_FlannBasedMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FlannBasedMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FlannBasedMatcher> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->DescriptorMatcher::empty(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_flannBasedMatcher_getDefaultName(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FlannBasedMatcher> * self1 = 0;
    if (!evision_FlannBasedMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FlannBasedMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FlannBasedMatcher> _self_ = *(self1);
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->Algorithm::getDefaultName(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_flannBasedMatcher_getTrainDescriptors(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FlannBasedMatcher> * self1 = 0;
    if (!evision_FlannBasedMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FlannBasedMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FlannBasedMatcher> _self_ = *(self1);
    std::vector<Mat> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->DescriptorMatcher::getTrainDescriptors(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_flannBasedMatcher_isMaskSupported(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FlannBasedMatcher> * self1 = 0;
    if (!evision_FlannBasedMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FlannBasedMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FlannBasedMatcher> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->isMaskSupported(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_flannBasedMatcher_knnMatch(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FlannBasedMatcher> * self1 = 0;
    if (!evision_FlannBasedMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FlannBasedMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FlannBasedMatcher> _self_ = *(self1);

    {
    Mat queryDescriptors;
    Mat trainDescriptors;
    vector_vector_DMatch matches;
    int k=0;
    Mat mask;
    bool compactResult=false;

    // const char* keywords[] = { "queryDescriptors", "trainDescriptors", "k", "mask", "compactResult", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "queryDescriptors"), queryDescriptors, ArgInfo("queryDescriptors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "trainDescriptors"), trainDescriptors, ArgInfo("trainDescriptors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), k, ArgInfo("k", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "compactResult"), compactResult, ArgInfo("compactResult", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::knnMatch(queryDescriptors, trainDescriptors, matches, k, mask, compactResult), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, matches);
        }
    }

    }
    

    {
    UMat queryDescriptors;
    UMat trainDescriptors;
    vector_vector_DMatch matches;
    int k=0;
    UMat mask;
    bool compactResult=false;

    // const char* keywords[] = { "queryDescriptors", "trainDescriptors", "k", "mask", "compactResult", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "queryDescriptors"), queryDescriptors, ArgInfo("queryDescriptors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "trainDescriptors"), trainDescriptors, ArgInfo("trainDescriptors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), k, ArgInfo("k", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "compactResult"), compactResult, ArgInfo("compactResult", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::knnMatch(queryDescriptors, trainDescriptors, matches, k, mask, compactResult), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, matches);
        }
    }

    }
    

    {
    Mat queryDescriptors;
    vector_vector_DMatch matches;
    int k=0;
    vector_Mat masks;
    bool compactResult=false;

    // const char* keywords[] = { "queryDescriptors", "k", "masks", "compactResult", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "queryDescriptors"), queryDescriptors, ArgInfo("queryDescriptors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), k, ArgInfo("k", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "masks"), masks, ArgInfo("masks", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "compactResult"), compactResult, ArgInfo("compactResult", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::knnMatch(queryDescriptors, matches, k, masks, compactResult), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, matches);
        }
    }

    }
    

    {
    UMat queryDescriptors;
    vector_vector_DMatch matches;
    int k=0;
    vector_UMat masks;
    bool compactResult=false;

    // const char* keywords[] = { "queryDescriptors", "k", "masks", "compactResult", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "queryDescriptors"), queryDescriptors, ArgInfo("queryDescriptors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), k, ArgInfo("k", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "masks"), masks, ArgInfo("masks", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "compactResult"), compactResult, ArgInfo("compactResult", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::knnMatch(queryDescriptors, matches, k, masks, compactResult), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, matches);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_flannBasedMatcher_match(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FlannBasedMatcher> * self1 = 0;
    if (!evision_FlannBasedMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FlannBasedMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FlannBasedMatcher> _self_ = *(self1);

    {
    Mat queryDescriptors;
    Mat trainDescriptors;
    vector_DMatch matches;
    Mat mask;

    // const char* keywords[] = { "queryDescriptors", "trainDescriptors", "mask", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "queryDescriptors"), queryDescriptors, ArgInfo("queryDescriptors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "trainDescriptors"), trainDescriptors, ArgInfo("trainDescriptors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::match(queryDescriptors, trainDescriptors, matches, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, matches);
        }
    }

    }
    

    {
    UMat queryDescriptors;
    UMat trainDescriptors;
    vector_DMatch matches;
    UMat mask;

    // const char* keywords[] = { "queryDescriptors", "trainDescriptors", "mask", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "queryDescriptors"), queryDescriptors, ArgInfo("queryDescriptors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "trainDescriptors"), trainDescriptors, ArgInfo("trainDescriptors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::match(queryDescriptors, trainDescriptors, matches, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, matches);
        }
    }

    }
    

    {
    Mat queryDescriptors;
    vector_DMatch matches;
    vector_Mat masks;

    // const char* keywords[] = { "queryDescriptors", "masks", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "queryDescriptors"), queryDescriptors, ArgInfo("queryDescriptors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "masks"), masks, ArgInfo("masks", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::match(queryDescriptors, matches, masks), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, matches);
        }
    }

    }
    

    {
    UMat queryDescriptors;
    vector_DMatch matches;
    vector_UMat masks;

    // const char* keywords[] = { "queryDescriptors", "masks", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "queryDescriptors"), queryDescriptors, ArgInfo("queryDescriptors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "masks"), masks, ArgInfo("masks", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::match(queryDescriptors, matches, masks), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, matches);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_flannBasedMatcher_radiusMatch(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FlannBasedMatcher> * self1 = 0;
    if (!evision_FlannBasedMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FlannBasedMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FlannBasedMatcher> _self_ = *(self1);

    {
    Mat queryDescriptors;
    Mat trainDescriptors;
    vector_vector_DMatch matches;
    float maxDistance=0.f;
    Mat mask;
    bool compactResult=false;

    // const char* keywords[] = { "queryDescriptors", "trainDescriptors", "maxDistance", "mask", "compactResult", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "queryDescriptors"), queryDescriptors, ArgInfo("queryDescriptors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "trainDescriptors"), trainDescriptors, ArgInfo("trainDescriptors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxDistance"), maxDistance, ArgInfo("maxDistance", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "compactResult"), compactResult, ArgInfo("compactResult", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::radiusMatch(queryDescriptors, trainDescriptors, matches, maxDistance, mask, compactResult), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, matches);
        }
    }

    }
    

    {
    UMat queryDescriptors;
    UMat trainDescriptors;
    vector_vector_DMatch matches;
    float maxDistance=0.f;
    UMat mask;
    bool compactResult=false;

    // const char* keywords[] = { "queryDescriptors", "trainDescriptors", "maxDistance", "mask", "compactResult", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "queryDescriptors"), queryDescriptors, ArgInfo("queryDescriptors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "trainDescriptors"), trainDescriptors, ArgInfo("trainDescriptors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxDistance"), maxDistance, ArgInfo("maxDistance", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "compactResult"), compactResult, ArgInfo("compactResult", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::radiusMatch(queryDescriptors, trainDescriptors, matches, maxDistance, mask, compactResult), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, matches);
        }
    }

    }
    

    {
    Mat queryDescriptors;
    vector_vector_DMatch matches;
    float maxDistance=0.f;
    vector_Mat masks;
    bool compactResult=false;

    // const char* keywords[] = { "queryDescriptors", "maxDistance", "masks", "compactResult", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "queryDescriptors"), queryDescriptors, ArgInfo("queryDescriptors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxDistance"), maxDistance, ArgInfo("maxDistance", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "masks"), masks, ArgInfo("masks", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "compactResult"), compactResult, ArgInfo("compactResult", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::radiusMatch(queryDescriptors, matches, maxDistance, masks, compactResult), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, matches);
        }
    }

    }
    

    {
    UMat queryDescriptors;
    vector_vector_DMatch matches;
    float maxDistance=0.f;
    vector_UMat masks;
    bool compactResult=false;

    // const char* keywords[] = { "queryDescriptors", "maxDistance", "masks", "compactResult", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "queryDescriptors"), queryDescriptors, ArgInfo("queryDescriptors", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxDistance"), maxDistance, ArgInfo("maxDistance", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "masks"), masks, ArgInfo("masks", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "compactResult"), compactResult, ArgInfo("compactResult", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::radiusMatch(queryDescriptors, matches, maxDistance, masks, compactResult), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, matches);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_flannBasedMatcher_read(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FlannBasedMatcher> * self1 = 0;
    if (!evision_FlannBasedMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FlannBasedMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FlannBasedMatcher> _self_ = *(self1);

    {
    String fileName;

    // const char* keywords[] = { "fileName", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fileName"), fileName, ArgInfo("fileName", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::read(fileName), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "FlannBasedMatcher", success);
        }
    }

    }
    

    {
    FileNode arg1;

    // const char* keywords[] = { "arg1", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "arg1"), arg1, ArgInfo("arg1", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::read(arg1), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "FlannBasedMatcher", success);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_flannBasedMatcher_save(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FlannBasedMatcher> * self1 = 0;
    if (!evision_FlannBasedMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FlannBasedMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FlannBasedMatcher> _self_ = *(self1);
    String filename;

    // const char* keywords[] = { "filename", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::save(filename), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "FlannBasedMatcher", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_flannBasedMatcher_train(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FlannBasedMatcher> * self1 = 0;
    if (!evision_FlannBasedMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FlannBasedMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FlannBasedMatcher> _self_ = *(self1);

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::train(), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "FlannBasedMatcher", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_flannBasedMatcher_write(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::FlannBasedMatcher> * self1 = 0;
    if (!evision_FlannBasedMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::FlannBasedMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::FlannBasedMatcher> _self_ = *(self1);

    {
    String fileName;

    // const char* keywords[] = { "fileName", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fileName"), fileName, ArgInfo("fileName", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::write(fileName), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "FlannBasedMatcher", success);
        }
    }

    }
    

    {
    Ptr<FileStorage> fs;
    String name;

    // const char* keywords[] = { "fs", "name", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fs"), fs, ArgInfo("fs", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "name"), name, ArgInfo("name", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->DescriptorMatcher::write(fs, name), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "FlannBasedMatcher", success);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (FlannBasedMatcher)

template<>
struct Evision_Converter< Ptr<cv::FlannBasedMatcher> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::FlannBasedMatcher>& r)
    {
        return evision_FlannBasedMatcher_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::FlannBasedMatcher>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::FlannBasedMatcher> * dst_ = nullptr;
        if (evision_FlannBasedMatcher_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::FlannBasedMatcher> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// GFTTDetector (Generic)
//================================================================================

// GetSet (GFTTDetector)



// Methods (GFTTDetector)

static ERL_NIF_TERM evision_cv_gfttDetector_compute(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GFTTDetector> * self1 = 0;
    if (!evision_GFTTDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GFTTDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GFTTDetector> _self_ = *(self1);

    {
    Mat image;
    vector_KeyPoint keypoints;
    Mat descriptors;

    // const char* keywords[] = { "image", "keypoints", "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints"), keypoints, ArgInfo("keypoints", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute(image, keypoints, descriptors), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }
    

    {
    UMat image;
    vector_KeyPoint keypoints;
    UMat descriptors;

    // const char* keywords[] = { "image", "keypoints", "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints"), keypoints, ArgInfo("keypoints", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute(image, keypoints, descriptors), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }
    

    {
    vector_Mat images;
    vector_vector_KeyPoint keypoints;
    vector_Mat descriptors;

    // const char* keywords[] = { "images", "keypoints", "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints"), keypoints, ArgInfo("keypoints", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute(images, keypoints, descriptors), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }
    

    {
    vector_UMat images;
    vector_vector_KeyPoint keypoints;
    vector_UMat descriptors;

    // const char* keywords[] = { "images", "keypoints", "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints"), keypoints, ArgInfo("keypoints", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute(images, keypoints, descriptors), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_gfttDetector_create_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    {
    int maxCorners=1000;
    double qualityLevel=0.01;
    double minDistance=1;
    int blockSize=3;
    bool useHarrisDetector=false;
    double k=0.04;
    Ptr<GFTTDetector> retval;

    // const char* keywords[] = { "maxCorners", "qualityLevel", "minDistance", "blockSize", "useHarrisDetector", "k", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "maxCorners"), maxCorners, ArgInfo("maxCorners", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "qualityLevel"), qualityLevel, ArgInfo("qualityLevel", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minDistance"), minDistance, ArgInfo("minDistance", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "blockSize"), blockSize, ArgInfo("blockSize", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "useHarrisDetector"), useHarrisDetector, ArgInfo("useHarrisDetector", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), k, ArgInfo("k", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::GFTTDetector::create(maxCorners, qualityLevel, minDistance, blockSize, useHarrisDetector, k), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    int maxCorners=0;
    double qualityLevel=0;
    double minDistance=0;
    int blockSize=0;
    int gradiantSize=0;
    bool useHarrisDetector=false;
    double k=0.04;
    Ptr<GFTTDetector> retval;

    // const char* keywords[] = { "maxCorners", "qualityLevel", "minDistance", "blockSize", "gradiantSize", "useHarrisDetector", "k", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "maxCorners"), maxCorners, ArgInfo("maxCorners", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "qualityLevel"), qualityLevel, ArgInfo("qualityLevel", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minDistance"), minDistance, ArgInfo("minDistance", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "blockSize"), blockSize, ArgInfo("blockSize", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "gradiantSize"), gradiantSize, ArgInfo("gradiantSize", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "useHarrisDetector"), useHarrisDetector, ArgInfo("useHarrisDetector", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), k, ArgInfo("k", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::GFTTDetector::create(maxCorners, qualityLevel, minDistance, blockSize, gradiantSize, useHarrisDetector, k), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_gfttDetector_defaultNorm(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GFTTDetector> * self1 = 0;
    if (!evision_GFTTDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GFTTDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GFTTDetector> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->defaultNorm(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_gfttDetector_descriptorSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GFTTDetector> * self1 = 0;
    if (!evision_GFTTDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GFTTDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GFTTDetector> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->descriptorSize(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_gfttDetector_descriptorType(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GFTTDetector> * self1 = 0;
    if (!evision_GFTTDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GFTTDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GFTTDetector> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->descriptorType(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_gfttDetector_detect(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GFTTDetector> * self1 = 0;
    if (!evision_GFTTDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GFTTDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GFTTDetector> _self_ = *(self1);

    {
    Mat image;
    vector_KeyPoint keypoints;
    Mat mask;

    // const char* keywords[] = { "image", "mask", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(image, keypoints, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, keypoints);
        }
    }

    }
    

    {
    UMat image;
    vector_KeyPoint keypoints;
    UMat mask;

    // const char* keywords[] = { "image", "mask", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(image, keypoints, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, keypoints);
        }
    }

    }
    

    {
    vector_Mat images;
    vector_vector_KeyPoint keypoints;
    vector_Mat masks;

    // const char* keywords[] = { "images", "masks", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "masks"), masks, ArgInfo("masks", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(images, keypoints, masks), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, keypoints);
        }
    }

    }
    

    {
    vector_UMat images;
    vector_vector_KeyPoint keypoints;
    vector_UMat masks;

    // const char* keywords[] = { "images", "masks", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "masks"), masks, ArgInfo("masks", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(images, keypoints, masks), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, keypoints);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_gfttDetector_detectAndCompute(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GFTTDetector> * self1 = 0;
    if (!evision_GFTTDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GFTTDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GFTTDetector> _self_ = *(self1);

    {
    Mat image;
    Mat mask;
    vector_KeyPoint keypoints;
    Mat descriptors;
    bool useProvidedKeypoints=false;

    // const char* keywords[] = { "image", "mask", "descriptors", "useProvidedKeypoints", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "useProvidedKeypoints"), useProvidedKeypoints, ArgInfo("useProvidedKeypoints", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detectAndCompute(image, mask, keypoints, descriptors, useProvidedKeypoints), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }
    

    {
    UMat image;
    UMat mask;
    vector_KeyPoint keypoints;
    UMat descriptors;
    bool useProvidedKeypoints=false;

    // const char* keywords[] = { "image", "mask", "descriptors", "useProvidedKeypoints", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "useProvidedKeypoints"), useProvidedKeypoints, ArgInfo("useProvidedKeypoints", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detectAndCompute(image, mask, keypoints, descriptors, useProvidedKeypoints), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_gfttDetector_empty(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GFTTDetector> * self1 = 0;
    if (!evision_GFTTDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GFTTDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GFTTDetector> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->empty(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_gfttDetector_getBlockSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GFTTDetector> * self1 = 0;
    if (!evision_GFTTDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GFTTDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GFTTDetector> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getBlockSize(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_gfttDetector_getDefaultName(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GFTTDetector> * self1 = 0;
    if (!evision_GFTTDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GFTTDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GFTTDetector> _self_ = *(self1);
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getDefaultName(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_gfttDetector_getHarrisDetector(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GFTTDetector> * self1 = 0;
    if (!evision_GFTTDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GFTTDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GFTTDetector> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getHarrisDetector(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_gfttDetector_getK(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GFTTDetector> * self1 = 0;
    if (!evision_GFTTDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GFTTDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GFTTDetector> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getK(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_gfttDetector_getMaxFeatures(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GFTTDetector> * self1 = 0;
    if (!evision_GFTTDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GFTTDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GFTTDetector> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getMaxFeatures(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_gfttDetector_getMinDistance(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GFTTDetector> * self1 = 0;
    if (!evision_GFTTDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GFTTDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GFTTDetector> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getMinDistance(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_gfttDetector_getQualityLevel(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GFTTDetector> * self1 = 0;
    if (!evision_GFTTDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GFTTDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GFTTDetector> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getQualityLevel(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_gfttDetector_read(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GFTTDetector> * self1 = 0;
    if (!evision_GFTTDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GFTTDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GFTTDetector> _self_ = *(self1);

    {
    String fileName;

    // const char* keywords[] = { "fileName", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fileName"), fileName, ArgInfo("fileName", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->read(fileName), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "GFTTDetector", success);
        }
    }

    }
    

    {
    FileNode arg1;

    // const char* keywords[] = { "arg1", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "arg1"), arg1, ArgInfo("arg1", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->read(arg1), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "GFTTDetector", success);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_gfttDetector_setBlockSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GFTTDetector> * self1 = 0;
    if (!evision_GFTTDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GFTTDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GFTTDetector> _self_ = *(self1);
    int blockSize=0;

    // const char* keywords[] = { "blockSize", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "blockSize"), blockSize, ArgInfo("blockSize", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setBlockSize(blockSize), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "GFTTDetector", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_gfttDetector_setHarrisDetector(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GFTTDetector> * self1 = 0;
    if (!evision_GFTTDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GFTTDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GFTTDetector> _self_ = *(self1);
    bool val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setHarrisDetector(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "GFTTDetector", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_gfttDetector_setK(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GFTTDetector> * self1 = 0;
    if (!evision_GFTTDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GFTTDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GFTTDetector> _self_ = *(self1);
    double k=0;

    // const char* keywords[] = { "k", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), k, ArgInfo("k", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setK(k), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "GFTTDetector", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_gfttDetector_setMaxFeatures(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GFTTDetector> * self1 = 0;
    if (!evision_GFTTDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GFTTDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GFTTDetector> _self_ = *(self1);
    int maxFeatures=0;

    // const char* keywords[] = { "maxFeatures", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "maxFeatures"), maxFeatures, ArgInfo("maxFeatures", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setMaxFeatures(maxFeatures), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "GFTTDetector", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_gfttDetector_setMinDistance(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GFTTDetector> * self1 = 0;
    if (!evision_GFTTDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GFTTDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GFTTDetector> _self_ = *(self1);
    double minDistance=0;

    // const char* keywords[] = { "minDistance", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "minDistance"), minDistance, ArgInfo("minDistance", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setMinDistance(minDistance), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "GFTTDetector", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_gfttDetector_setQualityLevel(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GFTTDetector> * self1 = 0;
    if (!evision_GFTTDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GFTTDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GFTTDetector> _self_ = *(self1);
    double qlevel=0;

    // const char* keywords[] = { "qlevel", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "qlevel"), qlevel, ArgInfo("qlevel", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setQualityLevel(qlevel), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "GFTTDetector", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_gfttDetector_write(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GFTTDetector> * self1 = 0;
    if (!evision_GFTTDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GFTTDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GFTTDetector> _self_ = *(self1);

    {
    String fileName;

    // const char* keywords[] = { "fileName", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fileName"), fileName, ArgInfo("fileName", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->write(fileName), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "GFTTDetector", success);
        }
    }

    }
    

    {
    Ptr<FileStorage> fs;
    String name;

    // const char* keywords[] = { "fs", "name", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fs"), fs, ArgInfo("fs", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "name"), name, ArgInfo("name", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->write(fs, name), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "GFTTDetector", success);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (GFTTDetector)

template<>
struct Evision_Converter< Ptr<cv::GFTTDetector> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::GFTTDetector>& r)
    {
        return evision_GFTTDetector_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::GFTTDetector>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::GFTTDetector> * dst_ = nullptr;
        if (evision_GFTTDetector_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::GFTTDetector> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// GeneralizedHough (Generic)
//================================================================================

// GetSet (GeneralizedHough)



// Methods (GeneralizedHough)

static ERL_NIF_TERM evision_cv_generalizedHough_clear(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GeneralizedHough> * self1 = 0;
    if (!evision_GeneralizedHough_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GeneralizedHough>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GeneralizedHough> _self_ = *(self1);

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::clear(), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "GeneralizedHough", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_generalizedHough_detect(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GeneralizedHough> * self1 = 0;
    if (!evision_GeneralizedHough_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GeneralizedHough>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GeneralizedHough> _self_ = *(self1);

    {
    Mat image;
    Mat positions;
    Mat votes;

    // const char* keywords[] = { "image", "positions", "votes", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "positions"), positions, ArgInfo("positions", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "votes"), votes, ArgInfo("votes", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(image, positions, votes), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, positions), evision_from(env, votes));
        }
    }

    }
    

    {
    UMat image;
    UMat positions;
    UMat votes;

    // const char* keywords[] = { "image", "positions", "votes", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "positions"), positions, ArgInfo("positions", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "votes"), votes, ArgInfo("votes", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(image, positions, votes), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, positions), evision_from(env, votes));
        }
    }

    }
    

    {
    Mat edges;
    Mat dx;
    Mat dy;
    Mat positions;
    Mat votes;

    // const char* keywords[] = { "edges", "dx", "dy", "positions", "votes", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "edges"), edges, ArgInfo("edges", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dx"), dx, ArgInfo("dx", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dy"), dy, ArgInfo("dy", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "positions"), positions, ArgInfo("positions", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "votes"), votes, ArgInfo("votes", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(edges, dx, dy, positions, votes), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, positions), evision_from(env, votes));
        }
    }

    }
    

    {
    UMat edges;
    UMat dx;
    UMat dy;
    UMat positions;
    UMat votes;

    // const char* keywords[] = { "edges", "dx", "dy", "positions", "votes", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "edges"), edges, ArgInfo("edges", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dx"), dx, ArgInfo("dx", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dy"), dy, ArgInfo("dy", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "positions"), positions, ArgInfo("positions", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "votes"), votes, ArgInfo("votes", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(edges, dx, dy, positions, votes), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, positions), evision_from(env, votes));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_generalizedHough_empty(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GeneralizedHough> * self1 = 0;
    if (!evision_GeneralizedHough_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GeneralizedHough>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GeneralizedHough> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->Algorithm::empty(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_generalizedHough_getCannyHighThresh(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GeneralizedHough> * self1 = 0;
    if (!evision_GeneralizedHough_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GeneralizedHough>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GeneralizedHough> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getCannyHighThresh(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_generalizedHough_getCannyLowThresh(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GeneralizedHough> * self1 = 0;
    if (!evision_GeneralizedHough_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GeneralizedHough>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GeneralizedHough> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getCannyLowThresh(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_generalizedHough_getDefaultName(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GeneralizedHough> * self1 = 0;
    if (!evision_GeneralizedHough_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GeneralizedHough>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GeneralizedHough> _self_ = *(self1);
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->Algorithm::getDefaultName(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_generalizedHough_getDp(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GeneralizedHough> * self1 = 0;
    if (!evision_GeneralizedHough_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GeneralizedHough>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GeneralizedHough> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getDp(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_generalizedHough_getMaxBufferSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GeneralizedHough> * self1 = 0;
    if (!evision_GeneralizedHough_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GeneralizedHough>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GeneralizedHough> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getMaxBufferSize(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_generalizedHough_getMinDist(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GeneralizedHough> * self1 = 0;
    if (!evision_GeneralizedHough_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GeneralizedHough>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GeneralizedHough> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getMinDist(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_generalizedHough_read(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GeneralizedHough> * self1 = 0;
    if (!evision_GeneralizedHough_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GeneralizedHough>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GeneralizedHough> _self_ = *(self1);
    FileNode fn_;

    // const char* keywords[] = { "fn_", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fn_"), fn_, ArgInfo("fn_", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::read(fn_), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "GeneralizedHough", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_generalizedHough_save(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GeneralizedHough> * self1 = 0;
    if (!evision_GeneralizedHough_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GeneralizedHough>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GeneralizedHough> _self_ = *(self1);
    String filename;

    // const char* keywords[] = { "filename", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::save(filename), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "GeneralizedHough", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_generalizedHough_setCannyHighThresh(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GeneralizedHough> * self1 = 0;
    if (!evision_GeneralizedHough_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GeneralizedHough>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GeneralizedHough> _self_ = *(self1);
    int cannyHighThresh=0;

    // const char* keywords[] = { "cannyHighThresh", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "cannyHighThresh"), cannyHighThresh, ArgInfo("cannyHighThresh", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setCannyHighThresh(cannyHighThresh), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "GeneralizedHough", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_generalizedHough_setCannyLowThresh(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GeneralizedHough> * self1 = 0;
    if (!evision_GeneralizedHough_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GeneralizedHough>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GeneralizedHough> _self_ = *(self1);
    int cannyLowThresh=0;

    // const char* keywords[] = { "cannyLowThresh", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "cannyLowThresh"), cannyLowThresh, ArgInfo("cannyLowThresh", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setCannyLowThresh(cannyLowThresh), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "GeneralizedHough", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_generalizedHough_setDp(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GeneralizedHough> * self1 = 0;
    if (!evision_GeneralizedHough_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GeneralizedHough>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GeneralizedHough> _self_ = *(self1);
    double dp=0;

    // const char* keywords[] = { "dp", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "dp"), dp, ArgInfo("dp", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setDp(dp), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "GeneralizedHough", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_generalizedHough_setMaxBufferSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GeneralizedHough> * self1 = 0;
    if (!evision_GeneralizedHough_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GeneralizedHough>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GeneralizedHough> _self_ = *(self1);
    int maxBufferSize=0;

    // const char* keywords[] = { "maxBufferSize", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "maxBufferSize"), maxBufferSize, ArgInfo("maxBufferSize", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setMaxBufferSize(maxBufferSize), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "GeneralizedHough", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_generalizedHough_setMinDist(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GeneralizedHough> * self1 = 0;
    if (!evision_GeneralizedHough_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GeneralizedHough>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GeneralizedHough> _self_ = *(self1);
    double minDist=0;

    // const char* keywords[] = { "minDist", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "minDist"), minDist, ArgInfo("minDist", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setMinDist(minDist), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "GeneralizedHough", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_generalizedHough_setTemplate(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GeneralizedHough> * self1 = 0;
    if (!evision_GeneralizedHough_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GeneralizedHough>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GeneralizedHough> _self_ = *(self1);

    {
    Mat templ;
    Point templCenter=Point(-1, -1);

    // const char* keywords[] = { "templ", "templCenter", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "templ"), templ, ArgInfo("templ", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "templCenter"), templCenter, ArgInfo("templCenter", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setTemplate(templ, templCenter), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "GeneralizedHough", success);
        }
    }

    }
    

    {
    UMat templ;
    Point templCenter=Point(-1, -1);

    // const char* keywords[] = { "templ", "templCenter", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "templ"), templ, ArgInfo("templ", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "templCenter"), templCenter, ArgInfo("templCenter", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setTemplate(templ, templCenter), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "GeneralizedHough", success);
        }
    }

    }
    

    {
    Mat edges;
    Mat dx;
    Mat dy;
    Point templCenter=Point(-1, -1);

    // const char* keywords[] = { "edges", "dx", "dy", "templCenter", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "edges"), edges, ArgInfo("edges", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dx"), dx, ArgInfo("dx", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dy"), dy, ArgInfo("dy", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "templCenter"), templCenter, ArgInfo("templCenter", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setTemplate(edges, dx, dy, templCenter), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "GeneralizedHough", success);
        }
    }

    }
    

    {
    UMat edges;
    UMat dx;
    UMat dy;
    Point templCenter=Point(-1, -1);

    // const char* keywords[] = { "edges", "dx", "dy", "templCenter", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "edges"), edges, ArgInfo("edges", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dx"), dx, ArgInfo("dx", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dy"), dy, ArgInfo("dy", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "templCenter"), templCenter, ArgInfo("templCenter", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setTemplate(edges, dx, dy, templCenter), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "GeneralizedHough", success);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_generalizedHough_write(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GeneralizedHough> * self1 = 0;
    if (!evision_GeneralizedHough_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GeneralizedHough>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GeneralizedHough> _self_ = *(self1);
    Ptr<FileStorage> fs;
    String name;

    // const char* keywords[] = { "fs", "name", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fs"), fs, ArgInfo("fs", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "name"), name, ArgInfo("name", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::write(fs, name), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "GeneralizedHough", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (GeneralizedHough)

template<>
struct Evision_Converter< Ptr<cv::GeneralizedHough> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::GeneralizedHough>& r)
    {
        return evision_GeneralizedHough_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::GeneralizedHough>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::GeneralizedHough> * dst_ = nullptr;
        if (evision_GeneralizedHough_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::GeneralizedHough> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// GeneralizedHoughBallard (Generic)
//================================================================================

// GetSet (GeneralizedHoughBallard)



// Methods (GeneralizedHoughBallard)

static ERL_NIF_TERM evision_cv_generalizedHoughBallard_getLevels(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GeneralizedHoughBallard> * self1 = 0;
    if (!evision_GeneralizedHoughBallard_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GeneralizedHoughBallard>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GeneralizedHoughBallard> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getLevels(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_generalizedHoughBallard_getVotesThreshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GeneralizedHoughBallard> * self1 = 0;
    if (!evision_GeneralizedHoughBallard_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GeneralizedHoughBallard>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GeneralizedHoughBallard> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getVotesThreshold(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_generalizedHoughBallard_setLevels(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GeneralizedHoughBallard> * self1 = 0;
    if (!evision_GeneralizedHoughBallard_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GeneralizedHoughBallard>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GeneralizedHoughBallard> _self_ = *(self1);
    int levels=0;

    // const char* keywords[] = { "levels", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "levels"), levels, ArgInfo("levels", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setLevels(levels), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "GeneralizedHoughBallard", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_generalizedHoughBallard_setVotesThreshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GeneralizedHoughBallard> * self1 = 0;
    if (!evision_GeneralizedHoughBallard_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GeneralizedHoughBallard>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GeneralizedHoughBallard> _self_ = *(self1);
    int votesThreshold=0;

    // const char* keywords[] = { "votesThreshold", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "votesThreshold"), votesThreshold, ArgInfo("votesThreshold", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setVotesThreshold(votesThreshold), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "GeneralizedHoughBallard", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (GeneralizedHoughBallard)

template<>
struct Evision_Converter< Ptr<cv::GeneralizedHoughBallard> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::GeneralizedHoughBallard>& r)
    {
        return evision_GeneralizedHoughBallard_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::GeneralizedHoughBallard>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::GeneralizedHoughBallard> * dst_ = nullptr;
        if (evision_GeneralizedHoughBallard_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::GeneralizedHoughBallard> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// GeneralizedHoughGuil (Generic)
//================================================================================

// GetSet (GeneralizedHoughGuil)



// Methods (GeneralizedHoughGuil)

static ERL_NIF_TERM evision_cv_generalizedHoughGuil_getAngleEpsilon(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GeneralizedHoughGuil> * self1 = 0;
    if (!evision_GeneralizedHoughGuil_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GeneralizedHoughGuil>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GeneralizedHoughGuil> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getAngleEpsilon(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_generalizedHoughGuil_getAngleStep(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GeneralizedHoughGuil> * self1 = 0;
    if (!evision_GeneralizedHoughGuil_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GeneralizedHoughGuil>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GeneralizedHoughGuil> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getAngleStep(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_generalizedHoughGuil_getAngleThresh(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GeneralizedHoughGuil> * self1 = 0;
    if (!evision_GeneralizedHoughGuil_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GeneralizedHoughGuil>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GeneralizedHoughGuil> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getAngleThresh(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_generalizedHoughGuil_getLevels(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GeneralizedHoughGuil> * self1 = 0;
    if (!evision_GeneralizedHoughGuil_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GeneralizedHoughGuil>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GeneralizedHoughGuil> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getLevels(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_generalizedHoughGuil_getMaxAngle(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GeneralizedHoughGuil> * self1 = 0;
    if (!evision_GeneralizedHoughGuil_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GeneralizedHoughGuil>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GeneralizedHoughGuil> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getMaxAngle(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_generalizedHoughGuil_getMaxScale(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GeneralizedHoughGuil> * self1 = 0;
    if (!evision_GeneralizedHoughGuil_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GeneralizedHoughGuil>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GeneralizedHoughGuil> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getMaxScale(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_generalizedHoughGuil_getMinAngle(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GeneralizedHoughGuil> * self1 = 0;
    if (!evision_GeneralizedHoughGuil_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GeneralizedHoughGuil>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GeneralizedHoughGuil> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getMinAngle(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_generalizedHoughGuil_getMinScale(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GeneralizedHoughGuil> * self1 = 0;
    if (!evision_GeneralizedHoughGuil_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GeneralizedHoughGuil>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GeneralizedHoughGuil> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getMinScale(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_generalizedHoughGuil_getPosThresh(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GeneralizedHoughGuil> * self1 = 0;
    if (!evision_GeneralizedHoughGuil_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GeneralizedHoughGuil>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GeneralizedHoughGuil> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getPosThresh(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_generalizedHoughGuil_getScaleStep(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GeneralizedHoughGuil> * self1 = 0;
    if (!evision_GeneralizedHoughGuil_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GeneralizedHoughGuil>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GeneralizedHoughGuil> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getScaleStep(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_generalizedHoughGuil_getScaleThresh(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GeneralizedHoughGuil> * self1 = 0;
    if (!evision_GeneralizedHoughGuil_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GeneralizedHoughGuil>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GeneralizedHoughGuil> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getScaleThresh(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_generalizedHoughGuil_getXi(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GeneralizedHoughGuil> * self1 = 0;
    if (!evision_GeneralizedHoughGuil_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GeneralizedHoughGuil>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GeneralizedHoughGuil> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getXi(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_generalizedHoughGuil_setAngleEpsilon(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GeneralizedHoughGuil> * self1 = 0;
    if (!evision_GeneralizedHoughGuil_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GeneralizedHoughGuil>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GeneralizedHoughGuil> _self_ = *(self1);
    double angleEpsilon=0;

    // const char* keywords[] = { "angleEpsilon", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "angleEpsilon"), angleEpsilon, ArgInfo("angleEpsilon", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setAngleEpsilon(angleEpsilon), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "GeneralizedHoughGuil", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_generalizedHoughGuil_setAngleStep(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GeneralizedHoughGuil> * self1 = 0;
    if (!evision_GeneralizedHoughGuil_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GeneralizedHoughGuil>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GeneralizedHoughGuil> _self_ = *(self1);
    double angleStep=0;

    // const char* keywords[] = { "angleStep", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "angleStep"), angleStep, ArgInfo("angleStep", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setAngleStep(angleStep), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "GeneralizedHoughGuil", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_generalizedHoughGuil_setAngleThresh(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GeneralizedHoughGuil> * self1 = 0;
    if (!evision_GeneralizedHoughGuil_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GeneralizedHoughGuil>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GeneralizedHoughGuil> _self_ = *(self1);
    int angleThresh=0;

    // const char* keywords[] = { "angleThresh", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "angleThresh"), angleThresh, ArgInfo("angleThresh", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setAngleThresh(angleThresh), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "GeneralizedHoughGuil", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_generalizedHoughGuil_setLevels(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GeneralizedHoughGuil> * self1 = 0;
    if (!evision_GeneralizedHoughGuil_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GeneralizedHoughGuil>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GeneralizedHoughGuil> _self_ = *(self1);
    int levels=0;

    // const char* keywords[] = { "levels", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "levels"), levels, ArgInfo("levels", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setLevels(levels), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "GeneralizedHoughGuil", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_generalizedHoughGuil_setMaxAngle(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GeneralizedHoughGuil> * self1 = 0;
    if (!evision_GeneralizedHoughGuil_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GeneralizedHoughGuil>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GeneralizedHoughGuil> _self_ = *(self1);
    double maxAngle=0;

    // const char* keywords[] = { "maxAngle", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "maxAngle"), maxAngle, ArgInfo("maxAngle", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setMaxAngle(maxAngle), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "GeneralizedHoughGuil", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_generalizedHoughGuil_setMaxScale(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GeneralizedHoughGuil> * self1 = 0;
    if (!evision_GeneralizedHoughGuil_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GeneralizedHoughGuil>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GeneralizedHoughGuil> _self_ = *(self1);
    double maxScale=0;

    // const char* keywords[] = { "maxScale", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "maxScale"), maxScale, ArgInfo("maxScale", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setMaxScale(maxScale), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "GeneralizedHoughGuil", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_generalizedHoughGuil_setMinAngle(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GeneralizedHoughGuil> * self1 = 0;
    if (!evision_GeneralizedHoughGuil_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GeneralizedHoughGuil>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GeneralizedHoughGuil> _self_ = *(self1);
    double minAngle=0;

    // const char* keywords[] = { "minAngle", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "minAngle"), minAngle, ArgInfo("minAngle", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setMinAngle(minAngle), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "GeneralizedHoughGuil", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_generalizedHoughGuil_setMinScale(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GeneralizedHoughGuil> * self1 = 0;
    if (!evision_GeneralizedHoughGuil_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GeneralizedHoughGuil>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GeneralizedHoughGuil> _self_ = *(self1);
    double minScale=0;

    // const char* keywords[] = { "minScale", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "minScale"), minScale, ArgInfo("minScale", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setMinScale(minScale), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "GeneralizedHoughGuil", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_generalizedHoughGuil_setPosThresh(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GeneralizedHoughGuil> * self1 = 0;
    if (!evision_GeneralizedHoughGuil_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GeneralizedHoughGuil>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GeneralizedHoughGuil> _self_ = *(self1);
    int posThresh=0;

    // const char* keywords[] = { "posThresh", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "posThresh"), posThresh, ArgInfo("posThresh", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setPosThresh(posThresh), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "GeneralizedHoughGuil", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_generalizedHoughGuil_setScaleStep(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GeneralizedHoughGuil> * self1 = 0;
    if (!evision_GeneralizedHoughGuil_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GeneralizedHoughGuil>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GeneralizedHoughGuil> _self_ = *(self1);
    double scaleStep=0;

    // const char* keywords[] = { "scaleStep", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "scaleStep"), scaleStep, ArgInfo("scaleStep", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setScaleStep(scaleStep), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "GeneralizedHoughGuil", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_generalizedHoughGuil_setScaleThresh(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GeneralizedHoughGuil> * self1 = 0;
    if (!evision_GeneralizedHoughGuil_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GeneralizedHoughGuil>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GeneralizedHoughGuil> _self_ = *(self1);
    int scaleThresh=0;

    // const char* keywords[] = { "scaleThresh", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "scaleThresh"), scaleThresh, ArgInfo("scaleThresh", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setScaleThresh(scaleThresh), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "GeneralizedHoughGuil", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_generalizedHoughGuil_setXi(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::GeneralizedHoughGuil> * self1 = 0;
    if (!evision_GeneralizedHoughGuil_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::GeneralizedHoughGuil>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::GeneralizedHoughGuil> _self_ = *(self1);
    double xi=0;

    // const char* keywords[] = { "xi", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "xi"), xi, ArgInfo("xi", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setXi(xi), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "GeneralizedHoughGuil", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (GeneralizedHoughGuil)

template<>
struct Evision_Converter< Ptr<cv::GeneralizedHoughGuil> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::GeneralizedHoughGuil>& r)
    {
        return evision_GeneralizedHoughGuil_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::GeneralizedHoughGuil>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::GeneralizedHoughGuil> * dst_ = nullptr;
        if (evision_GeneralizedHoughGuil_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::GeneralizedHoughGuil> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// HOGDescriptor (Generic)
//================================================================================

// GetSet (HOGDescriptor)


static ERL_NIF_TERM evision_HOGDescriptor_get_L2HysThreshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    Ptr<cv::HOGDescriptor>* self_ptr = 0;
    if (!evision_HOGDescriptor_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `Ptr<cv::HOGDescriptor>` from `self`: mismatched type or invalid resource?");
    }

    Ptr<cv::HOGDescriptor> &self2 = *self_ptr;
    cv::HOGDescriptor* _self_ = dynamic_cast<cv::HOGDescriptor*>(self2.get());
    return evision_from(env, _self_->L2HysThreshold);
}

static ERL_NIF_TERM evision_HOGDescriptor_get_blockSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    Ptr<cv::HOGDescriptor>* self_ptr = 0;
    if (!evision_HOGDescriptor_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `Ptr<cv::HOGDescriptor>` from `self`: mismatched type or invalid resource?");
    }

    Ptr<cv::HOGDescriptor> &self2 = *self_ptr;
    cv::HOGDescriptor* _self_ = dynamic_cast<cv::HOGDescriptor*>(self2.get());
    return evision_from(env, _self_->blockSize);
}

static ERL_NIF_TERM evision_HOGDescriptor_get_blockStride(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    Ptr<cv::HOGDescriptor>* self_ptr = 0;
    if (!evision_HOGDescriptor_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `Ptr<cv::HOGDescriptor>` from `self`: mismatched type or invalid resource?");
    }

    Ptr<cv::HOGDescriptor> &self2 = *self_ptr;
    cv::HOGDescriptor* _self_ = dynamic_cast<cv::HOGDescriptor*>(self2.get());
    return evision_from(env, _self_->blockStride);
}

static ERL_NIF_TERM evision_HOGDescriptor_get_cellSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    Ptr<cv::HOGDescriptor>* self_ptr = 0;
    if (!evision_HOGDescriptor_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `Ptr<cv::HOGDescriptor>` from `self`: mismatched type or invalid resource?");
    }

    Ptr<cv::HOGDescriptor> &self2 = *self_ptr;
    cv::HOGDescriptor* _self_ = dynamic_cast<cv::HOGDescriptor*>(self2.get());
    return evision_from(env, _self_->cellSize);
}

static ERL_NIF_TERM evision_HOGDescriptor_get_derivAperture(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    Ptr<cv::HOGDescriptor>* self_ptr = 0;
    if (!evision_HOGDescriptor_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `Ptr<cv::HOGDescriptor>` from `self`: mismatched type or invalid resource?");
    }

    Ptr<cv::HOGDescriptor> &self2 = *self_ptr;
    cv::HOGDescriptor* _self_ = dynamic_cast<cv::HOGDescriptor*>(self2.get());
    return evision_from(env, _self_->derivAperture);
}

static ERL_NIF_TERM evision_HOGDescriptor_get_gammaCorrection(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    Ptr<cv::HOGDescriptor>* self_ptr = 0;
    if (!evision_HOGDescriptor_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `Ptr<cv::HOGDescriptor>` from `self`: mismatched type or invalid resource?");
    }

    Ptr<cv::HOGDescriptor> &self2 = *self_ptr;
    cv::HOGDescriptor* _self_ = dynamic_cast<cv::HOGDescriptor*>(self2.get());
    return evision_from(env, _self_->gammaCorrection);
}

static ERL_NIF_TERM evision_HOGDescriptor_get_histogramNormType(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    Ptr<cv::HOGDescriptor>* self_ptr = 0;
    if (!evision_HOGDescriptor_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `Ptr<cv::HOGDescriptor>` from `self`: mismatched type or invalid resource?");
    }

    Ptr<cv::HOGDescriptor> &self2 = *self_ptr;
    cv::HOGDescriptor* _self_ = dynamic_cast<cv::HOGDescriptor*>(self2.get());
    return evision_from(env, _self_->histogramNormType);
}

static ERL_NIF_TERM evision_HOGDescriptor_get_nbins(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    Ptr<cv::HOGDescriptor>* self_ptr = 0;
    if (!evision_HOGDescriptor_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `Ptr<cv::HOGDescriptor>` from `self`: mismatched type or invalid resource?");
    }

    Ptr<cv::HOGDescriptor> &self2 = *self_ptr;
    cv::HOGDescriptor* _self_ = dynamic_cast<cv::HOGDescriptor*>(self2.get());
    return evision_from(env, _self_->nbins);
}

static ERL_NIF_TERM evision_HOGDescriptor_get_nlevels(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    Ptr<cv::HOGDescriptor>* self_ptr = 0;
    if (!evision_HOGDescriptor_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `Ptr<cv::HOGDescriptor>` from `self`: mismatched type or invalid resource?");
    }

    Ptr<cv::HOGDescriptor> &self2 = *self_ptr;
    cv::HOGDescriptor* _self_ = dynamic_cast<cv::HOGDescriptor*>(self2.get());
    return evision_from(env, _self_->nlevels);
}

static ERL_NIF_TERM evision_HOGDescriptor_get_signedGradient(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    Ptr<cv::HOGDescriptor>* self_ptr = 0;
    if (!evision_HOGDescriptor_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `Ptr<cv::HOGDescriptor>` from `self`: mismatched type or invalid resource?");
    }

    Ptr<cv::HOGDescriptor> &self2 = *self_ptr;
    cv::HOGDescriptor* _self_ = dynamic_cast<cv::HOGDescriptor*>(self2.get());
    return evision_from(env, _self_->signedGradient);
}

static ERL_NIF_TERM evision_HOGDescriptor_get_svmDetector(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    Ptr<cv::HOGDescriptor>* self_ptr = 0;
    if (!evision_HOGDescriptor_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `Ptr<cv::HOGDescriptor>` from `self`: mismatched type or invalid resource?");
    }

    Ptr<cv::HOGDescriptor> &self2 = *self_ptr;
    cv::HOGDescriptor* _self_ = dynamic_cast<cv::HOGDescriptor*>(self2.get());
    return evision_from(env, _self_->svmDetector);
}

static ERL_NIF_TERM evision_HOGDescriptor_get_winSigma(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    Ptr<cv::HOGDescriptor>* self_ptr = 0;
    if (!evision_HOGDescriptor_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `Ptr<cv::HOGDescriptor>` from `self`: mismatched type or invalid resource?");
    }

    Ptr<cv::HOGDescriptor> &self2 = *self_ptr;
    cv::HOGDescriptor* _self_ = dynamic_cast<cv::HOGDescriptor*>(self2.get());
    return evision_from(env, _self_->winSigma);
}

static ERL_NIF_TERM evision_HOGDescriptor_get_winSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    Ptr<cv::HOGDescriptor>* self_ptr = 0;
    if (!evision_HOGDescriptor_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `Ptr<cv::HOGDescriptor>` from `self`: mismatched type or invalid resource?");
    }

    Ptr<cv::HOGDescriptor> &self2 = *self_ptr;
    cv::HOGDescriptor* _self_ = dynamic_cast<cv::HOGDescriptor*>(self2.get());
    return evision_from(env, _self_->winSize);
}


// Methods (HOGDescriptor)

static ERL_NIF_TERM evision_cv_hogDescriptor_HOGDescriptor(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    {

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        evision_res<Ptr<cv::HOGDescriptor>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::HOGDescriptor>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::HOGDescriptor()), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::HOGDescriptor>>(env, self->val, ret, "HOGDescriptor", success);;
        }
    }

    }
    

    {
    Size _winSize;
    Size _blockSize;
    Size _blockStride;
    Size _cellSize;
    int _nbins=0;
    int _derivAperture=1;
    double _winSigma=-1;
    std::underlying_type_t<HOGDescriptor_HistogramNormType> _histogramNormType=static_cast<std::underlying_type_t<HOGDescriptor_HistogramNormType>>(HOGDescriptor::L2Hys);
    double _L2HysThreshold=0.2;
    bool _gammaCorrection=false;
    int _nlevels=HOGDescriptor::DEFAULT_NLEVELS;
    bool _signedGradient=false;

    // const char* keywords[] = { "_winSize", "_blockSize", "_blockStride", "_cellSize", "_nbins", "_derivAperture", "_winSigma", "_histogramNormType", "_L2HysThreshold", "_gammaCorrection", "_nlevels", "_signedGradient", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "winSize"), _winSize, ArgInfo("_winSize", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "blockSize"), _blockSize, ArgInfo("_blockSize", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "blockStride"), _blockStride, ArgInfo("_blockStride", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cellSize"), _cellSize, ArgInfo("_cellSize", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nbins"), _nbins, ArgInfo("_nbins", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "derivAperture"), _derivAperture, ArgInfo("_derivAperture", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "winSigma"), _winSigma, ArgInfo("_winSigma", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "histogramNormType"), _histogramNormType, ArgInfo("_histogramNormType", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "l2HysThreshold"), _L2HysThreshold, ArgInfo("_L2HysThreshold", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "gammaCorrection"), _gammaCorrection, ArgInfo("_gammaCorrection", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nlevels"), _nlevels, ArgInfo("_nlevels", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "signedGradient"), _signedGradient, ArgInfo("_signedGradient", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::HOGDescriptor>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::HOGDescriptor>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::HOGDescriptor(_winSize, _blockSize, _blockStride, _cellSize, _nbins, _derivAperture, _winSigma, static_cast<HOGDescriptor_HistogramNormType>(_histogramNormType), _L2HysThreshold, _gammaCorrection, _nlevels, _signedGradient)), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::HOGDescriptor>>(env, self->val, ret, "HOGDescriptor", success);;
        }
    }

    }
    

    {
    String filename;

    // const char* keywords[] = { "filename", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::HOGDescriptor>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::HOGDescriptor>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::HOGDescriptor(filename)), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::HOGDescriptor>>(env, self->val, ret, "HOGDescriptor", success);;
        }
    }

    }

    return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_hogDescriptor_checkDetectorSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::HOGDescriptor> * self1 = 0;
    if (!evision_HOGDescriptor_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::HOGDescriptor>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::HOGDescriptor> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->checkDetectorSize(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_hogDescriptor_compute(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::HOGDescriptor> * self1 = 0;
    if (!evision_HOGDescriptor_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::HOGDescriptor>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::HOGDescriptor> _self_ = *(self1);

    {
    Mat img;
    vector_float descriptors;
    Size winStride;
    Size padding;
    vector_Point locations=std::vector<Point>();

    // const char* keywords[] = { "img", "winStride", "padding", "locations", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "winStride"), winStride, ArgInfo("winStride", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "padding"), padding, ArgInfo("padding", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "locations"), locations, ArgInfo("locations", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute(img, descriptors, winStride, padding, locations), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, descriptors);
        }
    }

    }
    

    {
    UMat img;
    vector_float descriptors;
    Size winStride;
    Size padding;
    vector_Point locations=std::vector<Point>();

    // const char* keywords[] = { "img", "winStride", "padding", "locations", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "winStride"), winStride, ArgInfo("winStride", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "padding"), padding, ArgInfo("padding", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "locations"), locations, ArgInfo("locations", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute(img, descriptors, winStride, padding, locations), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, descriptors);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_hogDescriptor_computeGradient(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::HOGDescriptor> * self1 = 0;
    if (!evision_HOGDescriptor_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::HOGDescriptor>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::HOGDescriptor> _self_ = *(self1);

    {
    Mat img;
    Mat grad;
    Mat angleOfs;
    Size paddingTL;
    Size paddingBR;

    // const char* keywords[] = { "img", "grad", "angleOfs", "paddingTL", "paddingBR", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "grad"), grad, ArgInfo("grad", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "angleOfs"), angleOfs, ArgInfo("angleOfs", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "paddingTL"), paddingTL, ArgInfo("paddingTL", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "paddingBR"), paddingBR, ArgInfo("paddingBR", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->computeGradient(img, grad, angleOfs, paddingTL, paddingBR), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, grad), evision_from(env, angleOfs));
        }
    }

    }
    

    {
    UMat img;
    UMat grad;
    UMat angleOfs;
    Size paddingTL;
    Size paddingBR;

    // const char* keywords[] = { "img", "grad", "angleOfs", "paddingTL", "paddingBR", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "grad"), grad, ArgInfo("grad", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "angleOfs"), angleOfs, ArgInfo("angleOfs", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "paddingTL"), paddingTL, ArgInfo("paddingTL", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "paddingBR"), paddingBR, ArgInfo("paddingBR", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->computeGradient(img, grad, angleOfs, paddingTL, paddingBR), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, grad), evision_from(env, angleOfs));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_hogDescriptor_detect(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::HOGDescriptor> * self1 = 0;
    if (!evision_HOGDescriptor_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::HOGDescriptor>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::HOGDescriptor> _self_ = *(self1);

    {
    Mat img;
    vector_Point foundLocations;
    vector_double weights;
    double hitThreshold=0;
    Size winStride;
    Size padding;
    vector_Point searchLocations=std::vector<Point>();

    // const char* keywords[] = { "img", "hitThreshold", "winStride", "padding", "searchLocations", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "hitThreshold"), hitThreshold, ArgInfo("hitThreshold", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "winStride"), winStride, ArgInfo("winStride", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "padding"), padding, ArgInfo("padding", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "searchLocations"), searchLocations, ArgInfo("searchLocations", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(img, foundLocations, weights, hitThreshold, winStride, padding, searchLocations), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, foundLocations), evision_from(env, weights));
        }
    }

    }
    

    {
    UMat img;
    vector_Point foundLocations;
    vector_double weights;
    double hitThreshold=0;
    Size winStride;
    Size padding;
    vector_Point searchLocations=std::vector<Point>();

    // const char* keywords[] = { "img", "hitThreshold", "winStride", "padding", "searchLocations", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "hitThreshold"), hitThreshold, ArgInfo("hitThreshold", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "winStride"), winStride, ArgInfo("winStride", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "padding"), padding, ArgInfo("padding", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "searchLocations"), searchLocations, ArgInfo("searchLocations", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(img, foundLocations, weights, hitThreshold, winStride, padding, searchLocations), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, foundLocations), evision_from(env, weights));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_hogDescriptor_detectMultiScale(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::HOGDescriptor> * self1 = 0;
    if (!evision_HOGDescriptor_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::HOGDescriptor>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::HOGDescriptor> _self_ = *(self1);

    {
    Mat img;
    vector_Rect foundLocations;
    vector_double foundWeights;
    double hitThreshold=0;
    Size winStride;
    Size padding;
    double scale=1.05;
    double groupThreshold=2.0;
    bool useMeanshiftGrouping=false;

    // const char* keywords[] = { "img", "hitThreshold", "winStride", "padding", "scale", "groupThreshold", "useMeanshiftGrouping", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "hitThreshold"), hitThreshold, ArgInfo("hitThreshold", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "winStride"), winStride, ArgInfo("winStride", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "padding"), padding, ArgInfo("padding", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scale"), scale, ArgInfo("scale", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "groupThreshold"), groupThreshold, ArgInfo("groupThreshold", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "useMeanshiftGrouping"), useMeanshiftGrouping, ArgInfo("useMeanshiftGrouping", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detectMultiScale(img, foundLocations, foundWeights, hitThreshold, winStride, padding, scale, groupThreshold, useMeanshiftGrouping), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, foundLocations), evision_from(env, foundWeights));
        }
    }

    }
    

    {
    UMat img;
    vector_Rect foundLocations;
    vector_double foundWeights;
    double hitThreshold=0;
    Size winStride;
    Size padding;
    double scale=1.05;
    double groupThreshold=2.0;
    bool useMeanshiftGrouping=false;

    // const char* keywords[] = { "img", "hitThreshold", "winStride", "padding", "scale", "groupThreshold", "useMeanshiftGrouping", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "hitThreshold"), hitThreshold, ArgInfo("hitThreshold", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "winStride"), winStride, ArgInfo("winStride", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "padding"), padding, ArgInfo("padding", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scale"), scale, ArgInfo("scale", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "groupThreshold"), groupThreshold, ArgInfo("groupThreshold", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "useMeanshiftGrouping"), useMeanshiftGrouping, ArgInfo("useMeanshiftGrouping", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detectMultiScale(img, foundLocations, foundWeights, hitThreshold, winStride, padding, scale, groupThreshold, useMeanshiftGrouping), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, foundLocations), evision_from(env, foundWeights));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_hogDescriptor_getDaimlerPeopleDetector_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    std::vector<float> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::HOGDescriptor::getDaimlerPeopleDetector(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_hogDescriptor_getDefaultPeopleDetector_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    std::vector<float> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::HOGDescriptor::getDefaultPeopleDetector(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_hogDescriptor_getDescriptorSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::HOGDescriptor> * self1 = 0;
    if (!evision_HOGDescriptor_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::HOGDescriptor>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::HOGDescriptor> _self_ = *(self1);
    size_t retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getDescriptorSize(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_hogDescriptor_getWinSigma(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::HOGDescriptor> * self1 = 0;
    if (!evision_HOGDescriptor_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::HOGDescriptor>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::HOGDescriptor> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getWinSigma(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_hogDescriptor_load(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::HOGDescriptor> * self1 = 0;
    if (!evision_HOGDescriptor_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::HOGDescriptor>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::HOGDescriptor> _self_ = *(self1);
    String filename;
    String objname;
    bool retval;

    // const char* keywords[] = { "filename", "objname", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "objname"), objname, ArgInfo("objname", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->load(filename, objname), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_hogDescriptor_save(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::HOGDescriptor> * self1 = 0;
    if (!evision_HOGDescriptor_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::HOGDescriptor>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::HOGDescriptor> _self_ = *(self1);
    String filename;
    String objname;

    // const char* keywords[] = { "filename", "objname", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "objname"), objname, ArgInfo("objname", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->save(filename, objname), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "HOGDescriptor", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_hogDescriptor_setSVMDetector(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::HOGDescriptor> * self1 = 0;
    if (!evision_HOGDescriptor_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::HOGDescriptor>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::HOGDescriptor> _self_ = *(self1);

    {
    Mat svmdetector;

    // const char* keywords[] = { "svmdetector", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "svmdetector"), svmdetector, ArgInfo("svmdetector", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setSVMDetector(svmdetector), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "HOGDescriptor", success);
        }
    }

    }
    

    {
    UMat svmdetector;

    // const char* keywords[] = { "svmdetector", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "svmdetector"), svmdetector, ArgInfo("svmdetector", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setSVMDetector(svmdetector), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "HOGDescriptor", success);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (HOGDescriptor)

template<>
struct Evision_Converter< Ptr<cv::HOGDescriptor> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::HOGDescriptor>& r)
    {
        return evision_HOGDescriptor_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::HOGDescriptor>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::HOGDescriptor> * dst_ = nullptr;
        if (evision_HOGDescriptor_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::HOGDescriptor> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// KAZE (Generic)
//================================================================================

// GetSet (KAZE)



// Methods (KAZE)

static ERL_NIF_TERM evision_cv_kaze_compute(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::KAZE> * self1 = 0;
    if (!evision_KAZE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::KAZE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::KAZE> _self_ = *(self1);

    {
    Mat image;
    vector_KeyPoint keypoints;
    Mat descriptors;

    // const char* keywords[] = { "image", "keypoints", "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints"), keypoints, ArgInfo("keypoints", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute(image, keypoints, descriptors), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }
    

    {
    UMat image;
    vector_KeyPoint keypoints;
    UMat descriptors;

    // const char* keywords[] = { "image", "keypoints", "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints"), keypoints, ArgInfo("keypoints", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute(image, keypoints, descriptors), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }
    

    {
    vector_Mat images;
    vector_vector_KeyPoint keypoints;
    vector_Mat descriptors;

    // const char* keywords[] = { "images", "keypoints", "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints"), keypoints, ArgInfo("keypoints", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute(images, keypoints, descriptors), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }
    

    {
    vector_UMat images;
    vector_vector_KeyPoint keypoints;
    vector_UMat descriptors;

    // const char* keywords[] = { "images", "keypoints", "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints"), keypoints, ArgInfo("keypoints", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute(images, keypoints, descriptors), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_kaze_create_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    bool extended=false;
    bool upright=false;
    float threshold=0.001f;
    int nOctaves=4;
    int nOctaveLayers=4;
    std::underlying_type_t<KAZE_DiffusivityType> diffusivity=static_cast<std::underlying_type_t<KAZE_DiffusivityType>>(KAZE::DIFF_PM_G2);
    Ptr<KAZE> retval;

    // const char* keywords[] = { "extended", "upright", "threshold", "nOctaves", "nOctaveLayers", "diffusivity", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "extended"), extended, ArgInfo("extended", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "upright"), upright, ArgInfo("upright", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "threshold"), threshold, ArgInfo("threshold", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nOctaves"), nOctaves, ArgInfo("nOctaves", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nOctaveLayers"), nOctaveLayers, ArgInfo("nOctaveLayers", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "diffusivity"), diffusivity, ArgInfo("diffusivity", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::KAZE::create(extended, upright, threshold, nOctaves, nOctaveLayers, static_cast<KAZE_DiffusivityType>(diffusivity)), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_kaze_defaultNorm(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::KAZE> * self1 = 0;
    if (!evision_KAZE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::KAZE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::KAZE> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->defaultNorm(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_kaze_descriptorSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::KAZE> * self1 = 0;
    if (!evision_KAZE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::KAZE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::KAZE> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->descriptorSize(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_kaze_descriptorType(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::KAZE> * self1 = 0;
    if (!evision_KAZE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::KAZE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::KAZE> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->descriptorType(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_kaze_detect(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::KAZE> * self1 = 0;
    if (!evision_KAZE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::KAZE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::KAZE> _self_ = *(self1);

    {
    Mat image;
    vector_KeyPoint keypoints;
    Mat mask;

    // const char* keywords[] = { "image", "mask", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(image, keypoints, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, keypoints);
        }
    }

    }
    

    {
    UMat image;
    vector_KeyPoint keypoints;
    UMat mask;

    // const char* keywords[] = { "image", "mask", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(image, keypoints, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, keypoints);
        }
    }

    }
    

    {
    vector_Mat images;
    vector_vector_KeyPoint keypoints;
    vector_Mat masks;

    // const char* keywords[] = { "images", "masks", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "masks"), masks, ArgInfo("masks", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(images, keypoints, masks), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, keypoints);
        }
    }

    }
    

    {
    vector_UMat images;
    vector_vector_KeyPoint keypoints;
    vector_UMat masks;

    // const char* keywords[] = { "images", "masks", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "masks"), masks, ArgInfo("masks", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(images, keypoints, masks), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, keypoints);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_kaze_detectAndCompute(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::KAZE> * self1 = 0;
    if (!evision_KAZE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::KAZE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::KAZE> _self_ = *(self1);

    {
    Mat image;
    Mat mask;
    vector_KeyPoint keypoints;
    Mat descriptors;
    bool useProvidedKeypoints=false;

    // const char* keywords[] = { "image", "mask", "descriptors", "useProvidedKeypoints", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "useProvidedKeypoints"), useProvidedKeypoints, ArgInfo("useProvidedKeypoints", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detectAndCompute(image, mask, keypoints, descriptors, useProvidedKeypoints), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }
    

    {
    UMat image;
    UMat mask;
    vector_KeyPoint keypoints;
    UMat descriptors;
    bool useProvidedKeypoints=false;

    // const char* keywords[] = { "image", "mask", "descriptors", "useProvidedKeypoints", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "useProvidedKeypoints"), useProvidedKeypoints, ArgInfo("useProvidedKeypoints", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detectAndCompute(image, mask, keypoints, descriptors, useProvidedKeypoints), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_kaze_empty(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::KAZE> * self1 = 0;
    if (!evision_KAZE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::KAZE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::KAZE> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->empty(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_kaze_getDefaultName(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::KAZE> * self1 = 0;
    if (!evision_KAZE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::KAZE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::KAZE> _self_ = *(self1);
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getDefaultName(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_kaze_getDiffusivity(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::KAZE> * self1 = 0;
    if (!evision_KAZE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::KAZE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::KAZE> _self_ = *(self1);
    KAZE::DiffusivityType retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getDiffusivity(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_kaze_getExtended(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::KAZE> * self1 = 0;
    if (!evision_KAZE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::KAZE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::KAZE> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getExtended(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_kaze_getNOctaveLayers(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::KAZE> * self1 = 0;
    if (!evision_KAZE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::KAZE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::KAZE> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getNOctaveLayers(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_kaze_getNOctaves(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::KAZE> * self1 = 0;
    if (!evision_KAZE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::KAZE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::KAZE> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getNOctaves(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_kaze_getThreshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::KAZE> * self1 = 0;
    if (!evision_KAZE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::KAZE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::KAZE> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getThreshold(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_kaze_getUpright(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::KAZE> * self1 = 0;
    if (!evision_KAZE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::KAZE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::KAZE> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getUpright(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_kaze_read(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::KAZE> * self1 = 0;
    if (!evision_KAZE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::KAZE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::KAZE> _self_ = *(self1);

    {
    String fileName;

    // const char* keywords[] = { "fileName", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fileName"), fileName, ArgInfo("fileName", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->read(fileName), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "KAZE", success);
        }
    }

    }
    

    {
    FileNode arg1;

    // const char* keywords[] = { "arg1", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "arg1"), arg1, ArgInfo("arg1", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->read(arg1), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "KAZE", success);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_kaze_setDiffusivity(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::KAZE> * self1 = 0;
    if (!evision_KAZE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::KAZE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::KAZE> _self_ = *(self1);
    std::underlying_type_t<KAZE_DiffusivityType> diff=static_cast<std::underlying_type_t<KAZE_DiffusivityType>>(static_cast<KAZE_DiffusivityType>(0));

    // const char* keywords[] = { "diff", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "diff"), diff, ArgInfo("diff", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setDiffusivity(static_cast<KAZE_DiffusivityType>(diff)), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "KAZE", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_kaze_setExtended(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::KAZE> * self1 = 0;
    if (!evision_KAZE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::KAZE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::KAZE> _self_ = *(self1);
    bool extended=0;

    // const char* keywords[] = { "extended", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "extended"), extended, ArgInfo("extended", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setExtended(extended), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "KAZE", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_kaze_setNOctaveLayers(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::KAZE> * self1 = 0;
    if (!evision_KAZE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::KAZE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::KAZE> _self_ = *(self1);
    int octaveLayers=0;

    // const char* keywords[] = { "octaveLayers", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "octaveLayers"), octaveLayers, ArgInfo("octaveLayers", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setNOctaveLayers(octaveLayers), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "KAZE", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_kaze_setNOctaves(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::KAZE> * self1 = 0;
    if (!evision_KAZE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::KAZE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::KAZE> _self_ = *(self1);
    int octaves=0;

    // const char* keywords[] = { "octaves", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "octaves"), octaves, ArgInfo("octaves", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setNOctaves(octaves), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "KAZE", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_kaze_setThreshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::KAZE> * self1 = 0;
    if (!evision_KAZE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::KAZE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::KAZE> _self_ = *(self1);
    double threshold=0;

    // const char* keywords[] = { "threshold", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "threshold"), threshold, ArgInfo("threshold", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setThreshold(threshold), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "KAZE", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_kaze_setUpright(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::KAZE> * self1 = 0;
    if (!evision_KAZE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::KAZE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::KAZE> _self_ = *(self1);
    bool upright=0;

    // const char* keywords[] = { "upright", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "upright"), upright, ArgInfo("upright", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setUpright(upright), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "KAZE", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_kaze_write(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::KAZE> * self1 = 0;
    if (!evision_KAZE_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::KAZE>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::KAZE> _self_ = *(self1);

    {
    String fileName;

    // const char* keywords[] = { "fileName", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fileName"), fileName, ArgInfo("fileName", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->write(fileName), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "KAZE", success);
        }
    }

    }
    

    {
    Ptr<FileStorage> fs;
    String name;

    // const char* keywords[] = { "fs", "name", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fs"), fs, ArgInfo("fs", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "name"), name, ArgInfo("name", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->write(fs, name), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "KAZE", success);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (KAZE)

template<>
struct Evision_Converter< Ptr<cv::KAZE> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::KAZE>& r)
    {
        return evision_KAZE_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::KAZE>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::KAZE> * dst_ = nullptr;
        if (evision_KAZE_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::KAZE> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// KalmanFilter (Generic)
//================================================================================

// GetSet (KalmanFilter)


static ERL_NIF_TERM evision_KalmanFilter_get_controlMatrix(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    Ptr<cv::KalmanFilter>* self_ptr = 0;
    if (!evision_KalmanFilter_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `Ptr<cv::KalmanFilter>` from `self`: mismatched type or invalid resource?");
    }

    Ptr<cv::KalmanFilter> &self2 = *self_ptr;
    cv::KalmanFilter* _self_ = dynamic_cast<cv::KalmanFilter*>(self2.get());
    return evision_from(env, _self_->controlMatrix);
}

static ERL_NIF_TERM evision_KalmanFilter_set_controlMatrix(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    Ptr<cv::KalmanFilter>* self_ptr = 0;

    if (!evision_KalmanFilter_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `Ptr<cv::KalmanFilter>` from `self`: mismatched type or invalid resource?");
    }

    Ptr<cv::KalmanFilter> &_self_ = *self_ptr;

    std::map<std::string, ERL_NIF_TERM> erl_terms;
    evision::nif::parse_arg(env, 1, argv, erl_terms);

    if (evision_to_safe(env, evision_get_kw(env, erl_terms, "controlMatrix"), _self_->controlMatrix, ArgInfo("controlMatrix", false))) {
        bool success;
        return evision_from_as_map<Ptr<cv::KalmanFilter>>(env, _self_, self, "KalmanFilter", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_KalmanFilter_get_errorCovPost(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    Ptr<cv::KalmanFilter>* self_ptr = 0;
    if (!evision_KalmanFilter_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `Ptr<cv::KalmanFilter>` from `self`: mismatched type or invalid resource?");
    }

    Ptr<cv::KalmanFilter> &self2 = *self_ptr;
    cv::KalmanFilter* _self_ = dynamic_cast<cv::KalmanFilter*>(self2.get());
    return evision_from(env, _self_->errorCovPost);
}

static ERL_NIF_TERM evision_KalmanFilter_set_errorCovPost(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    Ptr<cv::KalmanFilter>* self_ptr = 0;

    if (!evision_KalmanFilter_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `Ptr<cv::KalmanFilter>` from `self`: mismatched type or invalid resource?");
    }

    Ptr<cv::KalmanFilter> &_self_ = *self_ptr;

    std::map<std::string, ERL_NIF_TERM> erl_terms;
    evision::nif::parse_arg(env, 1, argv, erl_terms);

    if (evision_to_safe(env, evision_get_kw(env, erl_terms, "errorCovPost"), _self_->errorCovPost, ArgInfo("errorCovPost", false))) {
        bool success;
        return evision_from_as_map<Ptr<cv::KalmanFilter>>(env, _self_, self, "KalmanFilter", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_KalmanFilter_get_errorCovPre(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    Ptr<cv::KalmanFilter>* self_ptr = 0;
    if (!evision_KalmanFilter_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `Ptr<cv::KalmanFilter>` from `self`: mismatched type or invalid resource?");
    }

    Ptr<cv::KalmanFilter> &self2 = *self_ptr;
    cv::KalmanFilter* _self_ = dynamic_cast<cv::KalmanFilter*>(self2.get());
    return evision_from(env, _self_->errorCovPre);
}

static ERL_NIF_TERM evision_KalmanFilter_set_errorCovPre(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    Ptr<cv::KalmanFilter>* self_ptr = 0;

    if (!evision_KalmanFilter_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `Ptr<cv::KalmanFilter>` from `self`: mismatched type or invalid resource?");
    }

    Ptr<cv::KalmanFilter> &_self_ = *self_ptr;

    std::map<std::string, ERL_NIF_TERM> erl_terms;
    evision::nif::parse_arg(env, 1, argv, erl_terms);

    if (evision_to_safe(env, evision_get_kw(env, erl_terms, "errorCovPre"), _self_->errorCovPre, ArgInfo("errorCovPre", false))) {
        bool success;
        return evision_from_as_map<Ptr<cv::KalmanFilter>>(env, _self_, self, "KalmanFilter", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_KalmanFilter_get_gain(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    Ptr<cv::KalmanFilter>* self_ptr = 0;
    if (!evision_KalmanFilter_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `Ptr<cv::KalmanFilter>` from `self`: mismatched type or invalid resource?");
    }

    Ptr<cv::KalmanFilter> &self2 = *self_ptr;
    cv::KalmanFilter* _self_ = dynamic_cast<cv::KalmanFilter*>(self2.get());
    return evision_from(env, _self_->gain);
}

static ERL_NIF_TERM evision_KalmanFilter_set_gain(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    Ptr<cv::KalmanFilter>* self_ptr = 0;

    if (!evision_KalmanFilter_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `Ptr<cv::KalmanFilter>` from `self`: mismatched type or invalid resource?");
    }

    Ptr<cv::KalmanFilter> &_self_ = *self_ptr;

    std::map<std::string, ERL_NIF_TERM> erl_terms;
    evision::nif::parse_arg(env, 1, argv, erl_terms);

    if (evision_to_safe(env, evision_get_kw(env, erl_terms, "gain"), _self_->gain, ArgInfo("gain", false))) {
        bool success;
        return evision_from_as_map<Ptr<cv::KalmanFilter>>(env, _self_, self, "KalmanFilter", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_KalmanFilter_get_measurementMatrix(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    Ptr<cv::KalmanFilter>* self_ptr = 0;
    if (!evision_KalmanFilter_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `Ptr<cv::KalmanFilter>` from `self`: mismatched type or invalid resource?");
    }

    Ptr<cv::KalmanFilter> &self2 = *self_ptr;
    cv::KalmanFilter* _self_ = dynamic_cast<cv::KalmanFilter*>(self2.get());
    return evision_from(env, _self_->measurementMatrix);
}

static ERL_NIF_TERM evision_KalmanFilter_set_measurementMatrix(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    Ptr<cv::KalmanFilter>* self_ptr = 0;

    if (!evision_KalmanFilter_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `Ptr<cv::KalmanFilter>` from `self`: mismatched type or invalid resource?");
    }

    Ptr<cv::KalmanFilter> &_self_ = *self_ptr;

    std::map<std::string, ERL_NIF_TERM> erl_terms;
    evision::nif::parse_arg(env, 1, argv, erl_terms);

    if (evision_to_safe(env, evision_get_kw(env, erl_terms, "measurementMatrix"), _self_->measurementMatrix, ArgInfo("measurementMatrix", false))) {
        bool success;
        return evision_from_as_map<Ptr<cv::KalmanFilter>>(env, _self_, self, "KalmanFilter", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_KalmanFilter_get_measurementNoiseCov(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    Ptr<cv::KalmanFilter>* self_ptr = 0;
    if (!evision_KalmanFilter_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `Ptr<cv::KalmanFilter>` from `self`: mismatched type or invalid resource?");
    }

    Ptr<cv::KalmanFilter> &self2 = *self_ptr;
    cv::KalmanFilter* _self_ = dynamic_cast<cv::KalmanFilter*>(self2.get());
    return evision_from(env, _self_->measurementNoiseCov);
}

static ERL_NIF_TERM evision_KalmanFilter_set_measurementNoiseCov(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    Ptr<cv::KalmanFilter>* self_ptr = 0;

    if (!evision_KalmanFilter_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `Ptr<cv::KalmanFilter>` from `self`: mismatched type or invalid resource?");
    }

    Ptr<cv::KalmanFilter> &_self_ = *self_ptr;

    std::map<std::string, ERL_NIF_TERM> erl_terms;
    evision::nif::parse_arg(env, 1, argv, erl_terms);

    if (evision_to_safe(env, evision_get_kw(env, erl_terms, "measurementNoiseCov"), _self_->measurementNoiseCov, ArgInfo("measurementNoiseCov", false))) {
        bool success;
        return evision_from_as_map<Ptr<cv::KalmanFilter>>(env, _self_, self, "KalmanFilter", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_KalmanFilter_get_processNoiseCov(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    Ptr<cv::KalmanFilter>* self_ptr = 0;
    if (!evision_KalmanFilter_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `Ptr<cv::KalmanFilter>` from `self`: mismatched type or invalid resource?");
    }

    Ptr<cv::KalmanFilter> &self2 = *self_ptr;
    cv::KalmanFilter* _self_ = dynamic_cast<cv::KalmanFilter*>(self2.get());
    return evision_from(env, _self_->processNoiseCov);
}

static ERL_NIF_TERM evision_KalmanFilter_set_processNoiseCov(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    Ptr<cv::KalmanFilter>* self_ptr = 0;

    if (!evision_KalmanFilter_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `Ptr<cv::KalmanFilter>` from `self`: mismatched type or invalid resource?");
    }

    Ptr<cv::KalmanFilter> &_self_ = *self_ptr;

    std::map<std::string, ERL_NIF_TERM> erl_terms;
    evision::nif::parse_arg(env, 1, argv, erl_terms);

    if (evision_to_safe(env, evision_get_kw(env, erl_terms, "processNoiseCov"), _self_->processNoiseCov, ArgInfo("processNoiseCov", false))) {
        bool success;
        return evision_from_as_map<Ptr<cv::KalmanFilter>>(env, _self_, self, "KalmanFilter", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_KalmanFilter_get_statePost(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    Ptr<cv::KalmanFilter>* self_ptr = 0;
    if (!evision_KalmanFilter_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `Ptr<cv::KalmanFilter>` from `self`: mismatched type or invalid resource?");
    }

    Ptr<cv::KalmanFilter> &self2 = *self_ptr;
    cv::KalmanFilter* _self_ = dynamic_cast<cv::KalmanFilter*>(self2.get());
    return evision_from(env, _self_->statePost);
}

static ERL_NIF_TERM evision_KalmanFilter_set_statePost(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    Ptr<cv::KalmanFilter>* self_ptr = 0;

    if (!evision_KalmanFilter_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `Ptr<cv::KalmanFilter>` from `self`: mismatched type or invalid resource?");
    }

    Ptr<cv::KalmanFilter> &_self_ = *self_ptr;

    std::map<std::string, ERL_NIF_TERM> erl_terms;
    evision::nif::parse_arg(env, 1, argv, erl_terms);

    if (evision_to_safe(env, evision_get_kw(env, erl_terms, "statePost"), _self_->statePost, ArgInfo("statePost", false))) {
        bool success;
        return evision_from_as_map<Ptr<cv::KalmanFilter>>(env, _self_, self, "KalmanFilter", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_KalmanFilter_get_statePre(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    Ptr<cv::KalmanFilter>* self_ptr = 0;
    if (!evision_KalmanFilter_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `Ptr<cv::KalmanFilter>` from `self`: mismatched type or invalid resource?");
    }

    Ptr<cv::KalmanFilter> &self2 = *self_ptr;
    cv::KalmanFilter* _self_ = dynamic_cast<cv::KalmanFilter*>(self2.get());
    return evision_from(env, _self_->statePre);
}

static ERL_NIF_TERM evision_KalmanFilter_set_statePre(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    Ptr<cv::KalmanFilter>* self_ptr = 0;

    if (!evision_KalmanFilter_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `Ptr<cv::KalmanFilter>` from `self`: mismatched type or invalid resource?");
    }

    Ptr<cv::KalmanFilter> &_self_ = *self_ptr;

    std::map<std::string, ERL_NIF_TERM> erl_terms;
    evision::nif::parse_arg(env, 1, argv, erl_terms);

    if (evision_to_safe(env, evision_get_kw(env, erl_terms, "statePre"), _self_->statePre, ArgInfo("statePre", false))) {
        bool success;
        return evision_from_as_map<Ptr<cv::KalmanFilter>>(env, _self_, self, "KalmanFilter", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_KalmanFilter_get_transitionMatrix(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    Ptr<cv::KalmanFilter>* self_ptr = 0;
    if (!evision_KalmanFilter_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `Ptr<cv::KalmanFilter>` from `self`: mismatched type or invalid resource?");
    }

    Ptr<cv::KalmanFilter> &self2 = *self_ptr;
    cv::KalmanFilter* _self_ = dynamic_cast<cv::KalmanFilter*>(self2.get());
    return evision_from(env, _self_->transitionMatrix);
}

static ERL_NIF_TERM evision_KalmanFilter_set_transitionMatrix(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    Ptr<cv::KalmanFilter>* self_ptr = 0;

    if (!evision_KalmanFilter_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `Ptr<cv::KalmanFilter>` from `self`: mismatched type or invalid resource?");
    }

    Ptr<cv::KalmanFilter> &_self_ = *self_ptr;

    std::map<std::string, ERL_NIF_TERM> erl_terms;
    evision::nif::parse_arg(env, 1, argv, erl_terms);

    if (evision_to_safe(env, evision_get_kw(env, erl_terms, "transitionMatrix"), _self_->transitionMatrix, ArgInfo("transitionMatrix", false))) {
        bool success;
        return evision_from_as_map<Ptr<cv::KalmanFilter>>(env, _self_, self, "KalmanFilter", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}


// Methods (KalmanFilter)

static ERL_NIF_TERM evision_cv_kalmanFilter_KalmanFilter(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    {

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        evision_res<Ptr<cv::KalmanFilter>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::KalmanFilter>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::KalmanFilter()), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::KalmanFilter>>(env, self->val, ret, "KalmanFilter", success);;
        }
    }

    }
    

    {
    int dynamParams=0;
    int measureParams=0;
    int controlParams=0;
    int type=CV_32F;

    // const char* keywords[] = { "dynamParams", "measureParams", "controlParams", "type", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "dynamParams"), dynamParams, ArgInfo("dynamParams", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "measureParams"), measureParams, ArgInfo("measureParams", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "controlParams"), controlParams, ArgInfo("controlParams", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "type"), type, ArgInfo("type", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::KalmanFilter>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::KalmanFilter>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::KalmanFilter(dynamParams, measureParams, controlParams, type)), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::KalmanFilter>>(env, self->val, ret, "KalmanFilter", success);;
        }
    }

    }

    return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_kalmanFilter_correct(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::KalmanFilter> * self1 = 0;
    if (!evision_KalmanFilter_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::KalmanFilter>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::KalmanFilter> _self_ = *(self1);
    Mat measurement;
    Mat retval;

    // const char* keywords[] = { "measurement", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "measurement"), measurement, ArgInfo("measurement", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->correct(measurement), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_kalmanFilter_predict(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::KalmanFilter> * self1 = 0;
    if (!evision_KalmanFilter_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::KalmanFilter>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::KalmanFilter> _self_ = *(self1);
    Mat control;
    Mat retval;

    // const char* keywords[] = { "control", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "control"), control, ArgInfo("control", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->predict(control), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (KalmanFilter)

template<>
struct Evision_Converter< Ptr<cv::KalmanFilter> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::KalmanFilter>& r)
    {
        return evision_KalmanFilter_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::KalmanFilter>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::KalmanFilter> * dst_ = nullptr;
        if (evision_KalmanFilter_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::KalmanFilter> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// KeyPoint (Generic)
//================================================================================

// GetSet (KeyPoint)


static ERL_NIF_TERM evision_KeyPoint_get_angle(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::KeyPoint* self_ptr = 0;
    if (!evision_KeyPoint_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::KeyPoint` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->angle);
}

static ERL_NIF_TERM evision_KeyPoint_set_angle(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::KeyPoint* self_ptr = 0;

    if (!evision_KeyPoint_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::KeyPoint` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->angle, ArgInfo("angle", false))) {
        bool success;
        return evision_from_as_map<cv::KeyPoint>(env, *self_ptr, self, "KeyPoint", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_KeyPoint_get_class_id(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::KeyPoint* self_ptr = 0;
    if (!evision_KeyPoint_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::KeyPoint` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->class_id);
}

static ERL_NIF_TERM evision_KeyPoint_set_class_id(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::KeyPoint* self_ptr = 0;

    if (!evision_KeyPoint_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::KeyPoint` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->class_id, ArgInfo("class_id", false))) {
        bool success;
        return evision_from_as_map<cv::KeyPoint>(env, *self_ptr, self, "KeyPoint", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_KeyPoint_get_octave(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::KeyPoint* self_ptr = 0;
    if (!evision_KeyPoint_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::KeyPoint` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->octave);
}

static ERL_NIF_TERM evision_KeyPoint_set_octave(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::KeyPoint* self_ptr = 0;

    if (!evision_KeyPoint_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::KeyPoint` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->octave, ArgInfo("octave", false))) {
        bool success;
        return evision_from_as_map<cv::KeyPoint>(env, *self_ptr, self, "KeyPoint", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_KeyPoint_get_pt(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::KeyPoint* self_ptr = 0;
    if (!evision_KeyPoint_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::KeyPoint` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->pt);
}

static ERL_NIF_TERM evision_KeyPoint_set_pt(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::KeyPoint* self_ptr = 0;

    if (!evision_KeyPoint_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::KeyPoint` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->pt, ArgInfo("pt", false))) {
        bool success;
        return evision_from_as_map<cv::KeyPoint>(env, *self_ptr, self, "KeyPoint", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_KeyPoint_get_response(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::KeyPoint* self_ptr = 0;
    if (!evision_KeyPoint_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::KeyPoint` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->response);
}

static ERL_NIF_TERM evision_KeyPoint_set_response(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::KeyPoint* self_ptr = 0;

    if (!evision_KeyPoint_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::KeyPoint` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->response, ArgInfo("response", false))) {
        bool success;
        return evision_from_as_map<cv::KeyPoint>(env, *self_ptr, self, "KeyPoint", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_KeyPoint_get_size(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::KeyPoint* self_ptr = 0;
    if (!evision_KeyPoint_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::KeyPoint` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->size);
}

static ERL_NIF_TERM evision_KeyPoint_set_size(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::KeyPoint* self_ptr = 0;

    if (!evision_KeyPoint_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::KeyPoint` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->size, ArgInfo("size", false))) {
        bool success;
        return evision_from_as_map<cv::KeyPoint>(env, *self_ptr, self, "KeyPoint", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}


// Methods (KeyPoint)

static ERL_NIF_TERM evision_cv_keyPoint_KeyPoint(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    {

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        evision_res<cv::KeyPoint> * self = nullptr;
        if (alloc_resource(&self)) ERRWRAP2(new (&(self->val)) cv::KeyPoint(), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<cv::KeyPoint>(env, self->val, ret, "KeyPoint", success);;
        }
    }

    }
    

    {
    float x=0.f;
    float y=0.f;
    float size=0.f;
    float angle=-1;
    float response=0;
    int octave=0;
    int class_id=-1;

    // const char* keywords[] = { "x", "y", "size", "angle", "response", "octave", "class_id", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "x"), x, ArgInfo("x", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "y"), y, ArgInfo("y", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "size"), size, ArgInfo("size", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "angle"), angle, ArgInfo("angle", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "response"), response, ArgInfo("response", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "octave"), octave, ArgInfo("octave", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "class_id"), class_id, ArgInfo("class_id", 0)) )
    {
        int error_flag = false;
        evision_res<cv::KeyPoint> * self = nullptr;
        if (alloc_resource(&self)) ERRWRAP2(new (&(self->val)) cv::KeyPoint(x, y, size, angle, response, octave, class_id), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<cv::KeyPoint>(env, self->val, ret, "KeyPoint", success);;
        }
    }

    }

    return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_keyPoint_convert_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    {
    vector_KeyPoint keypoints;
    vector_Point2f points2f;
    vector_int keypointIndexes=std::vector<int>();

    // const char* keywords[] = { "keypoints", "keypointIndexes", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints"), keypoints, ArgInfo("keypoints", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypointIndexes"), keypointIndexes, ArgInfo("keypointIndexes", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(cv::KeyPoint::convert(keypoints, points2f, keypointIndexes), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, points2f);
        }
    }

    }
    

    {
    vector_Point2f points2f;
    vector_KeyPoint keypoints;
    float size=1;
    float response=1;
    int octave=0;
    int class_id=-1;

    // const char* keywords[] = { "points2f", "size", "response", "octave", "class_id", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "points2f"), points2f, ArgInfo("points2f", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "size"), size, ArgInfo("size", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "response"), response, ArgInfo("response", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "octave"), octave, ArgInfo("octave", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "class_id"), class_id, ArgInfo("class_id", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(cv::KeyPoint::convert(points2f, keypoints, size, response, octave, class_id), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, keypoints);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_keyPoint_overlap_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    KeyPoint kp1;
    KeyPoint kp2;
    float retval;

    // const char* keywords[] = { "kp1", "kp2", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "kp1"), kp1, ArgInfo("kp1", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "kp2"), kp2, ArgInfo("kp2", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::KeyPoint::overlap(kp1, kp2), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (KeyPoint)

template<>
struct Evision_Converter< cv::KeyPoint >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const cv::KeyPoint& r)
    {
        return evision_KeyPoint_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, cv::KeyPoint& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        cv::KeyPoint * dst_ = nullptr;
        if (evision_KeyPoint_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected cv::KeyPoint for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// LineSegmentDetector (Generic)
//================================================================================

// GetSet (LineSegmentDetector)



// Methods (LineSegmentDetector)

static ERL_NIF_TERM evision_cv_lineSegmentDetector_clear(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::LineSegmentDetector> * self1 = 0;
    if (!evision_LineSegmentDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::LineSegmentDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::LineSegmentDetector> _self_ = *(self1);

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::clear(), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "LineSegmentDetector", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_lineSegmentDetector_compareSegments(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::LineSegmentDetector> * self1 = 0;
    if (!evision_LineSegmentDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::LineSegmentDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::LineSegmentDetector> _self_ = *(self1);

    {
    Size size;
    Mat lines1;
    Mat lines2;
    Mat image;
    int retval;

    // const char* keywords[] = { "size", "lines1", "lines2", "image", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "size"), size, ArgInfo("size", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lines1"), lines1, ArgInfo("lines1", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lines2"), lines2, ArgInfo("lines2", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->compareSegments(size, lines1, lines2, image), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, image));
        }
    }

    }
    

    {
    Size size;
    UMat lines1;
    UMat lines2;
    UMat image;
    int retval;

    // const char* keywords[] = { "size", "lines1", "lines2", "image", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "size"), size, ArgInfo("size", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lines1"), lines1, ArgInfo("lines1", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lines2"), lines2, ArgInfo("lines2", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->compareSegments(size, lines1, lines2, image), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, image));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_lineSegmentDetector_detect(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::LineSegmentDetector> * self1 = 0;
    if (!evision_LineSegmentDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::LineSegmentDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::LineSegmentDetector> _self_ = *(self1);

    {
    Mat image;
    Mat lines;
    Mat width;
    Mat prec;
    Mat nfa;

    // const char* keywords[] = { "image", "lines", "width", "prec", "nfa", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lines"), lines, ArgInfo("lines", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "width"), width, ArgInfo("width", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "prec"), prec, ArgInfo("prec", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nfa"), nfa, ArgInfo("nfa", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(image, lines, width, prec, nfa), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple4(env, evision_from(env, lines), evision_from(env, width), evision_from(env, prec), evision_from(env, nfa));
        }
    }

    }
    

    {
    UMat image;
    UMat lines;
    UMat width;
    UMat prec;
    UMat nfa;

    // const char* keywords[] = { "image", "lines", "width", "prec", "nfa", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lines"), lines, ArgInfo("lines", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "width"), width, ArgInfo("width", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "prec"), prec, ArgInfo("prec", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nfa"), nfa, ArgInfo("nfa", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(image, lines, width, prec, nfa), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple4(env, evision_from(env, lines), evision_from(env, width), evision_from(env, prec), evision_from(env, nfa));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_lineSegmentDetector_drawSegments(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::LineSegmentDetector> * self1 = 0;
    if (!evision_LineSegmentDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::LineSegmentDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::LineSegmentDetector> _self_ = *(self1);

    {
    Mat image;
    Mat lines;

    // const char* keywords[] = { "image", "lines", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lines"), lines, ArgInfo("lines", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->drawSegments(image, lines), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, image);
        }
    }

    }
    

    {
    UMat image;
    UMat lines;

    // const char* keywords[] = { "image", "lines", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lines"), lines, ArgInfo("lines", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->drawSegments(image, lines), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, image);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_lineSegmentDetector_empty(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::LineSegmentDetector> * self1 = 0;
    if (!evision_LineSegmentDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::LineSegmentDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::LineSegmentDetector> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->Algorithm::empty(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_lineSegmentDetector_getDefaultName(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::LineSegmentDetector> * self1 = 0;
    if (!evision_LineSegmentDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::LineSegmentDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::LineSegmentDetector> _self_ = *(self1);
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->Algorithm::getDefaultName(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_lineSegmentDetector_read(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::LineSegmentDetector> * self1 = 0;
    if (!evision_LineSegmentDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::LineSegmentDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::LineSegmentDetector> _self_ = *(self1);
    FileNode fn_;

    // const char* keywords[] = { "fn_", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fn_"), fn_, ArgInfo("fn_", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::read(fn_), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "LineSegmentDetector", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_lineSegmentDetector_save(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::LineSegmentDetector> * self1 = 0;
    if (!evision_LineSegmentDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::LineSegmentDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::LineSegmentDetector> _self_ = *(self1);
    String filename;

    // const char* keywords[] = { "filename", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::save(filename), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "LineSegmentDetector", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_lineSegmentDetector_write(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::LineSegmentDetector> * self1 = 0;
    if (!evision_LineSegmentDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::LineSegmentDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::LineSegmentDetector> _self_ = *(self1);
    Ptr<FileStorage> fs;
    String name;

    // const char* keywords[] = { "fs", "name", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fs"), fs, ArgInfo("fs", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "name"), name, ArgInfo("name", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::write(fs, name), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "LineSegmentDetector", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (LineSegmentDetector)

template<>
struct Evision_Converter< Ptr<cv::LineSegmentDetector> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::LineSegmentDetector>& r)
    {
        return evision_LineSegmentDetector_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::LineSegmentDetector>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::LineSegmentDetector> * dst_ = nullptr;
        if (evision_LineSegmentDetector_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::LineSegmentDetector> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// MSER (Generic)
//================================================================================

// GetSet (MSER)



// Methods (MSER)

static ERL_NIF_TERM evision_cv_mser_compute(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::MSER> * self1 = 0;
    if (!evision_MSER_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::MSER>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::MSER> _self_ = *(self1);

    {
    Mat image;
    vector_KeyPoint keypoints;
    Mat descriptors;

    // const char* keywords[] = { "image", "keypoints", "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints"), keypoints, ArgInfo("keypoints", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute(image, keypoints, descriptors), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }
    

    {
    UMat image;
    vector_KeyPoint keypoints;
    UMat descriptors;

    // const char* keywords[] = { "image", "keypoints", "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints"), keypoints, ArgInfo("keypoints", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute(image, keypoints, descriptors), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }
    

    {
    vector_Mat images;
    vector_vector_KeyPoint keypoints;
    vector_Mat descriptors;

    // const char* keywords[] = { "images", "keypoints", "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints"), keypoints, ArgInfo("keypoints", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute(images, keypoints, descriptors), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }
    

    {
    vector_UMat images;
    vector_vector_KeyPoint keypoints;
    vector_UMat descriptors;

    // const char* keywords[] = { "images", "keypoints", "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints"), keypoints, ArgInfo("keypoints", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute(images, keypoints, descriptors), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_mser_create_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    int delta=5;
    int min_area=60;
    int max_area=14400;
    double max_variation=0.25;
    double min_diversity=.2;
    int max_evolution=200;
    double area_threshold=1.01;
    double min_margin=0.003;
    int edge_blur_size=5;
    Ptr<MSER> retval;

    // const char* keywords[] = { "delta", "min_area", "max_area", "max_variation", "min_diversity", "max_evolution", "area_threshold", "min_margin", "edge_blur_size", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "delta"), delta, ArgInfo("delta", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "min_area"), min_area, ArgInfo("min_area", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "max_area"), max_area, ArgInfo("max_area", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "max_variation"), max_variation, ArgInfo("max_variation", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "min_diversity"), min_diversity, ArgInfo("min_diversity", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "max_evolution"), max_evolution, ArgInfo("max_evolution", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "area_threshold"), area_threshold, ArgInfo("area_threshold", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "min_margin"), min_margin, ArgInfo("min_margin", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "edge_blur_size"), edge_blur_size, ArgInfo("edge_blur_size", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::MSER::create(delta, min_area, max_area, max_variation, min_diversity, max_evolution, area_threshold, min_margin, edge_blur_size), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_mser_defaultNorm(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::MSER> * self1 = 0;
    if (!evision_MSER_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::MSER>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::MSER> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->defaultNorm(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_mser_descriptorSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::MSER> * self1 = 0;
    if (!evision_MSER_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::MSER>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::MSER> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->descriptorSize(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_mser_descriptorType(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::MSER> * self1 = 0;
    if (!evision_MSER_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::MSER>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::MSER> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->descriptorType(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_mser_detect(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::MSER> * self1 = 0;
    if (!evision_MSER_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::MSER>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::MSER> _self_ = *(self1);

    {
    Mat image;
    vector_KeyPoint keypoints;
    Mat mask;

    // const char* keywords[] = { "image", "mask", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(image, keypoints, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, keypoints);
        }
    }

    }
    

    {
    UMat image;
    vector_KeyPoint keypoints;
    UMat mask;

    // const char* keywords[] = { "image", "mask", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(image, keypoints, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, keypoints);
        }
    }

    }
    

    {
    vector_Mat images;
    vector_vector_KeyPoint keypoints;
    vector_Mat masks;

    // const char* keywords[] = { "images", "masks", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "masks"), masks, ArgInfo("masks", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(images, keypoints, masks), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, keypoints);
        }
    }

    }
    

    {
    vector_UMat images;
    vector_vector_KeyPoint keypoints;
    vector_UMat masks;

    // const char* keywords[] = { "images", "masks", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "masks"), masks, ArgInfo("masks", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(images, keypoints, masks), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, keypoints);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_mser_detectAndCompute(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::MSER> * self1 = 0;
    if (!evision_MSER_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::MSER>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::MSER> _self_ = *(self1);

    {
    Mat image;
    Mat mask;
    vector_KeyPoint keypoints;
    Mat descriptors;
    bool useProvidedKeypoints=false;

    // const char* keywords[] = { "image", "mask", "descriptors", "useProvidedKeypoints", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "useProvidedKeypoints"), useProvidedKeypoints, ArgInfo("useProvidedKeypoints", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detectAndCompute(image, mask, keypoints, descriptors, useProvidedKeypoints), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }
    

    {
    UMat image;
    UMat mask;
    vector_KeyPoint keypoints;
    UMat descriptors;
    bool useProvidedKeypoints=false;

    // const char* keywords[] = { "image", "mask", "descriptors", "useProvidedKeypoints", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "useProvidedKeypoints"), useProvidedKeypoints, ArgInfo("useProvidedKeypoints", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detectAndCompute(image, mask, keypoints, descriptors, useProvidedKeypoints), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_mser_detectRegions(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::MSER> * self1 = 0;
    if (!evision_MSER_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::MSER>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::MSER> _self_ = *(self1);

    {
    Mat image;
    vector_vector_Point msers;
    vector_Rect bboxes;

    // const char* keywords[] = { "image", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detectRegions(image, msers, bboxes), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, msers), evision_from(env, bboxes));
        }
    }

    }
    

    {
    UMat image;
    vector_vector_Point msers;
    vector_Rect bboxes;

    // const char* keywords[] = { "image", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detectRegions(image, msers, bboxes), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, msers), evision_from(env, bboxes));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_mser_empty(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::MSER> * self1 = 0;
    if (!evision_MSER_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::MSER>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::MSER> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->empty(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_mser_getDefaultName(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::MSER> * self1 = 0;
    if (!evision_MSER_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::MSER>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::MSER> _self_ = *(self1);
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getDefaultName(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_mser_getDelta(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::MSER> * self1 = 0;
    if (!evision_MSER_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::MSER>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::MSER> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getDelta(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_mser_getMaxArea(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::MSER> * self1 = 0;
    if (!evision_MSER_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::MSER>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::MSER> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getMaxArea(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_mser_getMinArea(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::MSER> * self1 = 0;
    if (!evision_MSER_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::MSER>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::MSER> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getMinArea(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_mser_getPass2Only(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::MSER> * self1 = 0;
    if (!evision_MSER_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::MSER>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::MSER> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getPass2Only(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_mser_read(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::MSER> * self1 = 0;
    if (!evision_MSER_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::MSER>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::MSER> _self_ = *(self1);

    {
    String fileName;

    // const char* keywords[] = { "fileName", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fileName"), fileName, ArgInfo("fileName", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->read(fileName), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "MSER", success);
        }
    }

    }
    

    {
    FileNode arg1;

    // const char* keywords[] = { "arg1", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "arg1"), arg1, ArgInfo("arg1", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->read(arg1), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "MSER", success);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_mser_setDelta(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::MSER> * self1 = 0;
    if (!evision_MSER_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::MSER>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::MSER> _self_ = *(self1);
    int delta=0;

    // const char* keywords[] = { "delta", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "delta"), delta, ArgInfo("delta", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setDelta(delta), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "MSER", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_mser_setMaxArea(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::MSER> * self1 = 0;
    if (!evision_MSER_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::MSER>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::MSER> _self_ = *(self1);
    int maxArea=0;

    // const char* keywords[] = { "maxArea", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "maxArea"), maxArea, ArgInfo("maxArea", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setMaxArea(maxArea), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "MSER", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_mser_setMinArea(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::MSER> * self1 = 0;
    if (!evision_MSER_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::MSER>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::MSER> _self_ = *(self1);
    int minArea=0;

    // const char* keywords[] = { "minArea", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "minArea"), minArea, ArgInfo("minArea", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setMinArea(minArea), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "MSER", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_mser_setPass2Only(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::MSER> * self1 = 0;
    if (!evision_MSER_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::MSER>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::MSER> _self_ = *(self1);
    bool f=0;

    // const char* keywords[] = { "f", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "f"), f, ArgInfo("f", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setPass2Only(f), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "MSER", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_mser_write(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::MSER> * self1 = 0;
    if (!evision_MSER_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::MSER>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::MSER> _self_ = *(self1);

    {
    String fileName;

    // const char* keywords[] = { "fileName", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fileName"), fileName, ArgInfo("fileName", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->write(fileName), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "MSER", success);
        }
    }

    }
    

    {
    Ptr<FileStorage> fs;
    String name;

    // const char* keywords[] = { "fs", "name", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fs"), fs, ArgInfo("fs", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "name"), name, ArgInfo("name", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->write(fs, name), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "MSER", success);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (MSER)

template<>
struct Evision_Converter< Ptr<cv::MSER> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::MSER>& r)
    {
        return evision_MSER_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::MSER>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::MSER> * dst_ = nullptr;
        if (evision_MSER_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::MSER> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// MergeDebevec (Generic)
//================================================================================

// GetSet (MergeDebevec)



// Methods (MergeDebevec)

static ERL_NIF_TERM evision_cv_mergeDebevec_process(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::MergeDebevec> * self1 = 0;
    if (!evision_MergeDebevec_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::MergeDebevec>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::MergeDebevec> _self_ = *(self1);

    {
    vector_Mat src;
    Mat dst;
    Mat times;
    Mat response;

    // const char* keywords[] = { "src", "times", "response", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "times"), times, ArgInfo("times", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "response"), response, ArgInfo("response", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->process(src, dst, times, response), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    vector_UMat src;
    UMat dst;
    UMat times;
    UMat response;

    // const char* keywords[] = { "src", "times", "response", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "times"), times, ArgInfo("times", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "response"), response, ArgInfo("response", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->process(src, dst, times, response), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    vector_Mat src;
    Mat dst;
    Mat times;

    // const char* keywords[] = { "src", "times", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "times"), times, ArgInfo("times", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->process(src, dst, times), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    vector_UMat src;
    UMat dst;
    UMat times;

    // const char* keywords[] = { "src", "times", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "times"), times, ArgInfo("times", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->process(src, dst, times), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (MergeDebevec)

template<>
struct Evision_Converter< Ptr<cv::MergeDebevec> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::MergeDebevec>& r)
    {
        return evision_MergeDebevec_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::MergeDebevec>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::MergeDebevec> * dst_ = nullptr;
        if (evision_MergeDebevec_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::MergeDebevec> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// MergeExposures (Generic)
//================================================================================

// GetSet (MergeExposures)



// Methods (MergeExposures)

static ERL_NIF_TERM evision_cv_mergeExposures_clear(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::MergeExposures> * self1 = 0;
    if (!evision_MergeExposures_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::MergeExposures>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::MergeExposures> _self_ = *(self1);

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::clear(), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "MergeExposures", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_mergeExposures_empty(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::MergeExposures> * self1 = 0;
    if (!evision_MergeExposures_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::MergeExposures>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::MergeExposures> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->Algorithm::empty(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_mergeExposures_getDefaultName(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::MergeExposures> * self1 = 0;
    if (!evision_MergeExposures_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::MergeExposures>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::MergeExposures> _self_ = *(self1);
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->Algorithm::getDefaultName(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_mergeExposures_process(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::MergeExposures> * self1 = 0;
    if (!evision_MergeExposures_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::MergeExposures>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::MergeExposures> _self_ = *(self1);

    {
    vector_Mat src;
    Mat dst;
    Mat times;
    Mat response;

    // const char* keywords[] = { "src", "times", "response", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "times"), times, ArgInfo("times", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "response"), response, ArgInfo("response", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->process(src, dst, times, response), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    vector_UMat src;
    UMat dst;
    UMat times;
    UMat response;

    // const char* keywords[] = { "src", "times", "response", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "times"), times, ArgInfo("times", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "response"), response, ArgInfo("response", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->process(src, dst, times, response), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_mergeExposures_read(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::MergeExposures> * self1 = 0;
    if (!evision_MergeExposures_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::MergeExposures>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::MergeExposures> _self_ = *(self1);
    FileNode fn_;

    // const char* keywords[] = { "fn_", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fn_"), fn_, ArgInfo("fn_", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::read(fn_), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "MergeExposures", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_mergeExposures_save(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::MergeExposures> * self1 = 0;
    if (!evision_MergeExposures_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::MergeExposures>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::MergeExposures> _self_ = *(self1);
    String filename;

    // const char* keywords[] = { "filename", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::save(filename), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "MergeExposures", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_mergeExposures_write(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::MergeExposures> * self1 = 0;
    if (!evision_MergeExposures_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::MergeExposures>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::MergeExposures> _self_ = *(self1);
    Ptr<FileStorage> fs;
    String name;

    // const char* keywords[] = { "fs", "name", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fs"), fs, ArgInfo("fs", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "name"), name, ArgInfo("name", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::write(fs, name), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "MergeExposures", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (MergeExposures)

template<>
struct Evision_Converter< Ptr<cv::MergeExposures> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::MergeExposures>& r)
    {
        return evision_MergeExposures_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::MergeExposures>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::MergeExposures> * dst_ = nullptr;
        if (evision_MergeExposures_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::MergeExposures> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// MergeMertens (Generic)
//================================================================================

// GetSet (MergeMertens)



// Methods (MergeMertens)

static ERL_NIF_TERM evision_cv_mergeMertens_getContrastWeight(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::MergeMertens> * self1 = 0;
    if (!evision_MergeMertens_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::MergeMertens>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::MergeMertens> _self_ = *(self1);
    float retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getContrastWeight(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_mergeMertens_getExposureWeight(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::MergeMertens> * self1 = 0;
    if (!evision_MergeMertens_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::MergeMertens>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::MergeMertens> _self_ = *(self1);
    float retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getExposureWeight(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_mergeMertens_getSaturationWeight(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::MergeMertens> * self1 = 0;
    if (!evision_MergeMertens_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::MergeMertens>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::MergeMertens> _self_ = *(self1);
    float retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getSaturationWeight(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_mergeMertens_process(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::MergeMertens> * self1 = 0;
    if (!evision_MergeMertens_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::MergeMertens>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::MergeMertens> _self_ = *(self1);

    {
    vector_Mat src;
    Mat dst;
    Mat times;
    Mat response;

    // const char* keywords[] = { "src", "times", "response", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "times"), times, ArgInfo("times", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "response"), response, ArgInfo("response", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->process(src, dst, times, response), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    vector_UMat src;
    UMat dst;
    UMat times;
    UMat response;

    // const char* keywords[] = { "src", "times", "response", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "times"), times, ArgInfo("times", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "response"), response, ArgInfo("response", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->process(src, dst, times, response), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    vector_Mat src;
    Mat dst;

    // const char* keywords[] = { "src", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->process(src, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    vector_UMat src;
    UMat dst;

    // const char* keywords[] = { "src", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->process(src, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_mergeMertens_setContrastWeight(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::MergeMertens> * self1 = 0;
    if (!evision_MergeMertens_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::MergeMertens>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::MergeMertens> _self_ = *(self1);
    float contrast_weiht=0.f;

    // const char* keywords[] = { "contrast_weiht", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "contrast_weiht"), contrast_weiht, ArgInfo("contrast_weiht", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setContrastWeight(contrast_weiht), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "MergeMertens", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_mergeMertens_setExposureWeight(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::MergeMertens> * self1 = 0;
    if (!evision_MergeMertens_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::MergeMertens>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::MergeMertens> _self_ = *(self1);
    float exposure_weight=0.f;

    // const char* keywords[] = { "exposure_weight", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "exposure_weight"), exposure_weight, ArgInfo("exposure_weight", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setExposureWeight(exposure_weight), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "MergeMertens", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_mergeMertens_setSaturationWeight(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::MergeMertens> * self1 = 0;
    if (!evision_MergeMertens_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::MergeMertens>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::MergeMertens> _self_ = *(self1);
    float saturation_weight=0.f;

    // const char* keywords[] = { "saturation_weight", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "saturation_weight"), saturation_weight, ArgInfo("saturation_weight", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setSaturationWeight(saturation_weight), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "MergeMertens", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (MergeMertens)

template<>
struct Evision_Converter< Ptr<cv::MergeMertens> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::MergeMertens>& r)
    {
        return evision_MergeMertens_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::MergeMertens>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::MergeMertens> * dst_ = nullptr;
        if (evision_MergeMertens_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::MergeMertens> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// MergeRobertson (Generic)
//================================================================================

// GetSet (MergeRobertson)



// Methods (MergeRobertson)

static ERL_NIF_TERM evision_cv_mergeRobertson_process(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::MergeRobertson> * self1 = 0;
    if (!evision_MergeRobertson_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::MergeRobertson>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::MergeRobertson> _self_ = *(self1);

    {
    vector_Mat src;
    Mat dst;
    Mat times;
    Mat response;

    // const char* keywords[] = { "src", "times", "response", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "times"), times, ArgInfo("times", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "response"), response, ArgInfo("response", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->process(src, dst, times, response), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    vector_UMat src;
    UMat dst;
    UMat times;
    UMat response;

    // const char* keywords[] = { "src", "times", "response", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "times"), times, ArgInfo("times", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "response"), response, ArgInfo("response", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->process(src, dst, times, response), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    vector_Mat src;
    Mat dst;
    Mat times;

    // const char* keywords[] = { "src", "times", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "times"), times, ArgInfo("times", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->process(src, dst, times), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    vector_UMat src;
    UMat dst;
    UMat times;

    // const char* keywords[] = { "src", "times", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "times"), times, ArgInfo("times", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->process(src, dst, times), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (MergeRobertson)

template<>
struct Evision_Converter< Ptr<cv::MergeRobertson> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::MergeRobertson>& r)
    {
        return evision_MergeRobertson_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::MergeRobertson>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::MergeRobertson> * dst_ = nullptr;
        if (evision_MergeRobertson_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::MergeRobertson> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// Moments (Map)
//================================================================================
static bool evision_to(ErlNifEnv *env, ERL_NIF_TERM src, cv::Moments& dst, const ArgInfo& info)
{
    ERL_NIF_TERM tmp;
    bool ok;

    if( enif_get_map_value(env, src, evision::nif::atom(env, "m00"), &tmp) )
    {
        ok = evision_to_safe(env, tmp, dst.m00, ArgInfo("m00", false));
        if(!ok) return false;
    }
    if( enif_get_map_value(env, src, evision::nif::atom(env, "m10"), &tmp) )
    {
        ok = evision_to_safe(env, tmp, dst.m10, ArgInfo("m10", false));
        if(!ok) return false;
    }
    if( enif_get_map_value(env, src, evision::nif::atom(env, "m01"), &tmp) )
    {
        ok = evision_to_safe(env, tmp, dst.m01, ArgInfo("m01", false));
        if(!ok) return false;
    }
    if( enif_get_map_value(env, src, evision::nif::atom(env, "m20"), &tmp) )
    {
        ok = evision_to_safe(env, tmp, dst.m20, ArgInfo("m20", false));
        if(!ok) return false;
    }
    if( enif_get_map_value(env, src, evision::nif::atom(env, "m11"), &tmp) )
    {
        ok = evision_to_safe(env, tmp, dst.m11, ArgInfo("m11", false));
        if(!ok) return false;
    }
    if( enif_get_map_value(env, src, evision::nif::atom(env, "m02"), &tmp) )
    {
        ok = evision_to_safe(env, tmp, dst.m02, ArgInfo("m02", false));
        if(!ok) return false;
    }
    if( enif_get_map_value(env, src, evision::nif::atom(env, "m30"), &tmp) )
    {
        ok = evision_to_safe(env, tmp, dst.m30, ArgInfo("m30", false));
        if(!ok) return false;
    }
    if( enif_get_map_value(env, src, evision::nif::atom(env, "m21"), &tmp) )
    {
        ok = evision_to_safe(env, tmp, dst.m21, ArgInfo("m21", false));
        if(!ok) return false;
    }
    if( enif_get_map_value(env, src, evision::nif::atom(env, "m12"), &tmp) )
    {
        ok = evision_to_safe(env, tmp, dst.m12, ArgInfo("m12", false));
        if(!ok) return false;
    }
    if( enif_get_map_value(env, src, evision::nif::atom(env, "m03"), &tmp) )
    {
        ok = evision_to_safe(env, tmp, dst.m03, ArgInfo("m03", false));
        if(!ok) return false;
    }
    if( enif_get_map_value(env, src, evision::nif::atom(env, "mu20"), &tmp) )
    {
        ok = evision_to_safe(env, tmp, dst.mu20, ArgInfo("mu20", false));
        if(!ok) return false;
    }
    if( enif_get_map_value(env, src, evision::nif::atom(env, "mu11"), &tmp) )
    {
        ok = evision_to_safe(env, tmp, dst.mu11, ArgInfo("mu11", false));
        if(!ok) return false;
    }
    if( enif_get_map_value(env, src, evision::nif::atom(env, "mu02"), &tmp) )
    {
        ok = evision_to_safe(env, tmp, dst.mu02, ArgInfo("mu02", false));
        if(!ok) return false;
    }
    if( enif_get_map_value(env, src, evision::nif::atom(env, "mu30"), &tmp) )
    {
        ok = evision_to_safe(env, tmp, dst.mu30, ArgInfo("mu30", false));
        if(!ok) return false;
    }
    if( enif_get_map_value(env, src, evision::nif::atom(env, "mu21"), &tmp) )
    {
        ok = evision_to_safe(env, tmp, dst.mu21, ArgInfo("mu21", false));
        if(!ok) return false;
    }
    if( enif_get_map_value(env, src, evision::nif::atom(env, "mu12"), &tmp) )
    {
        ok = evision_to_safe(env, tmp, dst.mu12, ArgInfo("mu12", false));
        if(!ok) return false;
    }
    if( enif_get_map_value(env, src, evision::nif::atom(env, "mu03"), &tmp) )
    {
        ok = evision_to_safe(env, tmp, dst.mu03, ArgInfo("mu03", false));
        if(!ok) return false;
    }
    if( enif_get_map_value(env, src, evision::nif::atom(env, "nu20"), &tmp) )
    {
        ok = evision_to_safe(env, tmp, dst.nu20, ArgInfo("nu20", false));
        if(!ok) return false;
    }
    if( enif_get_map_value(env, src, evision::nif::atom(env, "nu11"), &tmp) )
    {
        ok = evision_to_safe(env, tmp, dst.nu11, ArgInfo("nu11", false));
        if(!ok) return false;
    }
    if( enif_get_map_value(env, src, evision::nif::atom(env, "nu02"), &tmp) )
    {
        ok = evision_to_safe(env, tmp, dst.nu02, ArgInfo("nu02", false));
        if(!ok) return false;
    }
    if( enif_get_map_value(env, src, evision::nif::atom(env, "nu30"), &tmp) )
    {
        ok = evision_to_safe(env, tmp, dst.nu30, ArgInfo("nu30", false));
        if(!ok) return false;
    }
    if( enif_get_map_value(env, src, evision::nif::atom(env, "nu21"), &tmp) )
    {
        ok = evision_to_safe(env, tmp, dst.nu21, ArgInfo("nu21", false));
        if(!ok) return false;
    }
    if( enif_get_map_value(env, src, evision::nif::atom(env, "nu12"), &tmp) )
    {
        ok = evision_to_safe(env, tmp, dst.nu12, ArgInfo("nu12", false));
        if(!ok) return false;
    }
    if( enif_get_map_value(env, src, evision::nif::atom(env, "nu03"), &tmp) )
    {
        ok = evision_to_safe(env, tmp, dst.nu03, ArgInfo("nu03", false));
        if(!ok) return false;
    }
    return true;
}

template<> bool evision_to(ErlNifEnv *env, ERL_NIF_TERM src, cv::Moments& dst, const ArgInfo& info);

//================================================================================
// ORB (Generic)
//================================================================================

// GetSet (ORB)



// Methods (ORB)

static ERL_NIF_TERM evision_cv_orb_compute(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ORB> * self1 = 0;
    if (!evision_ORB_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ORB>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ORB> _self_ = *(self1);

    {
    Mat image;
    vector_KeyPoint keypoints;
    Mat descriptors;

    // const char* keywords[] = { "image", "keypoints", "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints"), keypoints, ArgInfo("keypoints", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute(image, keypoints, descriptors), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }
    

    {
    UMat image;
    vector_KeyPoint keypoints;
    UMat descriptors;

    // const char* keywords[] = { "image", "keypoints", "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints"), keypoints, ArgInfo("keypoints", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute(image, keypoints, descriptors), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }
    

    {
    vector_Mat images;
    vector_vector_KeyPoint keypoints;
    vector_Mat descriptors;

    // const char* keywords[] = { "images", "keypoints", "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints"), keypoints, ArgInfo("keypoints", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute(images, keypoints, descriptors), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }
    

    {
    vector_UMat images;
    vector_vector_KeyPoint keypoints;
    vector_UMat descriptors;

    // const char* keywords[] = { "images", "keypoints", "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints"), keypoints, ArgInfo("keypoints", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute(images, keypoints, descriptors), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_orb_create_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    int nfeatures=500;
    float scaleFactor=1.2f;
    int nlevels=8;
    int edgeThreshold=31;
    int firstLevel=0;
    int WTA_K=2;
    std::underlying_type_t<ORB_ScoreType> scoreType=static_cast<std::underlying_type_t<ORB_ScoreType>>(ORB::HARRIS_SCORE);
    int patchSize=31;
    int fastThreshold=20;
    Ptr<ORB> retval;

    // const char* keywords[] = { "nfeatures", "scaleFactor", "nlevels", "edgeThreshold", "firstLevel", "WTA_K", "scoreType", "patchSize", "fastThreshold", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "nfeatures"), nfeatures, ArgInfo("nfeatures", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scaleFactor"), scaleFactor, ArgInfo("scaleFactor", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nlevels"), nlevels, ArgInfo("nlevels", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "edgeThreshold"), edgeThreshold, ArgInfo("edgeThreshold", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "firstLevel"), firstLevel, ArgInfo("firstLevel", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "wTA_K"), WTA_K, ArgInfo("WTA_K", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scoreType"), scoreType, ArgInfo("scoreType", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "patchSize"), patchSize, ArgInfo("patchSize", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "fastThreshold"), fastThreshold, ArgInfo("fastThreshold", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::ORB::create(nfeatures, scaleFactor, nlevels, edgeThreshold, firstLevel, WTA_K, static_cast<ORB_ScoreType>(scoreType), patchSize, fastThreshold), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_orb_defaultNorm(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ORB> * self1 = 0;
    if (!evision_ORB_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ORB>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ORB> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->defaultNorm(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_orb_descriptorSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ORB> * self1 = 0;
    if (!evision_ORB_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ORB>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ORB> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->descriptorSize(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_orb_descriptorType(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ORB> * self1 = 0;
    if (!evision_ORB_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ORB>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ORB> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->descriptorType(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_orb_detect(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ORB> * self1 = 0;
    if (!evision_ORB_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ORB>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ORB> _self_ = *(self1);

    {
    Mat image;
    vector_KeyPoint keypoints;
    Mat mask;

    // const char* keywords[] = { "image", "mask", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(image, keypoints, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, keypoints);
        }
    }

    }
    

    {
    UMat image;
    vector_KeyPoint keypoints;
    UMat mask;

    // const char* keywords[] = { "image", "mask", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(image, keypoints, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, keypoints);
        }
    }

    }
    

    {
    vector_Mat images;
    vector_vector_KeyPoint keypoints;
    vector_Mat masks;

    // const char* keywords[] = { "images", "masks", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "masks"), masks, ArgInfo("masks", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(images, keypoints, masks), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, keypoints);
        }
    }

    }
    

    {
    vector_UMat images;
    vector_vector_KeyPoint keypoints;
    vector_UMat masks;

    // const char* keywords[] = { "images", "masks", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "masks"), masks, ArgInfo("masks", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(images, keypoints, masks), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, keypoints);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_orb_detectAndCompute(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ORB> * self1 = 0;
    if (!evision_ORB_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ORB>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ORB> _self_ = *(self1);

    {
    Mat image;
    Mat mask;
    vector_KeyPoint keypoints;
    Mat descriptors;
    bool useProvidedKeypoints=false;

    // const char* keywords[] = { "image", "mask", "descriptors", "useProvidedKeypoints", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "useProvidedKeypoints"), useProvidedKeypoints, ArgInfo("useProvidedKeypoints", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detectAndCompute(image, mask, keypoints, descriptors, useProvidedKeypoints), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }
    

    {
    UMat image;
    UMat mask;
    vector_KeyPoint keypoints;
    UMat descriptors;
    bool useProvidedKeypoints=false;

    // const char* keywords[] = { "image", "mask", "descriptors", "useProvidedKeypoints", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "useProvidedKeypoints"), useProvidedKeypoints, ArgInfo("useProvidedKeypoints", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detectAndCompute(image, mask, keypoints, descriptors, useProvidedKeypoints), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_orb_empty(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ORB> * self1 = 0;
    if (!evision_ORB_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ORB>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ORB> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->empty(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_orb_getDefaultName(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ORB> * self1 = 0;
    if (!evision_ORB_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ORB>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ORB> _self_ = *(self1);
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getDefaultName(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_orb_getEdgeThreshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ORB> * self1 = 0;
    if (!evision_ORB_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ORB>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ORB> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getEdgeThreshold(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_orb_getFastThreshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ORB> * self1 = 0;
    if (!evision_ORB_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ORB>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ORB> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getFastThreshold(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_orb_getFirstLevel(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ORB> * self1 = 0;
    if (!evision_ORB_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ORB>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ORB> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getFirstLevel(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_orb_getMaxFeatures(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ORB> * self1 = 0;
    if (!evision_ORB_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ORB>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ORB> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getMaxFeatures(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_orb_getNLevels(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ORB> * self1 = 0;
    if (!evision_ORB_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ORB>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ORB> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getNLevels(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_orb_getPatchSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ORB> * self1 = 0;
    if (!evision_ORB_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ORB>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ORB> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getPatchSize(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_orb_getScaleFactor(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ORB> * self1 = 0;
    if (!evision_ORB_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ORB>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ORB> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getScaleFactor(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_orb_getScoreType(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ORB> * self1 = 0;
    if (!evision_ORB_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ORB>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ORB> _self_ = *(self1);
    ORB::ScoreType retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getScoreType(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_orb_getWTA_K(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ORB> * self1 = 0;
    if (!evision_ORB_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ORB>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ORB> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getWTA_K(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_orb_read(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ORB> * self1 = 0;
    if (!evision_ORB_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ORB>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ORB> _self_ = *(self1);

    {
    String fileName;

    // const char* keywords[] = { "fileName", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fileName"), fileName, ArgInfo("fileName", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->read(fileName), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ORB", success);
        }
    }

    }
    

    {
    FileNode arg1;

    // const char* keywords[] = { "arg1", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "arg1"), arg1, ArgInfo("arg1", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->read(arg1), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ORB", success);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_orb_setEdgeThreshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ORB> * self1 = 0;
    if (!evision_ORB_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ORB>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ORB> _self_ = *(self1);
    int edgeThreshold=0;

    // const char* keywords[] = { "edgeThreshold", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "edgeThreshold"), edgeThreshold, ArgInfo("edgeThreshold", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setEdgeThreshold(edgeThreshold), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ORB", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_orb_setFastThreshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ORB> * self1 = 0;
    if (!evision_ORB_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ORB>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ORB> _self_ = *(self1);
    int fastThreshold=0;

    // const char* keywords[] = { "fastThreshold", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fastThreshold"), fastThreshold, ArgInfo("fastThreshold", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setFastThreshold(fastThreshold), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ORB", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_orb_setFirstLevel(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ORB> * self1 = 0;
    if (!evision_ORB_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ORB>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ORB> _self_ = *(self1);
    int firstLevel=0;

    // const char* keywords[] = { "firstLevel", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "firstLevel"), firstLevel, ArgInfo("firstLevel", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setFirstLevel(firstLevel), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ORB", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_orb_setMaxFeatures(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ORB> * self1 = 0;
    if (!evision_ORB_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ORB>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ORB> _self_ = *(self1);
    int maxFeatures=0;

    // const char* keywords[] = { "maxFeatures", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "maxFeatures"), maxFeatures, ArgInfo("maxFeatures", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setMaxFeatures(maxFeatures), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ORB", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_orb_setNLevels(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ORB> * self1 = 0;
    if (!evision_ORB_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ORB>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ORB> _self_ = *(self1);
    int nlevels=0;

    // const char* keywords[] = { "nlevels", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "nlevels"), nlevels, ArgInfo("nlevels", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setNLevels(nlevels), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ORB", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_orb_setPatchSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ORB> * self1 = 0;
    if (!evision_ORB_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ORB>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ORB> _self_ = *(self1);
    int patchSize=0;

    // const char* keywords[] = { "patchSize", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "patchSize"), patchSize, ArgInfo("patchSize", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setPatchSize(patchSize), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ORB", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_orb_setScaleFactor(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ORB> * self1 = 0;
    if (!evision_ORB_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ORB>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ORB> _self_ = *(self1);
    double scaleFactor=0;

    // const char* keywords[] = { "scaleFactor", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "scaleFactor"), scaleFactor, ArgInfo("scaleFactor", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setScaleFactor(scaleFactor), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ORB", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_orb_setScoreType(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ORB> * self1 = 0;
    if (!evision_ORB_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ORB>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ORB> _self_ = *(self1);
    std::underlying_type_t<ORB_ScoreType> scoreType=static_cast<std::underlying_type_t<ORB_ScoreType>>(static_cast<ORB_ScoreType>(0));

    // const char* keywords[] = { "scoreType", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "scoreType"), scoreType, ArgInfo("scoreType", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setScoreType(static_cast<ORB_ScoreType>(scoreType)), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ORB", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_orb_setWTA_K(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ORB> * self1 = 0;
    if (!evision_ORB_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ORB>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ORB> _self_ = *(self1);
    int wta_k=0;

    // const char* keywords[] = { "wta_k", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "wta_k"), wta_k, ArgInfo("wta_k", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setWTA_K(wta_k), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ORB", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_orb_write(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ORB> * self1 = 0;
    if (!evision_ORB_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ORB>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ORB> _self_ = *(self1);

    {
    String fileName;

    // const char* keywords[] = { "fileName", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fileName"), fileName, ArgInfo("fileName", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->write(fileName), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ORB", success);
        }
    }

    }
    

    {
    Ptr<FileStorage> fs;
    String name;

    // const char* keywords[] = { "fs", "name", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fs"), fs, ArgInfo("fs", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "name"), name, ArgInfo("name", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->write(fs, name), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ORB", success);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (ORB)

template<>
struct Evision_Converter< Ptr<cv::ORB> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::ORB>& r)
    {
        return evision_ORB_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::ORB>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::ORB> * dst_ = nullptr;
        if (evision_ORB_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::ORB> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// PyRotationWarper (Generic)
//================================================================================

// GetSet (PyRotationWarper)



// Methods (PyRotationWarper)

static ERL_NIF_TERM evision_cv_pyRotationWarper_PyRotationWarper(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    {
    String type;
    float scale=0.f;

    // const char* keywords[] = { "type", "scale", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "type"), type, ArgInfo("type", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scale"), scale, ArgInfo("scale", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::PyRotationWarper>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::PyRotationWarper>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::PyRotationWarper(type, scale)), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::PyRotationWarper>>(env, self->val, ret, "PyRotationWarper", success);;
        }
    }

    }
    

    {

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        evision_res<Ptr<cv::PyRotationWarper>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::PyRotationWarper>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::PyRotationWarper()), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::PyRotationWarper>>(env, self->val, ret, "PyRotationWarper", success);;
        }
    }

    }

    return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_pyRotationWarper_buildMaps(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::PyRotationWarper> * self1 = 0;
    if (!evision_PyRotationWarper_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::PyRotationWarper>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::PyRotationWarper> _self_ = *(self1);

    {
    Size src_size;
    Mat K;
    Mat R;
    Mat xmap;
    Mat ymap;
    Rect retval;

    // const char* keywords[] = { "src_size", "K", "R", "xmap", "ymap", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "src_size"), src_size, ArgInfo("src_size", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), K, ArgInfo("K", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), R, ArgInfo("R", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "xmap"), xmap, ArgInfo("xmap", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ymap"), ymap, ArgInfo("ymap", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->buildMaps(src_size, K, R, xmap, ymap), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, retval), evision_from(env, xmap), evision_from(env, ymap));
        }
    }

    }
    

    {
    Size src_size;
    UMat K;
    UMat R;
    UMat xmap;
    UMat ymap;
    Rect retval;

    // const char* keywords[] = { "src_size", "K", "R", "xmap", "ymap", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "src_size"), src_size, ArgInfo("src_size", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), K, ArgInfo("K", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), R, ArgInfo("R", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "xmap"), xmap, ArgInfo("xmap", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ymap"), ymap, ArgInfo("ymap", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->buildMaps(src_size, K, R, xmap, ymap), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, retval), evision_from(env, xmap), evision_from(env, ymap));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_pyRotationWarper_getScale(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::PyRotationWarper> * self1 = 0;
    if (!evision_PyRotationWarper_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::PyRotationWarper>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::PyRotationWarper> _self_ = *(self1);
    float retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getScale(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_pyRotationWarper_setScale(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::PyRotationWarper> * self1 = 0;
    if (!evision_PyRotationWarper_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::PyRotationWarper>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::PyRotationWarper> _self_ = *(self1);
    float arg1=0.f;

    // const char* keywords[] = { "arg1", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "arg1"), arg1, ArgInfo("arg1", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setScale(arg1), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "PyRotationWarper", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_pyRotationWarper_warp(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::PyRotationWarper> * self1 = 0;
    if (!evision_PyRotationWarper_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::PyRotationWarper>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::PyRotationWarper> _self_ = *(self1);

    {
    Mat src;
    Mat K;
    Mat R;
    int interp_mode=0;
    int border_mode=0;
    Mat dst;
    Point retval;

    // const char* keywords[] = { "src", "K", "R", "interp_mode", "border_mode", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), K, ArgInfo("K", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), R, ArgInfo("R", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "interp_mode"), interp_mode, ArgInfo("interp_mode", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "border_mode"), border_mode, ArgInfo("border_mode", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->warp(src, K, R, interp_mode, border_mode, dst), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, dst));
        }
    }

    }
    

    {
    UMat src;
    UMat K;
    UMat R;
    int interp_mode=0;
    int border_mode=0;
    UMat dst;
    Point retval;

    // const char* keywords[] = { "src", "K", "R", "interp_mode", "border_mode", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), K, ArgInfo("K", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), R, ArgInfo("R", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "interp_mode"), interp_mode, ArgInfo("interp_mode", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "border_mode"), border_mode, ArgInfo("border_mode", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->warp(src, K, R, interp_mode, border_mode, dst), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, dst));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_pyRotationWarper_warpBackward(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::PyRotationWarper> * self1 = 0;
    if (!evision_PyRotationWarper_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::PyRotationWarper>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::PyRotationWarper> _self_ = *(self1);

    {
    Mat src;
    Mat K;
    Mat R;
    int interp_mode=0;
    int border_mode=0;
    Size dst_size;
    Mat dst;

    // const char* keywords[] = { "src", "K", "R", "interp_mode", "border_mode", "dst_size", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), K, ArgInfo("K", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), R, ArgInfo("R", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "interp_mode"), interp_mode, ArgInfo("interp_mode", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "border_mode"), border_mode, ArgInfo("border_mode", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst_size"), dst_size, ArgInfo("dst_size", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->warpBackward(src, K, R, interp_mode, border_mode, dst_size, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    UMat src;
    UMat K;
    UMat R;
    int interp_mode=0;
    int border_mode=0;
    Size dst_size;
    UMat dst;

    // const char* keywords[] = { "src", "K", "R", "interp_mode", "border_mode", "dst_size", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), K, ArgInfo("K", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), R, ArgInfo("R", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "interp_mode"), interp_mode, ArgInfo("interp_mode", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "border_mode"), border_mode, ArgInfo("border_mode", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst_size"), dst_size, ArgInfo("dst_size", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->warpBackward(src, K, R, interp_mode, border_mode, dst_size, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_pyRotationWarper_warpPoint(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::PyRotationWarper> * self1 = 0;
    if (!evision_PyRotationWarper_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::PyRotationWarper>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::PyRotationWarper> _self_ = *(self1);

    {
    Point2f pt;
    Mat K;
    Mat R;
    Point2f retval;

    // const char* keywords[] = { "pt", "K", "R", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "pt"), pt, ArgInfo("pt", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), K, ArgInfo("K", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), R, ArgInfo("R", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->warpPoint(pt, K, R), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Point2f pt;
    UMat K;
    UMat R;
    Point2f retval;

    // const char* keywords[] = { "pt", "K", "R", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "pt"), pt, ArgInfo("pt", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), K, ArgInfo("K", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), R, ArgInfo("R", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->warpPoint(pt, K, R), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_pyRotationWarper_warpPointBackward(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::PyRotationWarper> * self1 = 0;
    if (!evision_PyRotationWarper_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::PyRotationWarper>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::PyRotationWarper> _self_ = *(self1);

    {
    Point2f pt;
    Mat K;
    Mat R;
    Point2f retval;

    // const char* keywords[] = { "pt", "K", "R", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "pt"), pt, ArgInfo("pt", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), K, ArgInfo("K", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), R, ArgInfo("R", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->warpPointBackward(pt, K, R), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Point2f pt;
    UMat K;
    UMat R;
    Point2f retval;

    // const char* keywords[] = { "pt", "K", "R", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "pt"), pt, ArgInfo("pt", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), K, ArgInfo("K", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), R, ArgInfo("R", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->warpPointBackward(pt, K, R), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Point2f pt;
    Mat K;
    Mat R;
    Point2f retval;

    // const char* keywords[] = { "pt", "K", "R", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "pt"), pt, ArgInfo("pt", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), K, ArgInfo("K", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), R, ArgInfo("R", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->warpPointBackward(pt, K, R), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Point2f pt;
    UMat K;
    UMat R;
    Point2f retval;

    // const char* keywords[] = { "pt", "K", "R", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "pt"), pt, ArgInfo("pt", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), K, ArgInfo("K", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), R, ArgInfo("R", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->warpPointBackward(pt, K, R), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_pyRotationWarper_warpRoi(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::PyRotationWarper> * self1 = 0;
    if (!evision_PyRotationWarper_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::PyRotationWarper>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::PyRotationWarper> _self_ = *(self1);

    {
    Size src_size;
    Mat K;
    Mat R;
    Rect retval;

    // const char* keywords[] = { "src_size", "K", "R", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "src_size"), src_size, ArgInfo("src_size", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), K, ArgInfo("K", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), R, ArgInfo("R", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->warpRoi(src_size, K, R), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Size src_size;
    UMat K;
    UMat R;
    Rect retval;

    // const char* keywords[] = { "src_size", "K", "R", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "src_size"), src_size, ArgInfo("src_size", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), K, ArgInfo("K", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), R, ArgInfo("R", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->warpRoi(src_size, K, R), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (PyRotationWarper)

template<>
struct Evision_Converter< Ptr<cv::PyRotationWarper> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::PyRotationWarper>& r)
    {
        return evision_PyRotationWarper_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::PyRotationWarper>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::PyRotationWarper> * dst_ = nullptr;
        if (evision_PyRotationWarper_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::PyRotationWarper> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// QRCodeDetector (Generic)
//================================================================================

// GetSet (QRCodeDetector)



// Methods (QRCodeDetector)

static ERL_NIF_TERM evision_cv_qrCodeDetector_QRCodeDetector(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        evision_res<Ptr<cv::QRCodeDetector>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::QRCodeDetector>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::QRCodeDetector()), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::QRCodeDetector>>(env, self->val, ret, "QRCodeDetector", success);;
        }
    }

    return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_qrCodeDetector_decode(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::QRCodeDetector> * self1 = 0;
    if (!evision_QRCodeDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::QRCodeDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::QRCodeDetector> _self_ = *(self1);

    {
    Mat img;
    Mat points;
    Mat straight_qrcode;
    std::string retval;

    // const char* keywords[] = { "img", "points", "straight_qrcode", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points"), points, ArgInfo("points", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "straight_qrcode"), straight_qrcode, ArgInfo("straight_qrcode", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->decode(img, points, straight_qrcode), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, straight_qrcode));
        }
    }

    }
    

    {
    UMat img;
    UMat points;
    UMat straight_qrcode;
    std::string retval;

    // const char* keywords[] = { "img", "points", "straight_qrcode", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points"), points, ArgInfo("points", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "straight_qrcode"), straight_qrcode, ArgInfo("straight_qrcode", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->decode(img, points, straight_qrcode), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, straight_qrcode));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_qrCodeDetector_decodeCurved(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::QRCodeDetector> * self1 = 0;
    if (!evision_QRCodeDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::QRCodeDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::QRCodeDetector> _self_ = *(self1);

    {
    Mat img;
    Mat points;
    Mat straight_qrcode;
    cv::String retval;

    // const char* keywords[] = { "img", "points", "straight_qrcode", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points"), points, ArgInfo("points", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "straight_qrcode"), straight_qrcode, ArgInfo("straight_qrcode", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->decodeCurved(img, points, straight_qrcode), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, straight_qrcode));
        }
    }

    }
    

    {
    UMat img;
    UMat points;
    UMat straight_qrcode;
    cv::String retval;

    // const char* keywords[] = { "img", "points", "straight_qrcode", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points"), points, ArgInfo("points", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "straight_qrcode"), straight_qrcode, ArgInfo("straight_qrcode", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->decodeCurved(img, points, straight_qrcode), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, straight_qrcode));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_qrCodeDetector_decodeMulti(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::QRCodeDetector> * self1 = 0;
    if (!evision_QRCodeDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::QRCodeDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::QRCodeDetector> _self_ = *(self1);

    {
    Mat img;
    Mat points;
    vector_string decoded_info;
    vector_Mat straight_qrcode;
    bool retval;

    // const char* keywords[] = { "img", "points", "straight_qrcode", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points"), points, ArgInfo("points", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "straight_qrcode"), straight_qrcode, ArgInfo("straight_qrcode", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->decodeMulti(img, points, decoded_info, straight_qrcode), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_2_to_10_tuple_except_bool
                return enif_make_tuple2(env, evision_from(env, decoded_info), evision_from(env, straight_qrcode));
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    UMat img;
    UMat points;
    vector_string decoded_info;
    vector_UMat straight_qrcode;
    bool retval;

    // const char* keywords[] = { "img", "points", "straight_qrcode", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points"), points, ArgInfo("points", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "straight_qrcode"), straight_qrcode, ArgInfo("straight_qrcode", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->decodeMulti(img, points, decoded_info, straight_qrcode), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_2_to_10_tuple_except_bool
                return enif_make_tuple2(env, evision_from(env, decoded_info), evision_from(env, straight_qrcode));
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_qrCodeDetector_detect(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::QRCodeDetector> * self1 = 0;
    if (!evision_QRCodeDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::QRCodeDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::QRCodeDetector> _self_ = *(self1);

    {
    Mat img;
    Mat points;
    bool retval;

    // const char* keywords[] = { "img", "points", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points"), points, ArgInfo("points", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->detect(img, points), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_1_tuple_except_bool
                return evision_from(env, points);
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    UMat img;
    UMat points;
    bool retval;

    // const char* keywords[] = { "img", "points", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points"), points, ArgInfo("points", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->detect(img, points), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_1_tuple_except_bool
                return evision_from(env, points);
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_qrCodeDetector_detectAndDecode(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::QRCodeDetector> * self1 = 0;
    if (!evision_QRCodeDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::QRCodeDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::QRCodeDetector> _self_ = *(self1);

    {
    Mat img;
    Mat points;
    Mat straight_qrcode;
    std::string retval;

    // const char* keywords[] = { "img", "points", "straight_qrcode", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points"), points, ArgInfo("points", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "straight_qrcode"), straight_qrcode, ArgInfo("straight_qrcode", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->detectAndDecode(img, points, straight_qrcode), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, retval), evision_from(env, points), evision_from(env, straight_qrcode));
        }
    }

    }
    

    {
    UMat img;
    UMat points;
    UMat straight_qrcode;
    std::string retval;

    // const char* keywords[] = { "img", "points", "straight_qrcode", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points"), points, ArgInfo("points", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "straight_qrcode"), straight_qrcode, ArgInfo("straight_qrcode", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->detectAndDecode(img, points, straight_qrcode), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, retval), evision_from(env, points), evision_from(env, straight_qrcode));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_qrCodeDetector_detectAndDecodeCurved(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::QRCodeDetector> * self1 = 0;
    if (!evision_QRCodeDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::QRCodeDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::QRCodeDetector> _self_ = *(self1);

    {
    Mat img;
    Mat points;
    Mat straight_qrcode;
    std::string retval;

    // const char* keywords[] = { "img", "points", "straight_qrcode", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points"), points, ArgInfo("points", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "straight_qrcode"), straight_qrcode, ArgInfo("straight_qrcode", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->detectAndDecodeCurved(img, points, straight_qrcode), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, retval), evision_from(env, points), evision_from(env, straight_qrcode));
        }
    }

    }
    

    {
    UMat img;
    UMat points;
    UMat straight_qrcode;
    std::string retval;

    // const char* keywords[] = { "img", "points", "straight_qrcode", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points"), points, ArgInfo("points", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "straight_qrcode"), straight_qrcode, ArgInfo("straight_qrcode", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->detectAndDecodeCurved(img, points, straight_qrcode), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, retval), evision_from(env, points), evision_from(env, straight_qrcode));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_qrCodeDetector_detectAndDecodeMulti(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::QRCodeDetector> * self1 = 0;
    if (!evision_QRCodeDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::QRCodeDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::QRCodeDetector> _self_ = *(self1);

    {
    Mat img;
    vector_string decoded_info;
    Mat points;
    vector_Mat straight_qrcode;
    bool retval;

    // const char* keywords[] = { "img", "points", "straight_qrcode", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points"), points, ArgInfo("points", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "straight_qrcode"), straight_qrcode, ArgInfo("straight_qrcode", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->detectAndDecodeMulti(img, decoded_info, points, straight_qrcode), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_2_to_10_tuple_except_bool
                return enif_make_tuple3(env, evision_from(env, decoded_info), evision_from(env, points), evision_from(env, straight_qrcode));
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    UMat img;
    vector_string decoded_info;
    UMat points;
    vector_UMat straight_qrcode;
    bool retval;

    // const char* keywords[] = { "img", "points", "straight_qrcode", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points"), points, ArgInfo("points", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "straight_qrcode"), straight_qrcode, ArgInfo("straight_qrcode", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->detectAndDecodeMulti(img, decoded_info, points, straight_qrcode), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_2_to_10_tuple_except_bool
                return enif_make_tuple3(env, evision_from(env, decoded_info), evision_from(env, points), evision_from(env, straight_qrcode));
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_qrCodeDetector_detectMulti(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::QRCodeDetector> * self1 = 0;
    if (!evision_QRCodeDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::QRCodeDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::QRCodeDetector> _self_ = *(self1);

    {
    Mat img;
    Mat points;
    bool retval;

    // const char* keywords[] = { "img", "points", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points"), points, ArgInfo("points", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->detectMulti(img, points), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_1_tuple_except_bool
                return evision_from(env, points);
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    UMat img;
    UMat points;
    bool retval;

    // const char* keywords[] = { "img", "points", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points"), points, ArgInfo("points", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->detectMulti(img, points), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_1_tuple_except_bool
                return evision_from(env, points);
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_qrCodeDetector_setEpsX(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::QRCodeDetector> * self1 = 0;
    if (!evision_QRCodeDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::QRCodeDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::QRCodeDetector> _self_ = *(self1);
    double epsX=0;

    // const char* keywords[] = { "epsX", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "epsX"), epsX, ArgInfo("epsX", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setEpsX(epsX), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "QRCodeDetector", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_qrCodeDetector_setEpsY(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::QRCodeDetector> * self1 = 0;
    if (!evision_QRCodeDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::QRCodeDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::QRCodeDetector> _self_ = *(self1);
    double epsY=0;

    // const char* keywords[] = { "epsY", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "epsY"), epsY, ArgInfo("epsY", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setEpsY(epsY), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "QRCodeDetector", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (QRCodeDetector)

template<>
struct Evision_Converter< Ptr<cv::QRCodeDetector> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::QRCodeDetector>& r)
    {
        return evision_QRCodeDetector_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::QRCodeDetector>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::QRCodeDetector> * dst_ = nullptr;
        if (evision_QRCodeDetector_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::QRCodeDetector> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// QRCodeEncoder (Generic)
//================================================================================

// GetSet (QRCodeEncoder)



// Methods (QRCodeEncoder)

static ERL_NIF_TERM evision_cv_qrCodeEncoder_create_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    QRCodeEncoder::Params parameters=QRCodeEncoder::Params();
    Ptr<QRCodeEncoder> retval;

    // const char* keywords[] = { "parameters", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "parameters"), parameters, ArgInfo("parameters", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::QRCodeEncoder::create(parameters), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_qrCodeEncoder_encode(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::QRCodeEncoder> * self1 = 0;
    if (!evision_QRCodeEncoder_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::QRCodeEncoder>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::QRCodeEncoder> _self_ = *(self1);

    {
    String encoded_info;
    Mat qrcode;

    // const char* keywords[] = { "encoded_info", "qrcode", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "encoded_info"), encoded_info, ArgInfo("encoded_info", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "qrcode"), qrcode, ArgInfo("qrcode", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->encode(encoded_info, qrcode), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, qrcode);
        }
    }

    }
    

    {
    String encoded_info;
    UMat qrcode;

    // const char* keywords[] = { "encoded_info", "qrcode", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "encoded_info"), encoded_info, ArgInfo("encoded_info", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "qrcode"), qrcode, ArgInfo("qrcode", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->encode(encoded_info, qrcode), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, qrcode);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_qrCodeEncoder_encodeStructuredAppend(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::QRCodeEncoder> * self1 = 0;
    if (!evision_QRCodeEncoder_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::QRCodeEncoder>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::QRCodeEncoder> _self_ = *(self1);

    {
    String encoded_info;
    vector_Mat qrcodes;

    // const char* keywords[] = { "encoded_info", "qrcodes", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "encoded_info"), encoded_info, ArgInfo("encoded_info", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "qrcodes"), qrcodes, ArgInfo("qrcodes", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->encodeStructuredAppend(encoded_info, qrcodes), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, qrcodes);
        }
    }

    }
    

    {
    String encoded_info;
    vector_UMat qrcodes;

    // const char* keywords[] = { "encoded_info", "qrcodes", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "encoded_info"), encoded_info, ArgInfo("encoded_info", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "qrcodes"), qrcodes, ArgInfo("qrcodes", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->encodeStructuredAppend(encoded_info, qrcodes), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, qrcodes);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (QRCodeEncoder)

template<>
struct Evision_Converter< Ptr<cv::QRCodeEncoder> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::QRCodeEncoder>& r)
    {
        return evision_QRCodeEncoder_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::QRCodeEncoder>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::QRCodeEncoder> * dst_ = nullptr;
        if (evision_QRCodeEncoder_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::QRCodeEncoder> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// QRCodeEncoder_Params (Generic)
//================================================================================

// GetSet (QRCodeEncoder_Params)


static ERL_NIF_TERM evision_QRCodeEncoder_Params_get_correction_level(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::QRCodeEncoder::Params* self_ptr = 0;
    if (!evision_QRCodeEncoder_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::QRCodeEncoder::Params` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->correction_level);
}

static ERL_NIF_TERM evision_QRCodeEncoder_Params_set_correction_level(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::QRCodeEncoder::Params* self_ptr = 0;

    if (!evision_QRCodeEncoder_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::QRCodeEncoder::Params` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->correction_level, ArgInfo("correction_level", false))) {
        bool success;
        return evision_from_as_map<cv::QRCodeEncoder::Params>(env, *self_ptr, self, "\"QRCodeEncoder.Params\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_QRCodeEncoder_Params_get_mode(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::QRCodeEncoder::Params* self_ptr = 0;
    if (!evision_QRCodeEncoder_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::QRCodeEncoder::Params` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->mode);
}

static ERL_NIF_TERM evision_QRCodeEncoder_Params_set_mode(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::QRCodeEncoder::Params* self_ptr = 0;

    if (!evision_QRCodeEncoder_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::QRCodeEncoder::Params` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->mode, ArgInfo("mode", false))) {
        bool success;
        return evision_from_as_map<cv::QRCodeEncoder::Params>(env, *self_ptr, self, "\"QRCodeEncoder.Params\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_QRCodeEncoder_Params_get_structure_number(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::QRCodeEncoder::Params* self_ptr = 0;
    if (!evision_QRCodeEncoder_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::QRCodeEncoder::Params` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->structure_number);
}

static ERL_NIF_TERM evision_QRCodeEncoder_Params_set_structure_number(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::QRCodeEncoder::Params* self_ptr = 0;

    if (!evision_QRCodeEncoder_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::QRCodeEncoder::Params` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->structure_number, ArgInfo("structure_number", false))) {
        bool success;
        return evision_from_as_map<cv::QRCodeEncoder::Params>(env, *self_ptr, self, "\"QRCodeEncoder.Params\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_QRCodeEncoder_Params_get_version(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::QRCodeEncoder::Params* self_ptr = 0;
    if (!evision_QRCodeEncoder_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::QRCodeEncoder::Params` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->version);
}

static ERL_NIF_TERM evision_QRCodeEncoder_Params_set_version(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::QRCodeEncoder::Params* self_ptr = 0;

    if (!evision_QRCodeEncoder_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::QRCodeEncoder::Params` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->version, ArgInfo("version", false))) {
        bool success;
        return evision_from_as_map<cv::QRCodeEncoder::Params>(env, *self_ptr, self, "\"QRCodeEncoder.Params\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}


// Methods (QRCodeEncoder_Params)

static ERL_NIF_TERM evision_cv_qrCodeEncoder_Params_QRCodeEncoder_Params(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        evision_res<cv::QRCodeEncoder::Params> * self = nullptr;
        if (alloc_resource(&self)) ERRWRAP2(new (&(self->val)) cv::QRCodeEncoder::Params(), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<cv::QRCodeEncoder::Params>(env, self->val, ret, "QRCodeEncoder.Params", success);;
        }
    }

    return enif_make_badarg(env);
}



// Converter (QRCodeEncoder_Params)

template<>
struct Evision_Converter< cv::QRCodeEncoder::Params >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const cv::QRCodeEncoder::Params& r)
    {
        return evision_QRCodeEncoder_Params_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, cv::QRCodeEncoder::Params& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        cv::QRCodeEncoder::Params * dst_ = nullptr;
        if (evision_QRCodeEncoder_Params_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected cv::QRCodeEncoder::Params for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// SIFT (Generic)
//================================================================================

// GetSet (SIFT)



// Methods (SIFT)

static ERL_NIF_TERM evision_cv_sift_compute(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::SIFT> * self1 = 0;
    if (!evision_SIFT_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::SIFT>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::SIFT> _self_ = *(self1);

    {
    Mat image;
    vector_KeyPoint keypoints;
    Mat descriptors;

    // const char* keywords[] = { "image", "keypoints", "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints"), keypoints, ArgInfo("keypoints", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute(image, keypoints, descriptors), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }
    

    {
    UMat image;
    vector_KeyPoint keypoints;
    UMat descriptors;

    // const char* keywords[] = { "image", "keypoints", "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints"), keypoints, ArgInfo("keypoints", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute(image, keypoints, descriptors), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }
    

    {
    vector_Mat images;
    vector_vector_KeyPoint keypoints;
    vector_Mat descriptors;

    // const char* keywords[] = { "images", "keypoints", "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints"), keypoints, ArgInfo("keypoints", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute(images, keypoints, descriptors), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }
    

    {
    vector_UMat images;
    vector_vector_KeyPoint keypoints;
    vector_UMat descriptors;

    // const char* keywords[] = { "images", "keypoints", "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints"), keypoints, ArgInfo("keypoints", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute(images, keypoints, descriptors), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_sift_create_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    {
    int nfeatures=0;
    int nOctaveLayers=3;
    double contrastThreshold=0.04;
    double edgeThreshold=10;
    double sigma=1.6;
    Ptr<SIFT> retval;

    // const char* keywords[] = { "nfeatures", "nOctaveLayers", "contrastThreshold", "edgeThreshold", "sigma", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "nfeatures"), nfeatures, ArgInfo("nfeatures", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nOctaveLayers"), nOctaveLayers, ArgInfo("nOctaveLayers", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "contrastThreshold"), contrastThreshold, ArgInfo("contrastThreshold", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "edgeThreshold"), edgeThreshold, ArgInfo("edgeThreshold", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma"), sigma, ArgInfo("sigma", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::SIFT::create(nfeatures, nOctaveLayers, contrastThreshold, edgeThreshold, sigma), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    int nfeatures=0;
    int nOctaveLayers=0;
    double contrastThreshold=0;
    double edgeThreshold=0;
    double sigma=0;
    int descriptorType=0;
    Ptr<SIFT> retval;

    // const char* keywords[] = { "nfeatures", "nOctaveLayers", "contrastThreshold", "edgeThreshold", "sigma", "descriptorType", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "nfeatures"), nfeatures, ArgInfo("nfeatures", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nOctaveLayers"), nOctaveLayers, ArgInfo("nOctaveLayers", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "contrastThreshold"), contrastThreshold, ArgInfo("contrastThreshold", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "edgeThreshold"), edgeThreshold, ArgInfo("edgeThreshold", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma"), sigma, ArgInfo("sigma", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptorType"), descriptorType, ArgInfo("descriptorType", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::SIFT::create(nfeatures, nOctaveLayers, contrastThreshold, edgeThreshold, sigma, descriptorType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_sift_defaultNorm(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::SIFT> * self1 = 0;
    if (!evision_SIFT_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::SIFT>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::SIFT> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->defaultNorm(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_sift_descriptorSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::SIFT> * self1 = 0;
    if (!evision_SIFT_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::SIFT>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::SIFT> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->descriptorSize(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_sift_descriptorType(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::SIFT> * self1 = 0;
    if (!evision_SIFT_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::SIFT>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::SIFT> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->descriptorType(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_sift_detect(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::SIFT> * self1 = 0;
    if (!evision_SIFT_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::SIFT>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::SIFT> _self_ = *(self1);

    {
    Mat image;
    vector_KeyPoint keypoints;
    Mat mask;

    // const char* keywords[] = { "image", "mask", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(image, keypoints, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, keypoints);
        }
    }

    }
    

    {
    UMat image;
    vector_KeyPoint keypoints;
    UMat mask;

    // const char* keywords[] = { "image", "mask", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(image, keypoints, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, keypoints);
        }
    }

    }
    

    {
    vector_Mat images;
    vector_vector_KeyPoint keypoints;
    vector_Mat masks;

    // const char* keywords[] = { "images", "masks", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "masks"), masks, ArgInfo("masks", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(images, keypoints, masks), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, keypoints);
        }
    }

    }
    

    {
    vector_UMat images;
    vector_vector_KeyPoint keypoints;
    vector_UMat masks;

    // const char* keywords[] = { "images", "masks", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "masks"), masks, ArgInfo("masks", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(images, keypoints, masks), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, keypoints);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_sift_detectAndCompute(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::SIFT> * self1 = 0;
    if (!evision_SIFT_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::SIFT>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::SIFT> _self_ = *(self1);

    {
    Mat image;
    Mat mask;
    vector_KeyPoint keypoints;
    Mat descriptors;
    bool useProvidedKeypoints=false;

    // const char* keywords[] = { "image", "mask", "descriptors", "useProvidedKeypoints", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "useProvidedKeypoints"), useProvidedKeypoints, ArgInfo("useProvidedKeypoints", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detectAndCompute(image, mask, keypoints, descriptors, useProvidedKeypoints), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }
    

    {
    UMat image;
    UMat mask;
    vector_KeyPoint keypoints;
    UMat descriptors;
    bool useProvidedKeypoints=false;

    // const char* keywords[] = { "image", "mask", "descriptors", "useProvidedKeypoints", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "useProvidedKeypoints"), useProvidedKeypoints, ArgInfo("useProvidedKeypoints", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detectAndCompute(image, mask, keypoints, descriptors, useProvidedKeypoints), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_sift_empty(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::SIFT> * self1 = 0;
    if (!evision_SIFT_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::SIFT>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::SIFT> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->empty(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_sift_getDefaultName(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::SIFT> * self1 = 0;
    if (!evision_SIFT_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::SIFT>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::SIFT> _self_ = *(self1);
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getDefaultName(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_sift_read(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::SIFT> * self1 = 0;
    if (!evision_SIFT_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::SIFT>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::SIFT> _self_ = *(self1);

    {
    String fileName;

    // const char* keywords[] = { "fileName", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fileName"), fileName, ArgInfo("fileName", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->read(fileName), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "SIFT", success);
        }
    }

    }
    

    {
    FileNode arg1;

    // const char* keywords[] = { "arg1", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "arg1"), arg1, ArgInfo("arg1", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->read(arg1), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "SIFT", success);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_sift_write(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::SIFT> * self1 = 0;
    if (!evision_SIFT_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::SIFT>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::SIFT> _self_ = *(self1);

    {
    String fileName;

    // const char* keywords[] = { "fileName", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fileName"), fileName, ArgInfo("fileName", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->write(fileName), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "SIFT", success);
        }
    }

    }
    

    {
    Ptr<FileStorage> fs;
    String name;

    // const char* keywords[] = { "fs", "name", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fs"), fs, ArgInfo("fs", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "name"), name, ArgInfo("name", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->write(fs, name), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "SIFT", success);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (SIFT)

template<>
struct Evision_Converter< Ptr<cv::SIFT> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::SIFT>& r)
    {
        return evision_SIFT_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::SIFT>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::SIFT> * dst_ = nullptr;
        if (evision_SIFT_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::SIFT> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// SimpleBlobDetector (Generic)
//================================================================================

// GetSet (SimpleBlobDetector)



// Methods (SimpleBlobDetector)

static ERL_NIF_TERM evision_cv_simpleBlobDetector_compute(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::SimpleBlobDetector> * self1 = 0;
    if (!evision_SimpleBlobDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::SimpleBlobDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::SimpleBlobDetector> _self_ = *(self1);

    {
    Mat image;
    vector_KeyPoint keypoints;
    Mat descriptors;

    // const char* keywords[] = { "image", "keypoints", "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints"), keypoints, ArgInfo("keypoints", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute(image, keypoints, descriptors), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }
    

    {
    UMat image;
    vector_KeyPoint keypoints;
    UMat descriptors;

    // const char* keywords[] = { "image", "keypoints", "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints"), keypoints, ArgInfo("keypoints", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute(image, keypoints, descriptors), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }
    

    {
    vector_Mat images;
    vector_vector_KeyPoint keypoints;
    vector_Mat descriptors;

    // const char* keywords[] = { "images", "keypoints", "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints"), keypoints, ArgInfo("keypoints", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute(images, keypoints, descriptors), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }
    

    {
    vector_UMat images;
    vector_vector_KeyPoint keypoints;
    vector_UMat descriptors;

    // const char* keywords[] = { "images", "keypoints", "descriptors", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints"), keypoints, ArgInfo("keypoints", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute(images, keypoints, descriptors), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_simpleBlobDetector_create_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    SimpleBlobDetector_Params parameters=SimpleBlobDetector::Params();
    Ptr<SimpleBlobDetector> retval;

    // const char* keywords[] = { "parameters", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "parameters"), parameters, ArgInfo("parameters", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::SimpleBlobDetector::create(parameters), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_simpleBlobDetector_defaultNorm(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::SimpleBlobDetector> * self1 = 0;
    if (!evision_SimpleBlobDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::SimpleBlobDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::SimpleBlobDetector> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->defaultNorm(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_simpleBlobDetector_descriptorSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::SimpleBlobDetector> * self1 = 0;
    if (!evision_SimpleBlobDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::SimpleBlobDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::SimpleBlobDetector> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->descriptorSize(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_simpleBlobDetector_descriptorType(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::SimpleBlobDetector> * self1 = 0;
    if (!evision_SimpleBlobDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::SimpleBlobDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::SimpleBlobDetector> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->descriptorType(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_simpleBlobDetector_detect(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::SimpleBlobDetector> * self1 = 0;
    if (!evision_SimpleBlobDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::SimpleBlobDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::SimpleBlobDetector> _self_ = *(self1);

    {
    Mat image;
    vector_KeyPoint keypoints;
    Mat mask;

    // const char* keywords[] = { "image", "mask", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(image, keypoints, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, keypoints);
        }
    }

    }
    

    {
    UMat image;
    vector_KeyPoint keypoints;
    UMat mask;

    // const char* keywords[] = { "image", "mask", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(image, keypoints, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, keypoints);
        }
    }

    }
    

    {
    vector_Mat images;
    vector_vector_KeyPoint keypoints;
    vector_Mat masks;

    // const char* keywords[] = { "images", "masks", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "masks"), masks, ArgInfo("masks", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(images, keypoints, masks), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, keypoints);
        }
    }

    }
    

    {
    vector_UMat images;
    vector_vector_KeyPoint keypoints;
    vector_UMat masks;

    // const char* keywords[] = { "images", "masks", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "masks"), masks, ArgInfo("masks", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(images, keypoints, masks), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, keypoints);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_simpleBlobDetector_detectAndCompute(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::SimpleBlobDetector> * self1 = 0;
    if (!evision_SimpleBlobDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::SimpleBlobDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::SimpleBlobDetector> _self_ = *(self1);

    {
    Mat image;
    Mat mask;
    vector_KeyPoint keypoints;
    Mat descriptors;
    bool useProvidedKeypoints=false;

    // const char* keywords[] = { "image", "mask", "descriptors", "useProvidedKeypoints", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "useProvidedKeypoints"), useProvidedKeypoints, ArgInfo("useProvidedKeypoints", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detectAndCompute(image, mask, keypoints, descriptors, useProvidedKeypoints), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }
    

    {
    UMat image;
    UMat mask;
    vector_KeyPoint keypoints;
    UMat descriptors;
    bool useProvidedKeypoints=false;

    // const char* keywords[] = { "image", "mask", "descriptors", "useProvidedKeypoints", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptors"), descriptors, ArgInfo("descriptors", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "useProvidedKeypoints"), useProvidedKeypoints, ArgInfo("useProvidedKeypoints", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detectAndCompute(image, mask, keypoints, descriptors, useProvidedKeypoints), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, keypoints), evision_from(env, descriptors));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_simpleBlobDetector_empty(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::SimpleBlobDetector> * self1 = 0;
    if (!evision_SimpleBlobDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::SimpleBlobDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::SimpleBlobDetector> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->empty(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_simpleBlobDetector_getDefaultName(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::SimpleBlobDetector> * self1 = 0;
    if (!evision_SimpleBlobDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::SimpleBlobDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::SimpleBlobDetector> _self_ = *(self1);
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getDefaultName(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_simpleBlobDetector_read(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::SimpleBlobDetector> * self1 = 0;
    if (!evision_SimpleBlobDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::SimpleBlobDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::SimpleBlobDetector> _self_ = *(self1);

    {
    String fileName;

    // const char* keywords[] = { "fileName", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fileName"), fileName, ArgInfo("fileName", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->read(fileName), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "SimpleBlobDetector", success);
        }
    }

    }
    

    {
    FileNode arg1;

    // const char* keywords[] = { "arg1", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "arg1"), arg1, ArgInfo("arg1", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->read(arg1), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "SimpleBlobDetector", success);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_simpleBlobDetector_write(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::SimpleBlobDetector> * self1 = 0;
    if (!evision_SimpleBlobDetector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::SimpleBlobDetector>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::SimpleBlobDetector> _self_ = *(self1);

    {
    String fileName;

    // const char* keywords[] = { "fileName", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fileName"), fileName, ArgInfo("fileName", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->write(fileName), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "SimpleBlobDetector", success);
        }
    }

    }
    

    {
    Ptr<FileStorage> fs;
    String name;

    // const char* keywords[] = { "fs", "name", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fs"), fs, ArgInfo("fs", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "name"), name, ArgInfo("name", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->write(fs, name), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "SimpleBlobDetector", success);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (SimpleBlobDetector)

template<>
struct Evision_Converter< Ptr<cv::SimpleBlobDetector> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::SimpleBlobDetector>& r)
    {
        return evision_SimpleBlobDetector_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::SimpleBlobDetector>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::SimpleBlobDetector> * dst_ = nullptr;
        if (evision_SimpleBlobDetector_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::SimpleBlobDetector> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// SimpleBlobDetector_Params (Generic)
//================================================================================

// GetSet (SimpleBlobDetector_Params)


static ERL_NIF_TERM evision_SimpleBlobDetector_Params_get_blobColor(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::SimpleBlobDetector::Params* self_ptr = 0;
    if (!evision_SimpleBlobDetector_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::SimpleBlobDetector::Params` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->blobColor);
}

static ERL_NIF_TERM evision_SimpleBlobDetector_Params_set_blobColor(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::SimpleBlobDetector::Params* self_ptr = 0;

    if (!evision_SimpleBlobDetector_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::SimpleBlobDetector::Params` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->blobColor, ArgInfo("blobColor", false))) {
        bool success;
        return evision_from_as_map<cv::SimpleBlobDetector::Params>(env, *self_ptr, self, "\"SimpleBlobDetector.Params\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_SimpleBlobDetector_Params_get_filterByArea(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::SimpleBlobDetector::Params* self_ptr = 0;
    if (!evision_SimpleBlobDetector_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::SimpleBlobDetector::Params` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->filterByArea);
}

static ERL_NIF_TERM evision_SimpleBlobDetector_Params_set_filterByArea(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::SimpleBlobDetector::Params* self_ptr = 0;

    if (!evision_SimpleBlobDetector_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::SimpleBlobDetector::Params` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->filterByArea, ArgInfo("filterByArea", false))) {
        bool success;
        return evision_from_as_map<cv::SimpleBlobDetector::Params>(env, *self_ptr, self, "\"SimpleBlobDetector.Params\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_SimpleBlobDetector_Params_get_filterByCircularity(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::SimpleBlobDetector::Params* self_ptr = 0;
    if (!evision_SimpleBlobDetector_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::SimpleBlobDetector::Params` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->filterByCircularity);
}

static ERL_NIF_TERM evision_SimpleBlobDetector_Params_set_filterByCircularity(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::SimpleBlobDetector::Params* self_ptr = 0;

    if (!evision_SimpleBlobDetector_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::SimpleBlobDetector::Params` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->filterByCircularity, ArgInfo("filterByCircularity", false))) {
        bool success;
        return evision_from_as_map<cv::SimpleBlobDetector::Params>(env, *self_ptr, self, "\"SimpleBlobDetector.Params\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_SimpleBlobDetector_Params_get_filterByColor(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::SimpleBlobDetector::Params* self_ptr = 0;
    if (!evision_SimpleBlobDetector_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::SimpleBlobDetector::Params` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->filterByColor);
}

static ERL_NIF_TERM evision_SimpleBlobDetector_Params_set_filterByColor(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::SimpleBlobDetector::Params* self_ptr = 0;

    if (!evision_SimpleBlobDetector_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::SimpleBlobDetector::Params` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->filterByColor, ArgInfo("filterByColor", false))) {
        bool success;
        return evision_from_as_map<cv::SimpleBlobDetector::Params>(env, *self_ptr, self, "\"SimpleBlobDetector.Params\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_SimpleBlobDetector_Params_get_filterByConvexity(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::SimpleBlobDetector::Params* self_ptr = 0;
    if (!evision_SimpleBlobDetector_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::SimpleBlobDetector::Params` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->filterByConvexity);
}

static ERL_NIF_TERM evision_SimpleBlobDetector_Params_set_filterByConvexity(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::SimpleBlobDetector::Params* self_ptr = 0;

    if (!evision_SimpleBlobDetector_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::SimpleBlobDetector::Params` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->filterByConvexity, ArgInfo("filterByConvexity", false))) {
        bool success;
        return evision_from_as_map<cv::SimpleBlobDetector::Params>(env, *self_ptr, self, "\"SimpleBlobDetector.Params\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_SimpleBlobDetector_Params_get_filterByInertia(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::SimpleBlobDetector::Params* self_ptr = 0;
    if (!evision_SimpleBlobDetector_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::SimpleBlobDetector::Params` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->filterByInertia);
}

static ERL_NIF_TERM evision_SimpleBlobDetector_Params_set_filterByInertia(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::SimpleBlobDetector::Params* self_ptr = 0;

    if (!evision_SimpleBlobDetector_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::SimpleBlobDetector::Params` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->filterByInertia, ArgInfo("filterByInertia", false))) {
        bool success;
        return evision_from_as_map<cv::SimpleBlobDetector::Params>(env, *self_ptr, self, "\"SimpleBlobDetector.Params\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_SimpleBlobDetector_Params_get_maxArea(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::SimpleBlobDetector::Params* self_ptr = 0;
    if (!evision_SimpleBlobDetector_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::SimpleBlobDetector::Params` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->maxArea);
}

static ERL_NIF_TERM evision_SimpleBlobDetector_Params_set_maxArea(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::SimpleBlobDetector::Params* self_ptr = 0;

    if (!evision_SimpleBlobDetector_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::SimpleBlobDetector::Params` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->maxArea, ArgInfo("maxArea", false))) {
        bool success;
        return evision_from_as_map<cv::SimpleBlobDetector::Params>(env, *self_ptr, self, "\"SimpleBlobDetector.Params\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_SimpleBlobDetector_Params_get_maxCircularity(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::SimpleBlobDetector::Params* self_ptr = 0;
    if (!evision_SimpleBlobDetector_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::SimpleBlobDetector::Params` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->maxCircularity);
}

static ERL_NIF_TERM evision_SimpleBlobDetector_Params_set_maxCircularity(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::SimpleBlobDetector::Params* self_ptr = 0;

    if (!evision_SimpleBlobDetector_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::SimpleBlobDetector::Params` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->maxCircularity, ArgInfo("maxCircularity", false))) {
        bool success;
        return evision_from_as_map<cv::SimpleBlobDetector::Params>(env, *self_ptr, self, "\"SimpleBlobDetector.Params\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_SimpleBlobDetector_Params_get_maxConvexity(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::SimpleBlobDetector::Params* self_ptr = 0;
    if (!evision_SimpleBlobDetector_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::SimpleBlobDetector::Params` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->maxConvexity);
}

static ERL_NIF_TERM evision_SimpleBlobDetector_Params_set_maxConvexity(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::SimpleBlobDetector::Params* self_ptr = 0;

    if (!evision_SimpleBlobDetector_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::SimpleBlobDetector::Params` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->maxConvexity, ArgInfo("maxConvexity", false))) {
        bool success;
        return evision_from_as_map<cv::SimpleBlobDetector::Params>(env, *self_ptr, self, "\"SimpleBlobDetector.Params\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_SimpleBlobDetector_Params_get_maxInertiaRatio(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::SimpleBlobDetector::Params* self_ptr = 0;
    if (!evision_SimpleBlobDetector_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::SimpleBlobDetector::Params` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->maxInertiaRatio);
}

static ERL_NIF_TERM evision_SimpleBlobDetector_Params_set_maxInertiaRatio(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::SimpleBlobDetector::Params* self_ptr = 0;

    if (!evision_SimpleBlobDetector_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::SimpleBlobDetector::Params` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->maxInertiaRatio, ArgInfo("maxInertiaRatio", false))) {
        bool success;
        return evision_from_as_map<cv::SimpleBlobDetector::Params>(env, *self_ptr, self, "\"SimpleBlobDetector.Params\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_SimpleBlobDetector_Params_get_maxThreshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::SimpleBlobDetector::Params* self_ptr = 0;
    if (!evision_SimpleBlobDetector_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::SimpleBlobDetector::Params` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->maxThreshold);
}

static ERL_NIF_TERM evision_SimpleBlobDetector_Params_set_maxThreshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::SimpleBlobDetector::Params* self_ptr = 0;

    if (!evision_SimpleBlobDetector_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::SimpleBlobDetector::Params` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->maxThreshold, ArgInfo("maxThreshold", false))) {
        bool success;
        return evision_from_as_map<cv::SimpleBlobDetector::Params>(env, *self_ptr, self, "\"SimpleBlobDetector.Params\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_SimpleBlobDetector_Params_get_minArea(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::SimpleBlobDetector::Params* self_ptr = 0;
    if (!evision_SimpleBlobDetector_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::SimpleBlobDetector::Params` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->minArea);
}

static ERL_NIF_TERM evision_SimpleBlobDetector_Params_set_minArea(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::SimpleBlobDetector::Params* self_ptr = 0;

    if (!evision_SimpleBlobDetector_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::SimpleBlobDetector::Params` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->minArea, ArgInfo("minArea", false))) {
        bool success;
        return evision_from_as_map<cv::SimpleBlobDetector::Params>(env, *self_ptr, self, "\"SimpleBlobDetector.Params\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_SimpleBlobDetector_Params_get_minCircularity(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::SimpleBlobDetector::Params* self_ptr = 0;
    if (!evision_SimpleBlobDetector_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::SimpleBlobDetector::Params` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->minCircularity);
}

static ERL_NIF_TERM evision_SimpleBlobDetector_Params_set_minCircularity(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::SimpleBlobDetector::Params* self_ptr = 0;

    if (!evision_SimpleBlobDetector_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::SimpleBlobDetector::Params` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->minCircularity, ArgInfo("minCircularity", false))) {
        bool success;
        return evision_from_as_map<cv::SimpleBlobDetector::Params>(env, *self_ptr, self, "\"SimpleBlobDetector.Params\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_SimpleBlobDetector_Params_get_minConvexity(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::SimpleBlobDetector::Params* self_ptr = 0;
    if (!evision_SimpleBlobDetector_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::SimpleBlobDetector::Params` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->minConvexity);
}

static ERL_NIF_TERM evision_SimpleBlobDetector_Params_set_minConvexity(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::SimpleBlobDetector::Params* self_ptr = 0;

    if (!evision_SimpleBlobDetector_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::SimpleBlobDetector::Params` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->minConvexity, ArgInfo("minConvexity", false))) {
        bool success;
        return evision_from_as_map<cv::SimpleBlobDetector::Params>(env, *self_ptr, self, "\"SimpleBlobDetector.Params\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_SimpleBlobDetector_Params_get_minDistBetweenBlobs(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::SimpleBlobDetector::Params* self_ptr = 0;
    if (!evision_SimpleBlobDetector_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::SimpleBlobDetector::Params` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->minDistBetweenBlobs);
}

static ERL_NIF_TERM evision_SimpleBlobDetector_Params_set_minDistBetweenBlobs(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::SimpleBlobDetector::Params* self_ptr = 0;

    if (!evision_SimpleBlobDetector_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::SimpleBlobDetector::Params` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->minDistBetweenBlobs, ArgInfo("minDistBetweenBlobs", false))) {
        bool success;
        return evision_from_as_map<cv::SimpleBlobDetector::Params>(env, *self_ptr, self, "\"SimpleBlobDetector.Params\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_SimpleBlobDetector_Params_get_minInertiaRatio(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::SimpleBlobDetector::Params* self_ptr = 0;
    if (!evision_SimpleBlobDetector_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::SimpleBlobDetector::Params` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->minInertiaRatio);
}

static ERL_NIF_TERM evision_SimpleBlobDetector_Params_set_minInertiaRatio(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::SimpleBlobDetector::Params* self_ptr = 0;

    if (!evision_SimpleBlobDetector_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::SimpleBlobDetector::Params` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->minInertiaRatio, ArgInfo("minInertiaRatio", false))) {
        bool success;
        return evision_from_as_map<cv::SimpleBlobDetector::Params>(env, *self_ptr, self, "\"SimpleBlobDetector.Params\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_SimpleBlobDetector_Params_get_minRepeatability(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::SimpleBlobDetector::Params* self_ptr = 0;
    if (!evision_SimpleBlobDetector_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::SimpleBlobDetector::Params` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->minRepeatability);
}

static ERL_NIF_TERM evision_SimpleBlobDetector_Params_set_minRepeatability(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::SimpleBlobDetector::Params* self_ptr = 0;

    if (!evision_SimpleBlobDetector_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::SimpleBlobDetector::Params` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->minRepeatability, ArgInfo("minRepeatability", false))) {
        bool success;
        return evision_from_as_map<cv::SimpleBlobDetector::Params>(env, *self_ptr, self, "\"SimpleBlobDetector.Params\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_SimpleBlobDetector_Params_get_minThreshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::SimpleBlobDetector::Params* self_ptr = 0;
    if (!evision_SimpleBlobDetector_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::SimpleBlobDetector::Params` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->minThreshold);
}

static ERL_NIF_TERM evision_SimpleBlobDetector_Params_set_minThreshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::SimpleBlobDetector::Params* self_ptr = 0;

    if (!evision_SimpleBlobDetector_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::SimpleBlobDetector::Params` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->minThreshold, ArgInfo("minThreshold", false))) {
        bool success;
        return evision_from_as_map<cv::SimpleBlobDetector::Params>(env, *self_ptr, self, "\"SimpleBlobDetector.Params\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_SimpleBlobDetector_Params_get_thresholdStep(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::SimpleBlobDetector::Params* self_ptr = 0;
    if (!evision_SimpleBlobDetector_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::SimpleBlobDetector::Params` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->thresholdStep);
}

static ERL_NIF_TERM evision_SimpleBlobDetector_Params_set_thresholdStep(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::SimpleBlobDetector::Params* self_ptr = 0;

    if (!evision_SimpleBlobDetector_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::SimpleBlobDetector::Params` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->thresholdStep, ArgInfo("thresholdStep", false))) {
        bool success;
        return evision_from_as_map<cv::SimpleBlobDetector::Params>(env, *self_ptr, self, "\"SimpleBlobDetector.Params\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}


// Methods (SimpleBlobDetector_Params)

static ERL_NIF_TERM evision_cv_simpleBlobDetector_Params_SimpleBlobDetector_Params(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        evision_res<cv::SimpleBlobDetector::Params> * self = nullptr;
        if (alloc_resource(&self)) ERRWRAP2(new (&(self->val)) cv::SimpleBlobDetector::Params(), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<cv::SimpleBlobDetector::Params>(env, self->val, ret, "SimpleBlobDetector.Params", success);;
        }
    }

    return enif_make_badarg(env);
}



// Converter (SimpleBlobDetector_Params)

template<>
struct Evision_Converter< cv::SimpleBlobDetector::Params >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const cv::SimpleBlobDetector::Params& r)
    {
        return evision_SimpleBlobDetector_Params_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, cv::SimpleBlobDetector::Params& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        cv::SimpleBlobDetector::Params * dst_ = nullptr;
        if (evision_SimpleBlobDetector_Params_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected cv::SimpleBlobDetector::Params for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// SparseOpticalFlow (Generic)
//================================================================================

// GetSet (SparseOpticalFlow)



// Methods (SparseOpticalFlow)

static ERL_NIF_TERM evision_cv_sparseOpticalFlow_calc(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::SparseOpticalFlow> * self1 = 0;
    if (!evision_SparseOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::SparseOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::SparseOpticalFlow> _self_ = *(self1);

    {
    Mat prevImg;
    Mat nextImg;
    Mat prevPts;
    Mat nextPts;
    Mat status;
    Mat err;

    // const char* keywords[] = { "prevImg", "nextImg", "prevPts", "nextPts", "status", "err", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "prevImg"), prevImg, ArgInfo("prevImg", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nextImg"), nextImg, ArgInfo("nextImg", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "prevPts"), prevPts, ArgInfo("prevPts", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nextPts"), nextPts, ArgInfo("nextPts", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "status"), status, ArgInfo("status", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "err"), err, ArgInfo("err", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->calc(prevImg, nextImg, prevPts, nextPts, status, err), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, nextPts), evision_from(env, status), evision_from(env, err));
        }
    }

    }
    

    {
    UMat prevImg;
    UMat nextImg;
    UMat prevPts;
    UMat nextPts;
    UMat status;
    UMat err;

    // const char* keywords[] = { "prevImg", "nextImg", "prevPts", "nextPts", "status", "err", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "prevImg"), prevImg, ArgInfo("prevImg", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nextImg"), nextImg, ArgInfo("nextImg", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "prevPts"), prevPts, ArgInfo("prevPts", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nextPts"), nextPts, ArgInfo("nextPts", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "status"), status, ArgInfo("status", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "err"), err, ArgInfo("err", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->calc(prevImg, nextImg, prevPts, nextPts, status, err), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, nextPts), evision_from(env, status), evision_from(env, err));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_sparseOpticalFlow_clear(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::SparseOpticalFlow> * self1 = 0;
    if (!evision_SparseOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::SparseOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::SparseOpticalFlow> _self_ = *(self1);

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::clear(), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "SparseOpticalFlow", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_sparseOpticalFlow_empty(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::SparseOpticalFlow> * self1 = 0;
    if (!evision_SparseOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::SparseOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::SparseOpticalFlow> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->Algorithm::empty(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_sparseOpticalFlow_getDefaultName(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::SparseOpticalFlow> * self1 = 0;
    if (!evision_SparseOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::SparseOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::SparseOpticalFlow> _self_ = *(self1);
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->Algorithm::getDefaultName(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_sparseOpticalFlow_read(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::SparseOpticalFlow> * self1 = 0;
    if (!evision_SparseOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::SparseOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::SparseOpticalFlow> _self_ = *(self1);
    FileNode fn_;

    // const char* keywords[] = { "fn_", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fn_"), fn_, ArgInfo("fn_", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::read(fn_), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "SparseOpticalFlow", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_sparseOpticalFlow_save(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::SparseOpticalFlow> * self1 = 0;
    if (!evision_SparseOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::SparseOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::SparseOpticalFlow> _self_ = *(self1);
    String filename;

    // const char* keywords[] = { "filename", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::save(filename), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "SparseOpticalFlow", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_sparseOpticalFlow_write(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::SparseOpticalFlow> * self1 = 0;
    if (!evision_SparseOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::SparseOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::SparseOpticalFlow> _self_ = *(self1);
    Ptr<FileStorage> fs;
    String name;

    // const char* keywords[] = { "fs", "name", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fs"), fs, ArgInfo("fs", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "name"), name, ArgInfo("name", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::write(fs, name), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "SparseOpticalFlow", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (SparseOpticalFlow)

template<>
struct Evision_Converter< Ptr<cv::SparseOpticalFlow> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::SparseOpticalFlow>& r)
    {
        return evision_SparseOpticalFlow_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::SparseOpticalFlow>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::SparseOpticalFlow> * dst_ = nullptr;
        if (evision_SparseOpticalFlow_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::SparseOpticalFlow> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// SparsePyrLKOpticalFlow (Generic)
//================================================================================

// GetSet (SparsePyrLKOpticalFlow)



// Methods (SparsePyrLKOpticalFlow)

static ERL_NIF_TERM evision_cv_sparsePyrLKOpticalFlow_create_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    Size winSize=Size(21, 21);
    int maxLevel=3;
    TermCriteria crit=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 0.01);
    int flags=0;
    double minEigThreshold=1e-4;
    Ptr<SparsePyrLKOpticalFlow> retval;

    // const char* keywords[] = { "winSize", "maxLevel", "crit", "flags", "minEigThreshold", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "winSize"), winSize, ArgInfo("winSize", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxLevel"), maxLevel, ArgInfo("maxLevel", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "crit"), crit, ArgInfo("crit", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minEigThreshold"), minEigThreshold, ArgInfo("minEigThreshold", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::SparsePyrLKOpticalFlow::create(winSize, maxLevel, crit, flags, minEigThreshold), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_sparsePyrLKOpticalFlow_getFlags(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::SparsePyrLKOpticalFlow> * self1 = 0;
    if (!evision_SparsePyrLKOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::SparsePyrLKOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::SparsePyrLKOpticalFlow> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getFlags(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_sparsePyrLKOpticalFlow_getMaxLevel(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::SparsePyrLKOpticalFlow> * self1 = 0;
    if (!evision_SparsePyrLKOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::SparsePyrLKOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::SparsePyrLKOpticalFlow> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getMaxLevel(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_sparsePyrLKOpticalFlow_getMinEigThreshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::SparsePyrLKOpticalFlow> * self1 = 0;
    if (!evision_SparsePyrLKOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::SparsePyrLKOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::SparsePyrLKOpticalFlow> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getMinEigThreshold(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_sparsePyrLKOpticalFlow_getTermCriteria(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::SparsePyrLKOpticalFlow> * self1 = 0;
    if (!evision_SparsePyrLKOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::SparsePyrLKOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::SparsePyrLKOpticalFlow> _self_ = *(self1);
    TermCriteria retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getTermCriteria(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_sparsePyrLKOpticalFlow_getWinSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::SparsePyrLKOpticalFlow> * self1 = 0;
    if (!evision_SparsePyrLKOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::SparsePyrLKOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::SparsePyrLKOpticalFlow> _self_ = *(self1);
    Size retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getWinSize(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_sparsePyrLKOpticalFlow_setFlags(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::SparsePyrLKOpticalFlow> * self1 = 0;
    if (!evision_SparsePyrLKOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::SparsePyrLKOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::SparsePyrLKOpticalFlow> _self_ = *(self1);
    int flags=0;

    // const char* keywords[] = { "flags", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setFlags(flags), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "SparsePyrLKOpticalFlow", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_sparsePyrLKOpticalFlow_setMaxLevel(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::SparsePyrLKOpticalFlow> * self1 = 0;
    if (!evision_SparsePyrLKOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::SparsePyrLKOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::SparsePyrLKOpticalFlow> _self_ = *(self1);
    int maxLevel=0;

    // const char* keywords[] = { "maxLevel", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "maxLevel"), maxLevel, ArgInfo("maxLevel", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setMaxLevel(maxLevel), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "SparsePyrLKOpticalFlow", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_sparsePyrLKOpticalFlow_setMinEigThreshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::SparsePyrLKOpticalFlow> * self1 = 0;
    if (!evision_SparsePyrLKOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::SparsePyrLKOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::SparsePyrLKOpticalFlow> _self_ = *(self1);
    double minEigThreshold=0;

    // const char* keywords[] = { "minEigThreshold", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "minEigThreshold"), minEigThreshold, ArgInfo("minEigThreshold", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setMinEigThreshold(minEigThreshold), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "SparsePyrLKOpticalFlow", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_sparsePyrLKOpticalFlow_setTermCriteria(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::SparsePyrLKOpticalFlow> * self1 = 0;
    if (!evision_SparsePyrLKOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::SparsePyrLKOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::SparsePyrLKOpticalFlow> _self_ = *(self1);
    TermCriteria crit;

    // const char* keywords[] = { "crit", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "crit"), crit, ArgInfo("crit", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setTermCriteria(crit), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "SparsePyrLKOpticalFlow", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_sparsePyrLKOpticalFlow_setWinSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::SparsePyrLKOpticalFlow> * self1 = 0;
    if (!evision_SparsePyrLKOpticalFlow_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::SparsePyrLKOpticalFlow>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::SparsePyrLKOpticalFlow> _self_ = *(self1);
    Size winSize;

    // const char* keywords[] = { "winSize", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "winSize"), winSize, ArgInfo("winSize", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setWinSize(winSize), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "SparsePyrLKOpticalFlow", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (SparsePyrLKOpticalFlow)

template<>
struct Evision_Converter< Ptr<cv::SparsePyrLKOpticalFlow> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::SparsePyrLKOpticalFlow>& r)
    {
        return evision_SparsePyrLKOpticalFlow_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::SparsePyrLKOpticalFlow>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::SparsePyrLKOpticalFlow> * dst_ = nullptr;
        if (evision_SparsePyrLKOpticalFlow_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::SparsePyrLKOpticalFlow> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// StereoBM (Generic)
//================================================================================

// GetSet (StereoBM)



// Methods (StereoBM)

static ERL_NIF_TERM evision_cv_stereoBM_clear(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoBM> * self1 = 0;
    if (!evision_StereoBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoBM> _self_ = *(self1);

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::clear(), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "StereoBM", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoBM_compute(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoBM> * self1 = 0;
    if (!evision_StereoBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoBM> _self_ = *(self1);

    {
    Mat left;
    Mat right;
    Mat disparity;

    // const char* keywords[] = { "left", "right", "disparity", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "left"), left, ArgInfo("left", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "right"), right, ArgInfo("right", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "disparity"), disparity, ArgInfo("disparity", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute(left, right, disparity), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, disparity);
        }
    }

    }
    

    {
    UMat left;
    UMat right;
    UMat disparity;

    // const char* keywords[] = { "left", "right", "disparity", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "left"), left, ArgInfo("left", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "right"), right, ArgInfo("right", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "disparity"), disparity, ArgInfo("disparity", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute(left, right, disparity), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, disparity);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoBM_create_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    int numDisparities=0;
    int blockSize=21;
    Ptr<StereoBM> retval;

    // const char* keywords[] = { "numDisparities", "blockSize", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "numDisparities"), numDisparities, ArgInfo("numDisparities", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "blockSize"), blockSize, ArgInfo("blockSize", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::StereoBM::create(numDisparities, blockSize), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoBM_empty(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoBM> * self1 = 0;
    if (!evision_StereoBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoBM> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->Algorithm::empty(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoBM_getBlockSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoBM> * self1 = 0;
    if (!evision_StereoBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoBM> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getBlockSize(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoBM_getDefaultName(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoBM> * self1 = 0;
    if (!evision_StereoBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoBM> _self_ = *(self1);
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->Algorithm::getDefaultName(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoBM_getDisp12MaxDiff(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoBM> * self1 = 0;
    if (!evision_StereoBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoBM> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getDisp12MaxDiff(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoBM_getMinDisparity(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoBM> * self1 = 0;
    if (!evision_StereoBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoBM> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getMinDisparity(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoBM_getNumDisparities(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoBM> * self1 = 0;
    if (!evision_StereoBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoBM> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getNumDisparities(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoBM_getPreFilterCap(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoBM> * self1 = 0;
    if (!evision_StereoBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoBM> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getPreFilterCap(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoBM_getPreFilterSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoBM> * self1 = 0;
    if (!evision_StereoBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoBM> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getPreFilterSize(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoBM_getPreFilterType(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoBM> * self1 = 0;
    if (!evision_StereoBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoBM> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getPreFilterType(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoBM_getROI1(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoBM> * self1 = 0;
    if (!evision_StereoBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoBM> _self_ = *(self1);
    Rect retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getROI1(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoBM_getROI2(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoBM> * self1 = 0;
    if (!evision_StereoBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoBM> _self_ = *(self1);
    Rect retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getROI2(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoBM_getSmallerBlockSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoBM> * self1 = 0;
    if (!evision_StereoBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoBM> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getSmallerBlockSize(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoBM_getSpeckleRange(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoBM> * self1 = 0;
    if (!evision_StereoBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoBM> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getSpeckleRange(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoBM_getSpeckleWindowSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoBM> * self1 = 0;
    if (!evision_StereoBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoBM> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getSpeckleWindowSize(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoBM_getTextureThreshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoBM> * self1 = 0;
    if (!evision_StereoBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoBM> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getTextureThreshold(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoBM_getUniquenessRatio(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoBM> * self1 = 0;
    if (!evision_StereoBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoBM> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getUniquenessRatio(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoBM_read(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoBM> * self1 = 0;
    if (!evision_StereoBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoBM> _self_ = *(self1);
    FileNode fn_;

    // const char* keywords[] = { "fn_", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fn_"), fn_, ArgInfo("fn_", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::read(fn_), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "StereoBM", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoBM_save(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoBM> * self1 = 0;
    if (!evision_StereoBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoBM> _self_ = *(self1);
    String filename;

    // const char* keywords[] = { "filename", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::save(filename), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "StereoBM", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoBM_setBlockSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoBM> * self1 = 0;
    if (!evision_StereoBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoBM> _self_ = *(self1);
    int blockSize=0;

    // const char* keywords[] = { "blockSize", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "blockSize"), blockSize, ArgInfo("blockSize", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setBlockSize(blockSize), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "StereoBM", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoBM_setDisp12MaxDiff(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoBM> * self1 = 0;
    if (!evision_StereoBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoBM> _self_ = *(self1);
    int disp12MaxDiff=0;

    // const char* keywords[] = { "disp12MaxDiff", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "disp12MaxDiff"), disp12MaxDiff, ArgInfo("disp12MaxDiff", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setDisp12MaxDiff(disp12MaxDiff), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "StereoBM", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoBM_setMinDisparity(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoBM> * self1 = 0;
    if (!evision_StereoBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoBM> _self_ = *(self1);
    int minDisparity=0;

    // const char* keywords[] = { "minDisparity", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "minDisparity"), minDisparity, ArgInfo("minDisparity", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setMinDisparity(minDisparity), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "StereoBM", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoBM_setNumDisparities(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoBM> * self1 = 0;
    if (!evision_StereoBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoBM> _self_ = *(self1);
    int numDisparities=0;

    // const char* keywords[] = { "numDisparities", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "numDisparities"), numDisparities, ArgInfo("numDisparities", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setNumDisparities(numDisparities), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "StereoBM", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoBM_setPreFilterCap(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoBM> * self1 = 0;
    if (!evision_StereoBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoBM> _self_ = *(self1);
    int preFilterCap=0;

    // const char* keywords[] = { "preFilterCap", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "preFilterCap"), preFilterCap, ArgInfo("preFilterCap", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setPreFilterCap(preFilterCap), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "StereoBM", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoBM_setPreFilterSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoBM> * self1 = 0;
    if (!evision_StereoBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoBM> _self_ = *(self1);
    int preFilterSize=0;

    // const char* keywords[] = { "preFilterSize", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "preFilterSize"), preFilterSize, ArgInfo("preFilterSize", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setPreFilterSize(preFilterSize), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "StereoBM", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoBM_setPreFilterType(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoBM> * self1 = 0;
    if (!evision_StereoBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoBM> _self_ = *(self1);
    int preFilterType=0;

    // const char* keywords[] = { "preFilterType", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "preFilterType"), preFilterType, ArgInfo("preFilterType", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setPreFilterType(preFilterType), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "StereoBM", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoBM_setROI1(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoBM> * self1 = 0;
    if (!evision_StereoBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoBM> _self_ = *(self1);
    Rect roi1;

    // const char* keywords[] = { "roi1", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "roi1"), roi1, ArgInfo("roi1", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setROI1(roi1), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "StereoBM", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoBM_setROI2(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoBM> * self1 = 0;
    if (!evision_StereoBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoBM> _self_ = *(self1);
    Rect roi2;

    // const char* keywords[] = { "roi2", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "roi2"), roi2, ArgInfo("roi2", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setROI2(roi2), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "StereoBM", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoBM_setSmallerBlockSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoBM> * self1 = 0;
    if (!evision_StereoBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoBM> _self_ = *(self1);
    int blockSize=0;

    // const char* keywords[] = { "blockSize", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "blockSize"), blockSize, ArgInfo("blockSize", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setSmallerBlockSize(blockSize), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "StereoBM", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoBM_setSpeckleRange(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoBM> * self1 = 0;
    if (!evision_StereoBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoBM> _self_ = *(self1);
    int speckleRange=0;

    // const char* keywords[] = { "speckleRange", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "speckleRange"), speckleRange, ArgInfo("speckleRange", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setSpeckleRange(speckleRange), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "StereoBM", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoBM_setSpeckleWindowSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoBM> * self1 = 0;
    if (!evision_StereoBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoBM> _self_ = *(self1);
    int speckleWindowSize=0;

    // const char* keywords[] = { "speckleWindowSize", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "speckleWindowSize"), speckleWindowSize, ArgInfo("speckleWindowSize", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setSpeckleWindowSize(speckleWindowSize), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "StereoBM", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoBM_setTextureThreshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoBM> * self1 = 0;
    if (!evision_StereoBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoBM> _self_ = *(self1);
    int textureThreshold=0;

    // const char* keywords[] = { "textureThreshold", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "textureThreshold"), textureThreshold, ArgInfo("textureThreshold", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setTextureThreshold(textureThreshold), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "StereoBM", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoBM_setUniquenessRatio(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoBM> * self1 = 0;
    if (!evision_StereoBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoBM> _self_ = *(self1);
    int uniquenessRatio=0;

    // const char* keywords[] = { "uniquenessRatio", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "uniquenessRatio"), uniquenessRatio, ArgInfo("uniquenessRatio", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setUniquenessRatio(uniquenessRatio), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "StereoBM", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoBM_write(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoBM> * self1 = 0;
    if (!evision_StereoBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoBM> _self_ = *(self1);
    Ptr<FileStorage> fs;
    String name;

    // const char* keywords[] = { "fs", "name", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fs"), fs, ArgInfo("fs", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "name"), name, ArgInfo("name", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::write(fs, name), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "StereoBM", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (StereoBM)

template<>
struct Evision_Converter< Ptr<cv::StereoBM> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::StereoBM>& r)
    {
        return evision_StereoBM_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::StereoBM>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::StereoBM> * dst_ = nullptr;
        if (evision_StereoBM_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::StereoBM> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// StereoMatcher (Generic)
//================================================================================

// GetSet (StereoMatcher)



// Methods (StereoMatcher)

static ERL_NIF_TERM evision_cv_stereoMatcher_clear(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoMatcher> * self1 = 0;
    if (!evision_StereoMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoMatcher> _self_ = *(self1);

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::clear(), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "StereoMatcher", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoMatcher_compute(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoMatcher> * self1 = 0;
    if (!evision_StereoMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoMatcher> _self_ = *(self1);

    {
    Mat left;
    Mat right;
    Mat disparity;

    // const char* keywords[] = { "left", "right", "disparity", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "left"), left, ArgInfo("left", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "right"), right, ArgInfo("right", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "disparity"), disparity, ArgInfo("disparity", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute(left, right, disparity), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, disparity);
        }
    }

    }
    

    {
    UMat left;
    UMat right;
    UMat disparity;

    // const char* keywords[] = { "left", "right", "disparity", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "left"), left, ArgInfo("left", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "right"), right, ArgInfo("right", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "disparity"), disparity, ArgInfo("disparity", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute(left, right, disparity), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, disparity);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoMatcher_empty(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoMatcher> * self1 = 0;
    if (!evision_StereoMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoMatcher> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->Algorithm::empty(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoMatcher_getBlockSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoMatcher> * self1 = 0;
    if (!evision_StereoMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoMatcher> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getBlockSize(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoMatcher_getDefaultName(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoMatcher> * self1 = 0;
    if (!evision_StereoMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoMatcher> _self_ = *(self1);
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->Algorithm::getDefaultName(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoMatcher_getDisp12MaxDiff(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoMatcher> * self1 = 0;
    if (!evision_StereoMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoMatcher> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getDisp12MaxDiff(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoMatcher_getMinDisparity(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoMatcher> * self1 = 0;
    if (!evision_StereoMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoMatcher> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getMinDisparity(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoMatcher_getNumDisparities(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoMatcher> * self1 = 0;
    if (!evision_StereoMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoMatcher> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getNumDisparities(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoMatcher_getSpeckleRange(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoMatcher> * self1 = 0;
    if (!evision_StereoMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoMatcher> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getSpeckleRange(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoMatcher_getSpeckleWindowSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoMatcher> * self1 = 0;
    if (!evision_StereoMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoMatcher> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getSpeckleWindowSize(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoMatcher_read(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoMatcher> * self1 = 0;
    if (!evision_StereoMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoMatcher> _self_ = *(self1);
    FileNode fn_;

    // const char* keywords[] = { "fn_", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fn_"), fn_, ArgInfo("fn_", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::read(fn_), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "StereoMatcher", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoMatcher_save(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoMatcher> * self1 = 0;
    if (!evision_StereoMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoMatcher> _self_ = *(self1);
    String filename;

    // const char* keywords[] = { "filename", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::save(filename), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "StereoMatcher", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoMatcher_setBlockSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoMatcher> * self1 = 0;
    if (!evision_StereoMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoMatcher> _self_ = *(self1);
    int blockSize=0;

    // const char* keywords[] = { "blockSize", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "blockSize"), blockSize, ArgInfo("blockSize", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setBlockSize(blockSize), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "StereoMatcher", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoMatcher_setDisp12MaxDiff(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoMatcher> * self1 = 0;
    if (!evision_StereoMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoMatcher> _self_ = *(self1);
    int disp12MaxDiff=0;

    // const char* keywords[] = { "disp12MaxDiff", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "disp12MaxDiff"), disp12MaxDiff, ArgInfo("disp12MaxDiff", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setDisp12MaxDiff(disp12MaxDiff), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "StereoMatcher", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoMatcher_setMinDisparity(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoMatcher> * self1 = 0;
    if (!evision_StereoMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoMatcher> _self_ = *(self1);
    int minDisparity=0;

    // const char* keywords[] = { "minDisparity", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "minDisparity"), minDisparity, ArgInfo("minDisparity", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setMinDisparity(minDisparity), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "StereoMatcher", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoMatcher_setNumDisparities(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoMatcher> * self1 = 0;
    if (!evision_StereoMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoMatcher> _self_ = *(self1);
    int numDisparities=0;

    // const char* keywords[] = { "numDisparities", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "numDisparities"), numDisparities, ArgInfo("numDisparities", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setNumDisparities(numDisparities), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "StereoMatcher", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoMatcher_setSpeckleRange(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoMatcher> * self1 = 0;
    if (!evision_StereoMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoMatcher> _self_ = *(self1);
    int speckleRange=0;

    // const char* keywords[] = { "speckleRange", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "speckleRange"), speckleRange, ArgInfo("speckleRange", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setSpeckleRange(speckleRange), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "StereoMatcher", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoMatcher_setSpeckleWindowSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoMatcher> * self1 = 0;
    if (!evision_StereoMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoMatcher> _self_ = *(self1);
    int speckleWindowSize=0;

    // const char* keywords[] = { "speckleWindowSize", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "speckleWindowSize"), speckleWindowSize, ArgInfo("speckleWindowSize", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setSpeckleWindowSize(speckleWindowSize), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "StereoMatcher", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoMatcher_write(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoMatcher> * self1 = 0;
    if (!evision_StereoMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoMatcher> _self_ = *(self1);
    Ptr<FileStorage> fs;
    String name;

    // const char* keywords[] = { "fs", "name", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fs"), fs, ArgInfo("fs", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "name"), name, ArgInfo("name", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::write(fs, name), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "StereoMatcher", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (StereoMatcher)

template<>
struct Evision_Converter< Ptr<cv::StereoMatcher> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::StereoMatcher>& r)
    {
        return evision_StereoMatcher_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::StereoMatcher>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::StereoMatcher> * dst_ = nullptr;
        if (evision_StereoMatcher_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::StereoMatcher> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// StereoSGBM (Generic)
//================================================================================

// GetSet (StereoSGBM)



// Methods (StereoSGBM)

static ERL_NIF_TERM evision_cv_stereoSGBM_clear(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoSGBM> * self1 = 0;
    if (!evision_StereoSGBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoSGBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoSGBM> _self_ = *(self1);

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::clear(), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "StereoSGBM", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoSGBM_compute(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoSGBM> * self1 = 0;
    if (!evision_StereoSGBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoSGBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoSGBM> _self_ = *(self1);

    {
    Mat left;
    Mat right;
    Mat disparity;

    // const char* keywords[] = { "left", "right", "disparity", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "left"), left, ArgInfo("left", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "right"), right, ArgInfo("right", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "disparity"), disparity, ArgInfo("disparity", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute(left, right, disparity), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, disparity);
        }
    }

    }
    

    {
    UMat left;
    UMat right;
    UMat disparity;

    // const char* keywords[] = { "left", "right", "disparity", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "left"), left, ArgInfo("left", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "right"), right, ArgInfo("right", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "disparity"), disparity, ArgInfo("disparity", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->compute(left, right, disparity), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, disparity);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoSGBM_create_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    int minDisparity=0;
    int numDisparities=16;
    int blockSize=3;
    int P1=0;
    int P2=0;
    int disp12MaxDiff=0;
    int preFilterCap=0;
    int uniquenessRatio=0;
    int speckleWindowSize=0;
    int speckleRange=0;
    int mode=StereoSGBM::MODE_SGBM;
    Ptr<StereoSGBM> retval;

    // const char* keywords[] = { "minDisparity", "numDisparities", "blockSize", "P1", "P2", "disp12MaxDiff", "preFilterCap", "uniquenessRatio", "speckleWindowSize", "speckleRange", "mode", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "minDisparity"), minDisparity, ArgInfo("minDisparity", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "numDisparities"), numDisparities, ArgInfo("numDisparities", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "blockSize"), blockSize, ArgInfo("blockSize", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "p1"), P1, ArgInfo("P1", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "p2"), P2, ArgInfo("P2", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "disp12MaxDiff"), disp12MaxDiff, ArgInfo("disp12MaxDiff", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "preFilterCap"), preFilterCap, ArgInfo("preFilterCap", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "uniquenessRatio"), uniquenessRatio, ArgInfo("uniquenessRatio", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "speckleWindowSize"), speckleWindowSize, ArgInfo("speckleWindowSize", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "speckleRange"), speckleRange, ArgInfo("speckleRange", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mode"), mode, ArgInfo("mode", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::StereoSGBM::create(minDisparity, numDisparities, blockSize, P1, P2, disp12MaxDiff, preFilterCap, uniquenessRatio, speckleWindowSize, speckleRange, mode), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoSGBM_empty(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoSGBM> * self1 = 0;
    if (!evision_StereoSGBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoSGBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoSGBM> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->Algorithm::empty(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoSGBM_getBlockSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoSGBM> * self1 = 0;
    if (!evision_StereoSGBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoSGBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoSGBM> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getBlockSize(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoSGBM_getDefaultName(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoSGBM> * self1 = 0;
    if (!evision_StereoSGBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoSGBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoSGBM> _self_ = *(self1);
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->Algorithm::getDefaultName(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoSGBM_getDisp12MaxDiff(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoSGBM> * self1 = 0;
    if (!evision_StereoSGBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoSGBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoSGBM> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getDisp12MaxDiff(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoSGBM_getMinDisparity(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoSGBM> * self1 = 0;
    if (!evision_StereoSGBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoSGBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoSGBM> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getMinDisparity(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoSGBM_getMode(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoSGBM> * self1 = 0;
    if (!evision_StereoSGBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoSGBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoSGBM> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getMode(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoSGBM_getNumDisparities(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoSGBM> * self1 = 0;
    if (!evision_StereoSGBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoSGBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoSGBM> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getNumDisparities(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoSGBM_getP1(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoSGBM> * self1 = 0;
    if (!evision_StereoSGBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoSGBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoSGBM> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getP1(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoSGBM_getP2(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoSGBM> * self1 = 0;
    if (!evision_StereoSGBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoSGBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoSGBM> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getP2(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoSGBM_getPreFilterCap(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoSGBM> * self1 = 0;
    if (!evision_StereoSGBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoSGBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoSGBM> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getPreFilterCap(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoSGBM_getSpeckleRange(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoSGBM> * self1 = 0;
    if (!evision_StereoSGBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoSGBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoSGBM> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getSpeckleRange(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoSGBM_getSpeckleWindowSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoSGBM> * self1 = 0;
    if (!evision_StereoSGBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoSGBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoSGBM> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getSpeckleWindowSize(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoSGBM_getUniquenessRatio(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoSGBM> * self1 = 0;
    if (!evision_StereoSGBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoSGBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoSGBM> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getUniquenessRatio(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoSGBM_read(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoSGBM> * self1 = 0;
    if (!evision_StereoSGBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoSGBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoSGBM> _self_ = *(self1);
    FileNode fn_;

    // const char* keywords[] = { "fn_", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fn_"), fn_, ArgInfo("fn_", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::read(fn_), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "StereoSGBM", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoSGBM_save(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoSGBM> * self1 = 0;
    if (!evision_StereoSGBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoSGBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoSGBM> _self_ = *(self1);
    String filename;

    // const char* keywords[] = { "filename", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::save(filename), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "StereoSGBM", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoSGBM_setBlockSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoSGBM> * self1 = 0;
    if (!evision_StereoSGBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoSGBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoSGBM> _self_ = *(self1);
    int blockSize=0;

    // const char* keywords[] = { "blockSize", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "blockSize"), blockSize, ArgInfo("blockSize", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setBlockSize(blockSize), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "StereoSGBM", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoSGBM_setDisp12MaxDiff(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoSGBM> * self1 = 0;
    if (!evision_StereoSGBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoSGBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoSGBM> _self_ = *(self1);
    int disp12MaxDiff=0;

    // const char* keywords[] = { "disp12MaxDiff", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "disp12MaxDiff"), disp12MaxDiff, ArgInfo("disp12MaxDiff", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setDisp12MaxDiff(disp12MaxDiff), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "StereoSGBM", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoSGBM_setMinDisparity(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoSGBM> * self1 = 0;
    if (!evision_StereoSGBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoSGBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoSGBM> _self_ = *(self1);
    int minDisparity=0;

    // const char* keywords[] = { "minDisparity", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "minDisparity"), minDisparity, ArgInfo("minDisparity", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setMinDisparity(minDisparity), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "StereoSGBM", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoSGBM_setMode(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoSGBM> * self1 = 0;
    if (!evision_StereoSGBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoSGBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoSGBM> _self_ = *(self1);
    int mode=0;

    // const char* keywords[] = { "mode", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "mode"), mode, ArgInfo("mode", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setMode(mode), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "StereoSGBM", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoSGBM_setNumDisparities(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoSGBM> * self1 = 0;
    if (!evision_StereoSGBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoSGBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoSGBM> _self_ = *(self1);
    int numDisparities=0;

    // const char* keywords[] = { "numDisparities", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "numDisparities"), numDisparities, ArgInfo("numDisparities", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setNumDisparities(numDisparities), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "StereoSGBM", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoSGBM_setP1(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoSGBM> * self1 = 0;
    if (!evision_StereoSGBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoSGBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoSGBM> _self_ = *(self1);
    int P1=0;

    // const char* keywords[] = { "P1", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "p1"), P1, ArgInfo("P1", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setP1(P1), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "StereoSGBM", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoSGBM_setP2(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoSGBM> * self1 = 0;
    if (!evision_StereoSGBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoSGBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoSGBM> _self_ = *(self1);
    int P2=0;

    // const char* keywords[] = { "P2", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "p2"), P2, ArgInfo("P2", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setP2(P2), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "StereoSGBM", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoSGBM_setPreFilterCap(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoSGBM> * self1 = 0;
    if (!evision_StereoSGBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoSGBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoSGBM> _self_ = *(self1);
    int preFilterCap=0;

    // const char* keywords[] = { "preFilterCap", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "preFilterCap"), preFilterCap, ArgInfo("preFilterCap", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setPreFilterCap(preFilterCap), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "StereoSGBM", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoSGBM_setSpeckleRange(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoSGBM> * self1 = 0;
    if (!evision_StereoSGBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoSGBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoSGBM> _self_ = *(self1);
    int speckleRange=0;

    // const char* keywords[] = { "speckleRange", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "speckleRange"), speckleRange, ArgInfo("speckleRange", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setSpeckleRange(speckleRange), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "StereoSGBM", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoSGBM_setSpeckleWindowSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoSGBM> * self1 = 0;
    if (!evision_StereoSGBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoSGBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoSGBM> _self_ = *(self1);
    int speckleWindowSize=0;

    // const char* keywords[] = { "speckleWindowSize", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "speckleWindowSize"), speckleWindowSize, ArgInfo("speckleWindowSize", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setSpeckleWindowSize(speckleWindowSize), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "StereoSGBM", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoSGBM_setUniquenessRatio(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoSGBM> * self1 = 0;
    if (!evision_StereoSGBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoSGBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoSGBM> _self_ = *(self1);
    int uniquenessRatio=0;

    // const char* keywords[] = { "uniquenessRatio", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "uniquenessRatio"), uniquenessRatio, ArgInfo("uniquenessRatio", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setUniquenessRatio(uniquenessRatio), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "StereoSGBM", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoSGBM_write(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::StereoSGBM> * self1 = 0;
    if (!evision_StereoSGBM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::StereoSGBM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::StereoSGBM> _self_ = *(self1);
    Ptr<FileStorage> fs;
    String name;

    // const char* keywords[] = { "fs", "name", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fs"), fs, ArgInfo("fs", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "name"), name, ArgInfo("name", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::write(fs, name), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "StereoSGBM", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (StereoSGBM)

template<>
struct Evision_Converter< Ptr<cv::StereoSGBM> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::StereoSGBM>& r)
    {
        return evision_StereoSGBM_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::StereoSGBM>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::StereoSGBM> * dst_ = nullptr;
        if (evision_StereoSGBM_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::StereoSGBM> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// Stitcher (Generic)
//================================================================================

// GetSet (Stitcher)



// Methods (Stitcher)

static ERL_NIF_TERM evision_cv_stitcher_composePanorama(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Stitcher> * self1 = 0;
    if (!evision_Stitcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Stitcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Stitcher> _self_ = *(self1);

    {
    Mat pano;
    Status retval;

    // const char* keywords[] = { "pano", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "pano"), pano, ArgInfo("pano", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->composePanorama(pano), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, pano));
        }
    }

    }
    

    {
    UMat pano;
    Status retval;

    // const char* keywords[] = { "pano", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "pano"), pano, ArgInfo("pano", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->composePanorama(pano), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, pano));
        }
    }

    }
    

    {
    vector_Mat images;
    Mat pano;
    Status retval;

    // const char* keywords[] = { "images", "pano", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pano"), pano, ArgInfo("pano", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->composePanorama(images, pano), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, pano));
        }
    }

    }
    

    {
    vector_UMat images;
    UMat pano;
    Status retval;

    // const char* keywords[] = { "images", "pano", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pano"), pano, ArgInfo("pano", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->composePanorama(images, pano), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, pano));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stitcher_compositingResol(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Stitcher> * self1 = 0;
    if (!evision_Stitcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Stitcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Stitcher> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->compositingResol(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stitcher_create_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    std::underlying_type_t<Mode> mode=static_cast<std::underlying_type_t<Mode>>(Stitcher::PANORAMA);
    Ptr<Stitcher> retval;

    // const char* keywords[] = { "mode", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "mode"), mode, ArgInfo("mode", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::Stitcher::create(static_cast<Mode>(mode)), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stitcher_estimateTransform(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Stitcher> * self1 = 0;
    if (!evision_Stitcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Stitcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Stitcher> _self_ = *(self1);

    {
    vector_Mat images;
    vector_Mat masks;
    Status retval;

    // const char* keywords[] = { "images", "masks", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "masks"), masks, ArgInfo("masks", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->estimateTransform(images, masks), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    vector_UMat images;
    vector_UMat masks;
    Status retval;

    // const char* keywords[] = { "images", "masks", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "masks"), masks, ArgInfo("masks", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->estimateTransform(images, masks), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stitcher_interpolationFlags(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Stitcher> * self1 = 0;
    if (!evision_Stitcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Stitcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Stitcher> _self_ = *(self1);
    InterpolationFlags retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->interpolationFlags(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stitcher_panoConfidenceThresh(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Stitcher> * self1 = 0;
    if (!evision_Stitcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Stitcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Stitcher> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->panoConfidenceThresh(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stitcher_registrationResol(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Stitcher> * self1 = 0;
    if (!evision_Stitcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Stitcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Stitcher> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->registrationResol(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stitcher_seamEstimationResol(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Stitcher> * self1 = 0;
    if (!evision_Stitcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Stitcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Stitcher> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->seamEstimationResol(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stitcher_setCompositingResol(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Stitcher> * self1 = 0;
    if (!evision_Stitcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Stitcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Stitcher> _self_ = *(self1);
    double resol_mpx=0;

    // const char* keywords[] = { "resol_mpx", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "resol_mpx"), resol_mpx, ArgInfo("resol_mpx", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setCompositingResol(resol_mpx), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Stitcher", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stitcher_setInterpolationFlags(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Stitcher> * self1 = 0;
    if (!evision_Stitcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Stitcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Stitcher> _self_ = *(self1);
    std::underlying_type_t<InterpolationFlags> interp_flags=static_cast<std::underlying_type_t<InterpolationFlags>>(static_cast<InterpolationFlags>(0));

    // const char* keywords[] = { "interp_flags", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "interp_flags"), interp_flags, ArgInfo("interp_flags", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setInterpolationFlags(static_cast<InterpolationFlags>(interp_flags)), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Stitcher", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stitcher_setPanoConfidenceThresh(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Stitcher> * self1 = 0;
    if (!evision_Stitcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Stitcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Stitcher> _self_ = *(self1);
    double conf_thresh=0;

    // const char* keywords[] = { "conf_thresh", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "conf_thresh"), conf_thresh, ArgInfo("conf_thresh", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setPanoConfidenceThresh(conf_thresh), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Stitcher", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stitcher_setRegistrationResol(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Stitcher> * self1 = 0;
    if (!evision_Stitcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Stitcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Stitcher> _self_ = *(self1);
    double resol_mpx=0;

    // const char* keywords[] = { "resol_mpx", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "resol_mpx"), resol_mpx, ArgInfo("resol_mpx", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setRegistrationResol(resol_mpx), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Stitcher", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stitcher_setSeamEstimationResol(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Stitcher> * self1 = 0;
    if (!evision_Stitcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Stitcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Stitcher> _self_ = *(self1);
    double resol_mpx=0;

    // const char* keywords[] = { "resol_mpx", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "resol_mpx"), resol_mpx, ArgInfo("resol_mpx", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setSeamEstimationResol(resol_mpx), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Stitcher", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stitcher_setWaveCorrection(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Stitcher> * self1 = 0;
    if (!evision_Stitcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Stitcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Stitcher> _self_ = *(self1);
    bool flag=0;

    // const char* keywords[] = { "flag", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "flag"), flag, ArgInfo("flag", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setWaveCorrection(flag), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Stitcher", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stitcher_stitch(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Stitcher> * self1 = 0;
    if (!evision_Stitcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Stitcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Stitcher> _self_ = *(self1);

    {
    vector_Mat images;
    Mat pano;
    Status retval;

    // const char* keywords[] = { "images", "pano", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pano"), pano, ArgInfo("pano", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->stitch(images, pano), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, pano));
        }
    }

    }
    

    {
    vector_UMat images;
    UMat pano;
    Status retval;

    // const char* keywords[] = { "images", "pano", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pano"), pano, ArgInfo("pano", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->stitch(images, pano), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, pano));
        }
    }

    }
    

    {
    vector_Mat images;
    vector_Mat masks;
    Mat pano;
    Status retval;

    // const char* keywords[] = { "images", "masks", "pano", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "masks"), masks, ArgInfo("masks", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pano"), pano, ArgInfo("pano", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->stitch(images, masks, pano), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, pano));
        }
    }

    }
    

    {
    vector_UMat images;
    vector_UMat masks;
    UMat pano;
    Status retval;

    // const char* keywords[] = { "images", "masks", "pano", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "masks"), masks, ArgInfo("masks", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pano"), pano, ArgInfo("pano", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->stitch(images, masks, pano), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, pano));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stitcher_waveCorrection(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Stitcher> * self1 = 0;
    if (!evision_Stitcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Stitcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Stitcher> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->waveCorrection(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stitcher_workScale(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Stitcher> * self1 = 0;
    if (!evision_Stitcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Stitcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Stitcher> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->workScale(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (Stitcher)

template<>
struct Evision_Converter< Ptr<cv::Stitcher> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::Stitcher>& r)
    {
        return evision_Stitcher_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::Stitcher>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::Stitcher> * dst_ = nullptr;
        if (evision_Stitcher_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::Stitcher> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// Subdiv2D (Generic)
//================================================================================

// GetSet (Subdiv2D)



// Methods (Subdiv2D)

static ERL_NIF_TERM evision_cv_subdiv2D_Subdiv2D(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    {

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        evision_res<Ptr<cv::Subdiv2D>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::Subdiv2D>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::Subdiv2D()), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::Subdiv2D>>(env, self->val, ret, "Subdiv2D", success);;
        }
    }

    }
    

    {
    Rect rect;

    // const char* keywords[] = { "rect", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "rect"), rect, ArgInfo("rect", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::Subdiv2D>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::Subdiv2D>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::Subdiv2D(rect)), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::Subdiv2D>>(env, self->val, ret, "Subdiv2D", success);;
        }
    }

    }

    return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_subdiv2D_edgeDst(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Subdiv2D> * self1 = 0;
    if (!evision_Subdiv2D_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Subdiv2D>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Subdiv2D> _self_ = *(self1);
    int edge=0;
    Point2f dstpt;
    int retval;

    // const char* keywords[] = { "edge", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "edge"), edge, ArgInfo("edge", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->edgeDst(edge, &dstpt), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, dstpt));
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_subdiv2D_edgeOrg(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Subdiv2D> * self1 = 0;
    if (!evision_Subdiv2D_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Subdiv2D>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Subdiv2D> _self_ = *(self1);
    int edge=0;
    Point2f orgpt;
    int retval;

    // const char* keywords[] = { "edge", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "edge"), edge, ArgInfo("edge", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->edgeOrg(edge, &orgpt), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, orgpt));
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_subdiv2D_findNearest(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Subdiv2D> * self1 = 0;
    if (!evision_Subdiv2D_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Subdiv2D>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Subdiv2D> _self_ = *(self1);
    Point2f pt;
    Point2f nearestPt;
    int retval;

    // const char* keywords[] = { "pt", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "pt"), pt, ArgInfo("pt", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->findNearest(pt, &nearestPt), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, nearestPt));
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_subdiv2D_getEdge(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Subdiv2D> * self1 = 0;
    if (!evision_Subdiv2D_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Subdiv2D>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Subdiv2D> _self_ = *(self1);
    int edge=0;
    int nextEdgeType=0;
    int retval;

    // const char* keywords[] = { "edge", "nextEdgeType", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "edge"), edge, ArgInfo("edge", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nextEdgeType"), nextEdgeType, ArgInfo("nextEdgeType", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getEdge(edge, nextEdgeType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_subdiv2D_getEdgeList(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Subdiv2D> * self1 = 0;
    if (!evision_Subdiv2D_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Subdiv2D>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Subdiv2D> _self_ = *(self1);
    vector_Vec4f edgeList;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->getEdgeList(edgeList), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, edgeList);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_subdiv2D_getLeadingEdgeList(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Subdiv2D> * self1 = 0;
    if (!evision_Subdiv2D_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Subdiv2D>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Subdiv2D> _self_ = *(self1);
    vector_int leadingEdgeList;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->getLeadingEdgeList(leadingEdgeList), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, leadingEdgeList);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_subdiv2D_getTriangleList(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Subdiv2D> * self1 = 0;
    if (!evision_Subdiv2D_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Subdiv2D>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Subdiv2D> _self_ = *(self1);
    vector_Vec6f triangleList;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->getTriangleList(triangleList), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, triangleList);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_subdiv2D_getVertex(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Subdiv2D> * self1 = 0;
    if (!evision_Subdiv2D_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Subdiv2D>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Subdiv2D> _self_ = *(self1);
    int vertex=0;
    int firstEdge;
    Point2f retval;

    // const char* keywords[] = { "vertex", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "vertex"), vertex, ArgInfo("vertex", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getVertex(vertex, &firstEdge), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, firstEdge));
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_subdiv2D_getVoronoiFacetList(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Subdiv2D> * self1 = 0;
    if (!evision_Subdiv2D_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Subdiv2D>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Subdiv2D> _self_ = *(self1);
    vector_int idx;
    vector_vector_Point2f facetList;
    vector_Point2f facetCenters;

    // const char* keywords[] = { "idx", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "idx"), idx, ArgInfo("idx", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->getVoronoiFacetList(idx, facetList, facetCenters), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, facetList), evision_from(env, facetCenters));
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_subdiv2D_initDelaunay(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Subdiv2D> * self1 = 0;
    if (!evision_Subdiv2D_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Subdiv2D>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Subdiv2D> _self_ = *(self1);
    Rect rect;

    // const char* keywords[] = { "rect", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "rect"), rect, ArgInfo("rect", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->initDelaunay(rect), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Subdiv2D", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_subdiv2D_insert(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Subdiv2D> * self1 = 0;
    if (!evision_Subdiv2D_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Subdiv2D>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Subdiv2D> _self_ = *(self1);

    {
    Point2f pt;
    int retval;

    // const char* keywords[] = { "pt", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "pt"), pt, ArgInfo("pt", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->insert(pt), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    vector_Point2f ptvec;

    // const char* keywords[] = { "ptvec", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "ptvec"), ptvec, ArgInfo("ptvec", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->insert(ptvec), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Subdiv2D", success);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_subdiv2D_locate(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Subdiv2D> * self1 = 0;
    if (!evision_Subdiv2D_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Subdiv2D>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Subdiv2D> _self_ = *(self1);
    Point2f pt;
    int edge;
    int vertex;
    int retval;

    // const char* keywords[] = { "pt", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "pt"), pt, ArgInfo("pt", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->locate(pt, edge, vertex), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, retval), evision_from(env, edge), evision_from(env, vertex));
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_subdiv2D_nextEdge(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Subdiv2D> * self1 = 0;
    if (!evision_Subdiv2D_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Subdiv2D>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Subdiv2D> _self_ = *(self1);
    int edge=0;
    int retval;

    // const char* keywords[] = { "edge", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "edge"), edge, ArgInfo("edge", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->nextEdge(edge), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_subdiv2D_rotateEdge(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Subdiv2D> * self1 = 0;
    if (!evision_Subdiv2D_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Subdiv2D>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Subdiv2D> _self_ = *(self1);
    int edge=0;
    int rotate=0;
    int retval;

    // const char* keywords[] = { "edge", "rotate", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "edge"), edge, ArgInfo("edge", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rotate"), rotate, ArgInfo("rotate", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->rotateEdge(edge, rotate), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_subdiv2D_symEdge(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Subdiv2D> * self1 = 0;
    if (!evision_Subdiv2D_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Subdiv2D>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Subdiv2D> _self_ = *(self1);
    int edge=0;
    int retval;

    // const char* keywords[] = { "edge", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "edge"), edge, ArgInfo("edge", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->symEdge(edge), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (Subdiv2D)

template<>
struct Evision_Converter< Ptr<cv::Subdiv2D> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::Subdiv2D>& r)
    {
        return evision_Subdiv2D_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::Subdiv2D>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::Subdiv2D> * dst_ = nullptr;
        if (evision_Subdiv2D_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::Subdiv2D> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// TickMeter (Generic)
//================================================================================

// GetSet (TickMeter)



// Methods (TickMeter)

static ERL_NIF_TERM evision_cv_tickMeter_TickMeter(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        evision_res<Ptr<cv::TickMeter>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::TickMeter>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::TickMeter()), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::TickMeter>>(env, self->val, ret, "TickMeter", success);;
        }
    }

    return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_tickMeter_getAvgTimeMilli(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::TickMeter> * self1 = 0;
    if (!evision_TickMeter_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::TickMeter>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::TickMeter> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getAvgTimeMilli(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_tickMeter_getAvgTimeSec(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::TickMeter> * self1 = 0;
    if (!evision_TickMeter_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::TickMeter>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::TickMeter> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getAvgTimeSec(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_tickMeter_getCounter(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::TickMeter> * self1 = 0;
    if (!evision_TickMeter_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::TickMeter>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::TickMeter> _self_ = *(self1);
    int64 retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getCounter(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_tickMeter_getFPS(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::TickMeter> * self1 = 0;
    if (!evision_TickMeter_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::TickMeter>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::TickMeter> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getFPS(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_tickMeter_getTimeMicro(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::TickMeter> * self1 = 0;
    if (!evision_TickMeter_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::TickMeter>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::TickMeter> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getTimeMicro(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_tickMeter_getTimeMilli(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::TickMeter> * self1 = 0;
    if (!evision_TickMeter_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::TickMeter>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::TickMeter> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getTimeMilli(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_tickMeter_getTimeSec(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::TickMeter> * self1 = 0;
    if (!evision_TickMeter_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::TickMeter>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::TickMeter> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getTimeSec(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_tickMeter_getTimeTicks(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::TickMeter> * self1 = 0;
    if (!evision_TickMeter_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::TickMeter>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::TickMeter> _self_ = *(self1);
    int64 retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getTimeTicks(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_tickMeter_reset(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::TickMeter> * self1 = 0;
    if (!evision_TickMeter_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::TickMeter>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::TickMeter> _self_ = *(self1);

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->reset(), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "TickMeter", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_tickMeter_start(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::TickMeter> * self1 = 0;
    if (!evision_TickMeter_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::TickMeter>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::TickMeter> _self_ = *(self1);

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->start(), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "TickMeter", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_tickMeter_stop(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::TickMeter> * self1 = 0;
    if (!evision_TickMeter_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::TickMeter>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::TickMeter> _self_ = *(self1);

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->stop(), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "TickMeter", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (TickMeter)

template<>
struct Evision_Converter< Ptr<cv::TickMeter> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::TickMeter>& r)
    {
        return evision_TickMeter_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::TickMeter>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::TickMeter> * dst_ = nullptr;
        if (evision_TickMeter_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::TickMeter> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// Tonemap (Generic)
//================================================================================

// GetSet (Tonemap)



// Methods (Tonemap)

static ERL_NIF_TERM evision_cv_tonemap_clear(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Tonemap> * self1 = 0;
    if (!evision_Tonemap_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Tonemap>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Tonemap> _self_ = *(self1);

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::clear(), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Tonemap", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_tonemap_empty(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Tonemap> * self1 = 0;
    if (!evision_Tonemap_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Tonemap>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Tonemap> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->Algorithm::empty(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_tonemap_getDefaultName(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Tonemap> * self1 = 0;
    if (!evision_Tonemap_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Tonemap>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Tonemap> _self_ = *(self1);
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->Algorithm::getDefaultName(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_tonemap_getGamma(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Tonemap> * self1 = 0;
    if (!evision_Tonemap_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Tonemap>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Tonemap> _self_ = *(self1);
    float retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getGamma(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_tonemap_process(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Tonemap> * self1 = 0;
    if (!evision_Tonemap_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Tonemap>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Tonemap> _self_ = *(self1);

    {
    Mat src;
    Mat dst;

    // const char* keywords[] = { "src", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->process(src, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    UMat src;
    UMat dst;

    // const char* keywords[] = { "src", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->process(src, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_tonemap_read(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Tonemap> * self1 = 0;
    if (!evision_Tonemap_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Tonemap>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Tonemap> _self_ = *(self1);
    FileNode fn_;

    // const char* keywords[] = { "fn_", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fn_"), fn_, ArgInfo("fn_", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::read(fn_), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Tonemap", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_tonemap_save(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Tonemap> * self1 = 0;
    if (!evision_Tonemap_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Tonemap>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Tonemap> _self_ = *(self1);
    String filename;

    // const char* keywords[] = { "filename", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::save(filename), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Tonemap", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_tonemap_setGamma(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Tonemap> * self1 = 0;
    if (!evision_Tonemap_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Tonemap>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Tonemap> _self_ = *(self1);
    float gamma=0.f;

    // const char* keywords[] = { "gamma", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "gamma"), gamma, ArgInfo("gamma", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setGamma(gamma), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Tonemap", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_tonemap_write(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Tonemap> * self1 = 0;
    if (!evision_Tonemap_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Tonemap>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Tonemap> _self_ = *(self1);
    Ptr<FileStorage> fs;
    String name;

    // const char* keywords[] = { "fs", "name", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fs"), fs, ArgInfo("fs", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "name"), name, ArgInfo("name", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::write(fs, name), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Tonemap", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (Tonemap)

template<>
struct Evision_Converter< Ptr<cv::Tonemap> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::Tonemap>& r)
    {
        return evision_Tonemap_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::Tonemap>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::Tonemap> * dst_ = nullptr;
        if (evision_Tonemap_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::Tonemap> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// TonemapDrago (Generic)
//================================================================================

// GetSet (TonemapDrago)



// Methods (TonemapDrago)

static ERL_NIF_TERM evision_cv_tonemapDrago_getBias(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::TonemapDrago> * self1 = 0;
    if (!evision_TonemapDrago_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::TonemapDrago>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::TonemapDrago> _self_ = *(self1);
    float retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getBias(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_tonemapDrago_getSaturation(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::TonemapDrago> * self1 = 0;
    if (!evision_TonemapDrago_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::TonemapDrago>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::TonemapDrago> _self_ = *(self1);
    float retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getSaturation(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_tonemapDrago_setBias(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::TonemapDrago> * self1 = 0;
    if (!evision_TonemapDrago_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::TonemapDrago>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::TonemapDrago> _self_ = *(self1);
    float bias=0.f;

    // const char* keywords[] = { "bias", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "bias"), bias, ArgInfo("bias", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setBias(bias), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "TonemapDrago", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_tonemapDrago_setSaturation(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::TonemapDrago> * self1 = 0;
    if (!evision_TonemapDrago_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::TonemapDrago>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::TonemapDrago> _self_ = *(self1);
    float saturation=0.f;

    // const char* keywords[] = { "saturation", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "saturation"), saturation, ArgInfo("saturation", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setSaturation(saturation), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "TonemapDrago", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (TonemapDrago)

template<>
struct Evision_Converter< Ptr<cv::TonemapDrago> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::TonemapDrago>& r)
    {
        return evision_TonemapDrago_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::TonemapDrago>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::TonemapDrago> * dst_ = nullptr;
        if (evision_TonemapDrago_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::TonemapDrago> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// TonemapMantiuk (Generic)
//================================================================================

// GetSet (TonemapMantiuk)



// Methods (TonemapMantiuk)

static ERL_NIF_TERM evision_cv_tonemapMantiuk_getSaturation(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::TonemapMantiuk> * self1 = 0;
    if (!evision_TonemapMantiuk_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::TonemapMantiuk>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::TonemapMantiuk> _self_ = *(self1);
    float retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getSaturation(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_tonemapMantiuk_getScale(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::TonemapMantiuk> * self1 = 0;
    if (!evision_TonemapMantiuk_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::TonemapMantiuk>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::TonemapMantiuk> _self_ = *(self1);
    float retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getScale(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_tonemapMantiuk_setSaturation(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::TonemapMantiuk> * self1 = 0;
    if (!evision_TonemapMantiuk_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::TonemapMantiuk>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::TonemapMantiuk> _self_ = *(self1);
    float saturation=0.f;

    // const char* keywords[] = { "saturation", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "saturation"), saturation, ArgInfo("saturation", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setSaturation(saturation), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "TonemapMantiuk", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_tonemapMantiuk_setScale(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::TonemapMantiuk> * self1 = 0;
    if (!evision_TonemapMantiuk_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::TonemapMantiuk>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::TonemapMantiuk> _self_ = *(self1);
    float scale=0.f;

    // const char* keywords[] = { "scale", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "scale"), scale, ArgInfo("scale", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setScale(scale), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "TonemapMantiuk", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (TonemapMantiuk)

template<>
struct Evision_Converter< Ptr<cv::TonemapMantiuk> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::TonemapMantiuk>& r)
    {
        return evision_TonemapMantiuk_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::TonemapMantiuk>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::TonemapMantiuk> * dst_ = nullptr;
        if (evision_TonemapMantiuk_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::TonemapMantiuk> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// TonemapReinhard (Generic)
//================================================================================

// GetSet (TonemapReinhard)



// Methods (TonemapReinhard)

static ERL_NIF_TERM evision_cv_tonemapReinhard_getColorAdaptation(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::TonemapReinhard> * self1 = 0;
    if (!evision_TonemapReinhard_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::TonemapReinhard>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::TonemapReinhard> _self_ = *(self1);
    float retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getColorAdaptation(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_tonemapReinhard_getIntensity(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::TonemapReinhard> * self1 = 0;
    if (!evision_TonemapReinhard_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::TonemapReinhard>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::TonemapReinhard> _self_ = *(self1);
    float retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getIntensity(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_tonemapReinhard_getLightAdaptation(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::TonemapReinhard> * self1 = 0;
    if (!evision_TonemapReinhard_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::TonemapReinhard>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::TonemapReinhard> _self_ = *(self1);
    float retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getLightAdaptation(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_tonemapReinhard_setColorAdaptation(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::TonemapReinhard> * self1 = 0;
    if (!evision_TonemapReinhard_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::TonemapReinhard>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::TonemapReinhard> _self_ = *(self1);
    float color_adapt=0.f;

    // const char* keywords[] = { "color_adapt", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "color_adapt"), color_adapt, ArgInfo("color_adapt", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setColorAdaptation(color_adapt), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "TonemapReinhard", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_tonemapReinhard_setIntensity(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::TonemapReinhard> * self1 = 0;
    if (!evision_TonemapReinhard_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::TonemapReinhard>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::TonemapReinhard> _self_ = *(self1);
    float intensity=0.f;

    // const char* keywords[] = { "intensity", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "intensity"), intensity, ArgInfo("intensity", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setIntensity(intensity), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "TonemapReinhard", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_tonemapReinhard_setLightAdaptation(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::TonemapReinhard> * self1 = 0;
    if (!evision_TonemapReinhard_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::TonemapReinhard>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::TonemapReinhard> _self_ = *(self1);
    float light_adapt=0.f;

    // const char* keywords[] = { "light_adapt", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "light_adapt"), light_adapt, ArgInfo("light_adapt", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setLightAdaptation(light_adapt), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "TonemapReinhard", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (TonemapReinhard)

template<>
struct Evision_Converter< Ptr<cv::TonemapReinhard> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::TonemapReinhard>& r)
    {
        return evision_TonemapReinhard_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::TonemapReinhard>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::TonemapReinhard> * dst_ = nullptr;
        if (evision_TonemapReinhard_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::TonemapReinhard> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// Tracker (Generic)
//================================================================================

// GetSet (Tracker)



// Methods (Tracker)

static ERL_NIF_TERM evision_cv_tracker_init(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Tracker> * self1 = 0;
    if (!evision_Tracker_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Tracker>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Tracker> _self_ = *(self1);

    {
    Mat image;
    Rect boundingBox;

    // const char* keywords[] = { "image", "boundingBox", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "boundingBox"), boundingBox, ArgInfo("boundingBox", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->init(image, boundingBox), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Tracker", success);
        }
    }

    }
    

    {
    UMat image;
    Rect boundingBox;

    // const char* keywords[] = { "image", "boundingBox", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "boundingBox"), boundingBox, ArgInfo("boundingBox", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->init(image, boundingBox), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Tracker", success);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_tracker_update(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::Tracker> * self1 = 0;
    if (!evision_Tracker_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::Tracker>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::Tracker> _self_ = *(self1);

    {
    Mat image;
    Rect boundingBox;
    bool retval;

    // const char* keywords[] = { "image", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->update(image, boundingBox), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_1_tuple_except_bool
                return evision_from(env, boundingBox);
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    UMat image;
    Rect boundingBox;
    bool retval;

    // const char* keywords[] = { "image", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->update(image, boundingBox), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_1_tuple_except_bool
                return evision_from(env, boundingBox);
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (Tracker)

template<>
struct Evision_Converter< Ptr<cv::Tracker> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::Tracker>& r)
    {
        return evision_Tracker_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::Tracker>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::Tracker> * dst_ = nullptr;
        if (evision_Tracker_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::Tracker> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// TrackerDaSiamRPN (Generic)
//================================================================================

// GetSet (TrackerDaSiamRPN)



// Methods (TrackerDaSiamRPN)

static ERL_NIF_TERM evision_cv_trackerDaSiamRPN_create_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    TrackerDaSiamRPN_Params parameters=TrackerDaSiamRPN::Params();
    Ptr<TrackerDaSiamRPN> retval;

    // const char* keywords[] = { "parameters", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "parameters"), parameters, ArgInfo("parameters", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::TrackerDaSiamRPN::create(parameters), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_trackerDaSiamRPN_getTrackingScore(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::TrackerDaSiamRPN> * self1 = 0;
    if (!evision_TrackerDaSiamRPN_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::TrackerDaSiamRPN>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::TrackerDaSiamRPN> _self_ = *(self1);
    float retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getTrackingScore(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (TrackerDaSiamRPN)

template<>
struct Evision_Converter< Ptr<cv::TrackerDaSiamRPN> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::TrackerDaSiamRPN>& r)
    {
        return evision_TrackerDaSiamRPN_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::TrackerDaSiamRPN>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::TrackerDaSiamRPN> * dst_ = nullptr;
        if (evision_TrackerDaSiamRPN_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::TrackerDaSiamRPN> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// TrackerDaSiamRPN_Params (Generic)
//================================================================================

// GetSet (TrackerDaSiamRPN_Params)


static ERL_NIF_TERM evision_TrackerDaSiamRPN_Params_get_backend(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::TrackerDaSiamRPN::Params* self_ptr = 0;
    if (!evision_TrackerDaSiamRPN_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::TrackerDaSiamRPN::Params` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->backend);
}

static ERL_NIF_TERM evision_TrackerDaSiamRPN_Params_set_backend(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::TrackerDaSiamRPN::Params* self_ptr = 0;

    if (!evision_TrackerDaSiamRPN_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::TrackerDaSiamRPN::Params` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->backend, ArgInfo("backend", false))) {
        bool success;
        return evision_from_as_map<cv::TrackerDaSiamRPN::Params>(env, *self_ptr, self, "\"TrackerDaSiamRPN.Params\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_TrackerDaSiamRPN_Params_get_kernel_cls1(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::TrackerDaSiamRPN::Params* self_ptr = 0;
    if (!evision_TrackerDaSiamRPN_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::TrackerDaSiamRPN::Params` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->kernel_cls1);
}

static ERL_NIF_TERM evision_TrackerDaSiamRPN_Params_set_kernel_cls1(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::TrackerDaSiamRPN::Params* self_ptr = 0;

    if (!evision_TrackerDaSiamRPN_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::TrackerDaSiamRPN::Params` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->kernel_cls1, ArgInfo("kernel_cls1", false))) {
        bool success;
        return evision_from_as_map<cv::TrackerDaSiamRPN::Params>(env, *self_ptr, self, "\"TrackerDaSiamRPN.Params\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_TrackerDaSiamRPN_Params_get_kernel_r1(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::TrackerDaSiamRPN::Params* self_ptr = 0;
    if (!evision_TrackerDaSiamRPN_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::TrackerDaSiamRPN::Params` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->kernel_r1);
}

static ERL_NIF_TERM evision_TrackerDaSiamRPN_Params_set_kernel_r1(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::TrackerDaSiamRPN::Params* self_ptr = 0;

    if (!evision_TrackerDaSiamRPN_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::TrackerDaSiamRPN::Params` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->kernel_r1, ArgInfo("kernel_r1", false))) {
        bool success;
        return evision_from_as_map<cv::TrackerDaSiamRPN::Params>(env, *self_ptr, self, "\"TrackerDaSiamRPN.Params\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_TrackerDaSiamRPN_Params_get_model(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::TrackerDaSiamRPN::Params* self_ptr = 0;
    if (!evision_TrackerDaSiamRPN_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::TrackerDaSiamRPN::Params` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->model);
}

static ERL_NIF_TERM evision_TrackerDaSiamRPN_Params_set_model(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::TrackerDaSiamRPN::Params* self_ptr = 0;

    if (!evision_TrackerDaSiamRPN_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::TrackerDaSiamRPN::Params` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->model, ArgInfo("model", false))) {
        bool success;
        return evision_from_as_map<cv::TrackerDaSiamRPN::Params>(env, *self_ptr, self, "\"TrackerDaSiamRPN.Params\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_TrackerDaSiamRPN_Params_get_target(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::TrackerDaSiamRPN::Params* self_ptr = 0;
    if (!evision_TrackerDaSiamRPN_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::TrackerDaSiamRPN::Params` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->target);
}

static ERL_NIF_TERM evision_TrackerDaSiamRPN_Params_set_target(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::TrackerDaSiamRPN::Params* self_ptr = 0;

    if (!evision_TrackerDaSiamRPN_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::TrackerDaSiamRPN::Params` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->target, ArgInfo("target", false))) {
        bool success;
        return evision_from_as_map<cv::TrackerDaSiamRPN::Params>(env, *self_ptr, self, "\"TrackerDaSiamRPN.Params\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}


// Methods (TrackerDaSiamRPN_Params)

static ERL_NIF_TERM evision_cv_trackerDaSiamRPN_Params_TrackerDaSiamRPN_Params(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        evision_res<cv::TrackerDaSiamRPN::Params> * self = nullptr;
        if (alloc_resource(&self)) ERRWRAP2(new (&(self->val)) cv::TrackerDaSiamRPN::Params(), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<cv::TrackerDaSiamRPN::Params>(env, self->val, ret, "TrackerDaSiamRPN.Params", success);;
        }
    }

    return enif_make_badarg(env);
}



// Converter (TrackerDaSiamRPN_Params)

template<>
struct Evision_Converter< cv::TrackerDaSiamRPN::Params >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const cv::TrackerDaSiamRPN::Params& r)
    {
        return evision_TrackerDaSiamRPN_Params_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, cv::TrackerDaSiamRPN::Params& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        cv::TrackerDaSiamRPN::Params * dst_ = nullptr;
        if (evision_TrackerDaSiamRPN_Params_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected cv::TrackerDaSiamRPN::Params for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// TrackerGOTURN (Generic)
//================================================================================

// GetSet (TrackerGOTURN)



// Methods (TrackerGOTURN)

static ERL_NIF_TERM evision_cv_trackerGOTURN_create_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    TrackerGOTURN_Params parameters=TrackerGOTURN::Params();
    Ptr<TrackerGOTURN> retval;

    // const char* keywords[] = { "parameters", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "parameters"), parameters, ArgInfo("parameters", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::TrackerGOTURN::create(parameters), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (TrackerGOTURN)

template<>
struct Evision_Converter< Ptr<cv::TrackerGOTURN> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::TrackerGOTURN>& r)
    {
        return evision_TrackerGOTURN_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::TrackerGOTURN>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::TrackerGOTURN> * dst_ = nullptr;
        if (evision_TrackerGOTURN_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::TrackerGOTURN> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// TrackerGOTURN_Params (Generic)
//================================================================================

// GetSet (TrackerGOTURN_Params)


static ERL_NIF_TERM evision_TrackerGOTURN_Params_get_modelBin(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::TrackerGOTURN::Params* self_ptr = 0;
    if (!evision_TrackerGOTURN_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::TrackerGOTURN::Params` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->modelBin);
}

static ERL_NIF_TERM evision_TrackerGOTURN_Params_set_modelBin(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::TrackerGOTURN::Params* self_ptr = 0;

    if (!evision_TrackerGOTURN_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::TrackerGOTURN::Params` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->modelBin, ArgInfo("modelBin", false))) {
        bool success;
        return evision_from_as_map<cv::TrackerGOTURN::Params>(env, *self_ptr, self, "\"TrackerGOTURN.Params\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_TrackerGOTURN_Params_get_modelTxt(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::TrackerGOTURN::Params* self_ptr = 0;
    if (!evision_TrackerGOTURN_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::TrackerGOTURN::Params` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->modelTxt);
}

static ERL_NIF_TERM evision_TrackerGOTURN_Params_set_modelTxt(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::TrackerGOTURN::Params* self_ptr = 0;

    if (!evision_TrackerGOTURN_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::TrackerGOTURN::Params` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->modelTxt, ArgInfo("modelTxt", false))) {
        bool success;
        return evision_from_as_map<cv::TrackerGOTURN::Params>(env, *self_ptr, self, "\"TrackerGOTURN.Params\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}


// Methods (TrackerGOTURN_Params)

static ERL_NIF_TERM evision_cv_trackerGOTURN_Params_TrackerGOTURN_Params(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        evision_res<cv::TrackerGOTURN::Params> * self = nullptr;
        if (alloc_resource(&self)) ERRWRAP2(new (&(self->val)) cv::TrackerGOTURN::Params(), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<cv::TrackerGOTURN::Params>(env, self->val, ret, "TrackerGOTURN.Params", success);;
        }
    }

    return enif_make_badarg(env);
}



// Converter (TrackerGOTURN_Params)

template<>
struct Evision_Converter< cv::TrackerGOTURN::Params >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const cv::TrackerGOTURN::Params& r)
    {
        return evision_TrackerGOTURN_Params_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, cv::TrackerGOTURN::Params& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        cv::TrackerGOTURN::Params * dst_ = nullptr;
        if (evision_TrackerGOTURN_Params_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected cv::TrackerGOTURN::Params for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// TrackerMIL (Generic)
//================================================================================

// GetSet (TrackerMIL)



// Methods (TrackerMIL)

static ERL_NIF_TERM evision_cv_trackerMIL_create_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    TrackerMIL_Params parameters=TrackerMIL::Params();
    Ptr<TrackerMIL> retval;

    // const char* keywords[] = { "parameters", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "parameters"), parameters, ArgInfo("parameters", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::TrackerMIL::create(parameters), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (TrackerMIL)

template<>
struct Evision_Converter< Ptr<cv::TrackerMIL> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::TrackerMIL>& r)
    {
        return evision_TrackerMIL_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::TrackerMIL>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::TrackerMIL> * dst_ = nullptr;
        if (evision_TrackerMIL_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::TrackerMIL> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// TrackerMIL_Params (Generic)
//================================================================================

// GetSet (TrackerMIL_Params)


static ERL_NIF_TERM evision_TrackerMIL_Params_get_featureSetNumFeatures(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::TrackerMIL::Params* self_ptr = 0;
    if (!evision_TrackerMIL_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::TrackerMIL::Params` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->featureSetNumFeatures);
}

static ERL_NIF_TERM evision_TrackerMIL_Params_set_featureSetNumFeatures(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::TrackerMIL::Params* self_ptr = 0;

    if (!evision_TrackerMIL_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::TrackerMIL::Params` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->featureSetNumFeatures, ArgInfo("featureSetNumFeatures", false))) {
        bool success;
        return evision_from_as_map<cv::TrackerMIL::Params>(env, *self_ptr, self, "\"TrackerMIL.Params\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_TrackerMIL_Params_get_samplerInitInRadius(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::TrackerMIL::Params* self_ptr = 0;
    if (!evision_TrackerMIL_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::TrackerMIL::Params` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->samplerInitInRadius);
}

static ERL_NIF_TERM evision_TrackerMIL_Params_set_samplerInitInRadius(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::TrackerMIL::Params* self_ptr = 0;

    if (!evision_TrackerMIL_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::TrackerMIL::Params` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->samplerInitInRadius, ArgInfo("samplerInitInRadius", false))) {
        bool success;
        return evision_from_as_map<cv::TrackerMIL::Params>(env, *self_ptr, self, "\"TrackerMIL.Params\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_TrackerMIL_Params_get_samplerInitMaxNegNum(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::TrackerMIL::Params* self_ptr = 0;
    if (!evision_TrackerMIL_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::TrackerMIL::Params` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->samplerInitMaxNegNum);
}

static ERL_NIF_TERM evision_TrackerMIL_Params_set_samplerInitMaxNegNum(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::TrackerMIL::Params* self_ptr = 0;

    if (!evision_TrackerMIL_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::TrackerMIL::Params` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->samplerInitMaxNegNum, ArgInfo("samplerInitMaxNegNum", false))) {
        bool success;
        return evision_from_as_map<cv::TrackerMIL::Params>(env, *self_ptr, self, "\"TrackerMIL.Params\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_TrackerMIL_Params_get_samplerSearchWinSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::TrackerMIL::Params* self_ptr = 0;
    if (!evision_TrackerMIL_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::TrackerMIL::Params` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->samplerSearchWinSize);
}

static ERL_NIF_TERM evision_TrackerMIL_Params_set_samplerSearchWinSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::TrackerMIL::Params* self_ptr = 0;

    if (!evision_TrackerMIL_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::TrackerMIL::Params` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->samplerSearchWinSize, ArgInfo("samplerSearchWinSize", false))) {
        bool success;
        return evision_from_as_map<cv::TrackerMIL::Params>(env, *self_ptr, self, "\"TrackerMIL.Params\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_TrackerMIL_Params_get_samplerTrackInRadius(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::TrackerMIL::Params* self_ptr = 0;
    if (!evision_TrackerMIL_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::TrackerMIL::Params` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->samplerTrackInRadius);
}

static ERL_NIF_TERM evision_TrackerMIL_Params_set_samplerTrackInRadius(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::TrackerMIL::Params* self_ptr = 0;

    if (!evision_TrackerMIL_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::TrackerMIL::Params` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->samplerTrackInRadius, ArgInfo("samplerTrackInRadius", false))) {
        bool success;
        return evision_from_as_map<cv::TrackerMIL::Params>(env, *self_ptr, self, "\"TrackerMIL.Params\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_TrackerMIL_Params_get_samplerTrackMaxNegNum(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::TrackerMIL::Params* self_ptr = 0;
    if (!evision_TrackerMIL_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::TrackerMIL::Params` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->samplerTrackMaxNegNum);
}

static ERL_NIF_TERM evision_TrackerMIL_Params_set_samplerTrackMaxNegNum(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::TrackerMIL::Params* self_ptr = 0;

    if (!evision_TrackerMIL_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::TrackerMIL::Params` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->samplerTrackMaxNegNum, ArgInfo("samplerTrackMaxNegNum", false))) {
        bool success;
        return evision_from_as_map<cv::TrackerMIL::Params>(env, *self_ptr, self, "\"TrackerMIL.Params\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_TrackerMIL_Params_get_samplerTrackMaxPosNum(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::TrackerMIL::Params* self_ptr = 0;
    if (!evision_TrackerMIL_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::TrackerMIL::Params` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->samplerTrackMaxPosNum);
}

static ERL_NIF_TERM evision_TrackerMIL_Params_set_samplerTrackMaxPosNum(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::TrackerMIL::Params* self_ptr = 0;

    if (!evision_TrackerMIL_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::TrackerMIL::Params` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->samplerTrackMaxPosNum, ArgInfo("samplerTrackMaxPosNum", false))) {
        bool success;
        return evision_from_as_map<cv::TrackerMIL::Params>(env, *self_ptr, self, "\"TrackerMIL.Params\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}


// Methods (TrackerMIL_Params)

static ERL_NIF_TERM evision_cv_trackerMIL_Params_TrackerMIL_Params(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        evision_res<cv::TrackerMIL::Params> * self = nullptr;
        if (alloc_resource(&self)) ERRWRAP2(new (&(self->val)) cv::TrackerMIL::Params(), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<cv::TrackerMIL::Params>(env, self->val, ret, "TrackerMIL.Params", success);;
        }
    }

    return enif_make_badarg(env);
}



// Converter (TrackerMIL_Params)

template<>
struct Evision_Converter< cv::TrackerMIL::Params >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const cv::TrackerMIL::Params& r)
    {
        return evision_TrackerMIL_Params_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, cv::TrackerMIL::Params& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        cv::TrackerMIL::Params * dst_ = nullptr;
        if (evision_TrackerMIL_Params_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected cv::TrackerMIL::Params for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// UMat (Generic)
//================================================================================

// GetSet (UMat)


static ERL_NIF_TERM evision_UMat_get_offset(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    Ptr<cv::UMat>* self_ptr = 0;
    if (!evision_UMat_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `Ptr<cv::UMat>` from `self`: mismatched type or invalid resource?");
    }

    Ptr<cv::UMat> &self2 = *self_ptr;
    cv::UMat* _self_ = dynamic_cast<cv::UMat*>(self2.get());
    return evision_from(env, _self_->offset);
}

static ERL_NIF_TERM evision_UMat_set_offset(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    Ptr<cv::UMat>* self_ptr = 0;

    if (!evision_UMat_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `Ptr<cv::UMat>` from `self`: mismatched type or invalid resource?");
    }

    Ptr<cv::UMat> &_self_ = *self_ptr;

    std::map<std::string, ERL_NIF_TERM> erl_terms;
    evision::nif::parse_arg(env, 1, argv, erl_terms);

    if (evision_to_safe(env, evision_get_kw(env, erl_terms, "offset"), _self_->offset, ArgInfo("offset", false))) {
        bool success;
        return evision_from_as_map<Ptr<cv::UMat>>(env, _self_, self, "UMat", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}


// Methods (UMat)

static ERL_NIF_TERM evision_cv_uMat_UMat(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    {
    std::underlying_type_t<UMatUsageFlags> usageFlags=static_cast<std::underlying_type_t<UMatUsageFlags>>(USAGE_DEFAULT);

    // const char* keywords[] = { "usageFlags", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "usageFlags"), usageFlags, ArgInfo("usageFlags", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::UMat>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::UMat>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::UMat(static_cast<UMatUsageFlags>(usageFlags))), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::UMat>>(env, self->val, ret, "UMat", success);;
        }
    }

    }
    

    {
    int rows=0;
    int cols=0;
    int type=0;
    std::underlying_type_t<UMatUsageFlags> usageFlags=static_cast<std::underlying_type_t<UMatUsageFlags>>(USAGE_DEFAULT);

    // const char* keywords[] = { "rows", "cols", "type", "usageFlags", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "rows"), rows, ArgInfo("rows", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cols"), cols, ArgInfo("cols", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "type"), type, ArgInfo("type", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "usageFlags"), usageFlags, ArgInfo("usageFlags", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::UMat>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::UMat>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::UMat(rows, cols, type, static_cast<UMatUsageFlags>(usageFlags))), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::UMat>>(env, self->val, ret, "UMat", success);;
        }
    }

    }
    

    {
    Size size;
    int type=0;
    std::underlying_type_t<UMatUsageFlags> usageFlags=static_cast<std::underlying_type_t<UMatUsageFlags>>(USAGE_DEFAULT);

    // const char* keywords[] = { "size", "type", "usageFlags", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "size"), size, ArgInfo("size", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "type"), type, ArgInfo("type", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "usageFlags"), usageFlags, ArgInfo("usageFlags", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::UMat>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::UMat>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::UMat(size, type, static_cast<UMatUsageFlags>(usageFlags))), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::UMat>>(env, self->val, ret, "UMat", success);;
        }
    }

    }
    

    {
    int rows=0;
    int cols=0;
    int type=0;
    Scalar s;
    std::underlying_type_t<UMatUsageFlags> usageFlags=static_cast<std::underlying_type_t<UMatUsageFlags>>(USAGE_DEFAULT);

    // const char* keywords[] = { "rows", "cols", "type", "s", "usageFlags", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "rows"), rows, ArgInfo("rows", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cols"), cols, ArgInfo("cols", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "type"), type, ArgInfo("type", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "s"), s, ArgInfo("s", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "usageFlags"), usageFlags, ArgInfo("usageFlags", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::UMat>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::UMat>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::UMat(rows, cols, type, s, static_cast<UMatUsageFlags>(usageFlags))), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::UMat>>(env, self->val, ret, "UMat", success);;
        }
    }

    }
    

    {
    Size size;
    int type=0;
    Scalar s;
    std::underlying_type_t<UMatUsageFlags> usageFlags=static_cast<std::underlying_type_t<UMatUsageFlags>>(USAGE_DEFAULT);

    // const char* keywords[] = { "size", "type", "s", "usageFlags", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "size"), size, ArgInfo("size", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "type"), type, ArgInfo("type", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "s"), s, ArgInfo("s", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "usageFlags"), usageFlags, ArgInfo("usageFlags", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::UMat>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::UMat>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::UMat(size, type, s, static_cast<UMatUsageFlags>(usageFlags))), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::UMat>>(env, self->val, ret, "UMat", success);;
        }
    }

    }
    

    {
    UMat m;

    // const char* keywords[] = { "m", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "m"), m, ArgInfo("m", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::UMat>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::UMat>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::UMat(m)), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::UMat>>(env, self->val, ret, "UMat", success);;
        }
    }

    }
    

    {
    UMat m;
    Range rowRange;
    Range colRange=Range::all();

    // const char* keywords[] = { "m", "rowRange", "colRange", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "m"), m, ArgInfo("m", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rowRange"), rowRange, ArgInfo("rowRange", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "colRange"), colRange, ArgInfo("colRange", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::UMat>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::UMat>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::UMat(m, rowRange, colRange)), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::UMat>>(env, self->val, ret, "UMat", success);;
        }
    }

    }
    

    {
    UMat m;
    Rect roi;

    // const char* keywords[] = { "m", "roi", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "m"), m, ArgInfo("m", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "roi"), roi, ArgInfo("roi", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::UMat>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::UMat>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::UMat(m, roi)), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::UMat>>(env, self->val, ret, "UMat", success);;
        }
    }

    }
    

    {
    UMat m;
    vector_Range ranges;

    // const char* keywords[] = { "m", "ranges", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "m"), m, ArgInfo("m", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ranges"), ranges, ArgInfo("ranges", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::UMat>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::UMat>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::UMat(m, ranges)), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::UMat>>(env, self->val, ret, "UMat", success);;
        }
    }

    }

    return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_uMat_context_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    void* retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = cv_UMat_context(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_uMat_get(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::UMat> * self1 = 0;
    if (!evision_UMat_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::UMat>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::UMat> _self_ = *(self1);
    Mat retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = cv_UMat_get(_self_), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_uMat_handle(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::UMat> * self1 = 0;
    if (!evision_UMat_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::UMat>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::UMat> _self_ = *(self1);
    std::underlying_type_t<AccessFlag> accessFlags=static_cast<std::underlying_type_t<AccessFlag>>(static_cast<AccessFlag>(0));
    void* retval;

    // const char* keywords[] = { "accessFlags", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "accessFlags"), accessFlags, ArgInfo("accessFlags", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->handle(static_cast<AccessFlag>(accessFlags)), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_uMat_isContinuous(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::UMat> * self1 = 0;
    if (!evision_UMat_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::UMat>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::UMat> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->isContinuous(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_uMat_isSubmatrix(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::UMat> * self1 = 0;
    if (!evision_UMat_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::UMat>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::UMat> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->isSubmatrix(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_uMat_queue_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    void* retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = cv_UMat_queue(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (UMat)

template<>
struct Evision_Converter< Ptr<cv::UMat> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::UMat>& r)
    {
        return evision_UMat_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::UMat>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::UMat> * dst_ = nullptr;
        if (evision_UMat_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
    {
        Ptr<Mat> _src;
        if (evision_to_safe(env, src, _src, info))
        {
            return cv_mappable_to(_src, dst);
        }
    }

        failmsg(env, "Expected Ptr<cv::UMat> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// UsacParams (Generic)
//================================================================================

// GetSet (UsacParams)


static ERL_NIF_TERM evision_UsacParams_get_confidence(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::UsacParams* self_ptr = 0;
    if (!evision_UsacParams_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::UsacParams` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->confidence);
}

static ERL_NIF_TERM evision_UsacParams_set_confidence(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::UsacParams* self_ptr = 0;

    if (!evision_UsacParams_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::UsacParams` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->confidence, ArgInfo("confidence", false))) {
        bool success;
        return evision_from_as_map<cv::UsacParams>(env, *self_ptr, self, "UsacParams", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_UsacParams_get_isParallel(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::UsacParams* self_ptr = 0;
    if (!evision_UsacParams_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::UsacParams` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->isParallel);
}

static ERL_NIF_TERM evision_UsacParams_set_isParallel(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::UsacParams* self_ptr = 0;

    if (!evision_UsacParams_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::UsacParams` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->isParallel, ArgInfo("isParallel", false))) {
        bool success;
        return evision_from_as_map<cv::UsacParams>(env, *self_ptr, self, "UsacParams", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_UsacParams_get_loIterations(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::UsacParams* self_ptr = 0;
    if (!evision_UsacParams_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::UsacParams` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->loIterations);
}

static ERL_NIF_TERM evision_UsacParams_set_loIterations(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::UsacParams* self_ptr = 0;

    if (!evision_UsacParams_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::UsacParams` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->loIterations, ArgInfo("loIterations", false))) {
        bool success;
        return evision_from_as_map<cv::UsacParams>(env, *self_ptr, self, "UsacParams", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_UsacParams_get_loMethod(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::UsacParams* self_ptr = 0;
    if (!evision_UsacParams_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::UsacParams` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->loMethod);
}

static ERL_NIF_TERM evision_UsacParams_set_loMethod(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::UsacParams* self_ptr = 0;

    if (!evision_UsacParams_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::UsacParams` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->loMethod, ArgInfo("loMethod", false))) {
        bool success;
        return evision_from_as_map<cv::UsacParams>(env, *self_ptr, self, "UsacParams", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_UsacParams_get_loSampleSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::UsacParams* self_ptr = 0;
    if (!evision_UsacParams_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::UsacParams` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->loSampleSize);
}

static ERL_NIF_TERM evision_UsacParams_set_loSampleSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::UsacParams* self_ptr = 0;

    if (!evision_UsacParams_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::UsacParams` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->loSampleSize, ArgInfo("loSampleSize", false))) {
        bool success;
        return evision_from_as_map<cv::UsacParams>(env, *self_ptr, self, "UsacParams", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_UsacParams_get_maxIterations(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::UsacParams* self_ptr = 0;
    if (!evision_UsacParams_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::UsacParams` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->maxIterations);
}

static ERL_NIF_TERM evision_UsacParams_set_maxIterations(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::UsacParams* self_ptr = 0;

    if (!evision_UsacParams_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::UsacParams` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->maxIterations, ArgInfo("maxIterations", false))) {
        bool success;
        return evision_from_as_map<cv::UsacParams>(env, *self_ptr, self, "UsacParams", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_UsacParams_get_neighborsSearch(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::UsacParams* self_ptr = 0;
    if (!evision_UsacParams_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::UsacParams` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->neighborsSearch);
}

static ERL_NIF_TERM evision_UsacParams_set_neighborsSearch(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::UsacParams* self_ptr = 0;

    if (!evision_UsacParams_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::UsacParams` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->neighborsSearch, ArgInfo("neighborsSearch", false))) {
        bool success;
        return evision_from_as_map<cv::UsacParams>(env, *self_ptr, self, "UsacParams", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_UsacParams_get_randomGeneratorState(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::UsacParams* self_ptr = 0;
    if (!evision_UsacParams_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::UsacParams` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->randomGeneratorState);
}

static ERL_NIF_TERM evision_UsacParams_set_randomGeneratorState(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::UsacParams* self_ptr = 0;

    if (!evision_UsacParams_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::UsacParams` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->randomGeneratorState, ArgInfo("randomGeneratorState", false))) {
        bool success;
        return evision_from_as_map<cv::UsacParams>(env, *self_ptr, self, "UsacParams", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_UsacParams_get_sampler(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::UsacParams* self_ptr = 0;
    if (!evision_UsacParams_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::UsacParams` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->sampler);
}

static ERL_NIF_TERM evision_UsacParams_set_sampler(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::UsacParams* self_ptr = 0;

    if (!evision_UsacParams_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::UsacParams` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->sampler, ArgInfo("sampler", false))) {
        bool success;
        return evision_from_as_map<cv::UsacParams>(env, *self_ptr, self, "UsacParams", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_UsacParams_get_score(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::UsacParams* self_ptr = 0;
    if (!evision_UsacParams_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::UsacParams` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->score);
}

static ERL_NIF_TERM evision_UsacParams_set_score(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::UsacParams* self_ptr = 0;

    if (!evision_UsacParams_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::UsacParams` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->score, ArgInfo("score", false))) {
        bool success;
        return evision_from_as_map<cv::UsacParams>(env, *self_ptr, self, "UsacParams", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_UsacParams_get_threshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::UsacParams* self_ptr = 0;
    if (!evision_UsacParams_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::UsacParams` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->threshold);
}

static ERL_NIF_TERM evision_UsacParams_set_threshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::UsacParams* self_ptr = 0;

    if (!evision_UsacParams_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::UsacParams` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->threshold, ArgInfo("threshold", false))) {
        bool success;
        return evision_from_as_map<cv::UsacParams>(env, *self_ptr, self, "UsacParams", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}


// Methods (UsacParams)

static ERL_NIF_TERM evision_cv_usacParams_UsacParams(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        evision_res<cv::UsacParams> * self = nullptr;
        if (alloc_resource(&self)) ERRWRAP2(new (&(self->val)) cv::UsacParams(), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<cv::UsacParams>(env, self->val, ret, "UsacParams", success);;
        }
    }

    return enif_make_badarg(env);
}



// Converter (UsacParams)

template<>
struct Evision_Converter< cv::UsacParams >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const cv::UsacParams& r)
    {
        return evision_UsacParams_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, cv::UsacParams& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        cv::UsacParams * dst_ = nullptr;
        if (evision_UsacParams_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected cv::UsacParams for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// VariationalRefinement (Generic)
//================================================================================

// GetSet (VariationalRefinement)



// Methods (VariationalRefinement)

static ERL_NIF_TERM evision_cv_variationalRefinement_calcUV(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::VariationalRefinement> * self1 = 0;
    if (!evision_VariationalRefinement_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::VariationalRefinement>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::VariationalRefinement> _self_ = *(self1);

    {
    Mat I0;
    Mat I1;
    Mat flow_u;
    Mat flow_v;

    // const char* keywords[] = { "I0", "I1", "flow_u", "flow_v", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "i0"), I0, ArgInfo("I0", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "i1"), I1, ArgInfo("I1", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flow_u"), flow_u, ArgInfo("flow_u", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flow_v"), flow_v, ArgInfo("flow_v", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->calcUV(I0, I1, flow_u, flow_v), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, flow_u), evision_from(env, flow_v));
        }
    }

    }
    

    {
    UMat I0;
    UMat I1;
    UMat flow_u;
    UMat flow_v;

    // const char* keywords[] = { "I0", "I1", "flow_u", "flow_v", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "i0"), I0, ArgInfo("I0", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "i1"), I1, ArgInfo("I1", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flow_u"), flow_u, ArgInfo("flow_u", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flow_v"), flow_v, ArgInfo("flow_v", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->calcUV(I0, I1, flow_u, flow_v), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, flow_u), evision_from(env, flow_v));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_variationalRefinement_create_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    Ptr<VariationalRefinement> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::VariationalRefinement::create(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_variationalRefinement_getAlpha(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::VariationalRefinement> * self1 = 0;
    if (!evision_VariationalRefinement_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::VariationalRefinement>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::VariationalRefinement> _self_ = *(self1);
    float retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getAlpha(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_variationalRefinement_getDelta(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::VariationalRefinement> * self1 = 0;
    if (!evision_VariationalRefinement_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::VariationalRefinement>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::VariationalRefinement> _self_ = *(self1);
    float retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getDelta(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_variationalRefinement_getFixedPointIterations(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::VariationalRefinement> * self1 = 0;
    if (!evision_VariationalRefinement_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::VariationalRefinement>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::VariationalRefinement> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getFixedPointIterations(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_variationalRefinement_getGamma(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::VariationalRefinement> * self1 = 0;
    if (!evision_VariationalRefinement_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::VariationalRefinement>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::VariationalRefinement> _self_ = *(self1);
    float retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getGamma(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_variationalRefinement_getOmega(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::VariationalRefinement> * self1 = 0;
    if (!evision_VariationalRefinement_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::VariationalRefinement>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::VariationalRefinement> _self_ = *(self1);
    float retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getOmega(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_variationalRefinement_getSorIterations(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::VariationalRefinement> * self1 = 0;
    if (!evision_VariationalRefinement_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::VariationalRefinement>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::VariationalRefinement> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getSorIterations(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_variationalRefinement_setAlpha(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::VariationalRefinement> * self1 = 0;
    if (!evision_VariationalRefinement_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::VariationalRefinement>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::VariationalRefinement> _self_ = *(self1);
    float val=0.f;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setAlpha(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "VariationalRefinement", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_variationalRefinement_setDelta(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::VariationalRefinement> * self1 = 0;
    if (!evision_VariationalRefinement_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::VariationalRefinement>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::VariationalRefinement> _self_ = *(self1);
    float val=0.f;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setDelta(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "VariationalRefinement", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_variationalRefinement_setFixedPointIterations(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::VariationalRefinement> * self1 = 0;
    if (!evision_VariationalRefinement_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::VariationalRefinement>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::VariationalRefinement> _self_ = *(self1);
    int val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setFixedPointIterations(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "VariationalRefinement", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_variationalRefinement_setGamma(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::VariationalRefinement> * self1 = 0;
    if (!evision_VariationalRefinement_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::VariationalRefinement>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::VariationalRefinement> _self_ = *(self1);
    float val=0.f;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setGamma(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "VariationalRefinement", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_variationalRefinement_setOmega(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::VariationalRefinement> * self1 = 0;
    if (!evision_VariationalRefinement_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::VariationalRefinement>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::VariationalRefinement> _self_ = *(self1);
    float val=0.f;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setOmega(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "VariationalRefinement", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_variationalRefinement_setSorIterations(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::VariationalRefinement> * self1 = 0;
    if (!evision_VariationalRefinement_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::VariationalRefinement>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::VariationalRefinement> _self_ = *(self1);
    int val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setSorIterations(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "VariationalRefinement", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (VariationalRefinement)

template<>
struct Evision_Converter< Ptr<cv::VariationalRefinement> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::VariationalRefinement>& r)
    {
        return evision_VariationalRefinement_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::VariationalRefinement>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::VariationalRefinement> * dst_ = nullptr;
        if (evision_VariationalRefinement_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::VariationalRefinement> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// VideoCapture (Generic)
//================================================================================

// GetSet (VideoCapture)



// Methods (VideoCapture)

static ERL_NIF_TERM evision_cv_videoCapture_VideoCapture(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    {

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        evision_res<Ptr<cv::VideoCapture>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::VideoCapture>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::VideoCapture()), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::VideoCapture>>(env, self->val, ret, "VideoCapture", success);;
        }
    }

    }
    

    {
    String filename;
    int apiPreference=CAP_ANY;

    // const char* keywords[] = { "filename", "apiPreference", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "apiPreference"), apiPreference, ArgInfo("apiPreference", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::VideoCapture>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::VideoCapture>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::VideoCapture(filename, apiPreference)), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::VideoCapture>>(env, self->val, ret, "VideoCapture", success);;
        }
    }

    }
    

    {
    String filename;
    int apiPreference=0;
    vector_int params;

    // const char* keywords[] = { "filename", "apiPreference", "params", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "apiPreference"), apiPreference, ArgInfo("apiPreference", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "params"), params, ArgInfo("params", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::VideoCapture>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::VideoCapture>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::VideoCapture(filename, apiPreference, params)), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::VideoCapture>>(env, self->val, ret, "VideoCapture", success);;
        }
    }

    }
    

    {
    int index=0;
    int apiPreference=CAP_ANY;

    // const char* keywords[] = { "index", "apiPreference", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "index"), index, ArgInfo("index", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "apiPreference"), apiPreference, ArgInfo("apiPreference", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::VideoCapture>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::VideoCapture>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::VideoCapture(index, apiPreference)), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::VideoCapture>>(env, self->val, ret, "VideoCapture", success);;
        }
    }

    }
    

    {
    int index=0;
    int apiPreference=0;
    vector_int params;

    // const char* keywords[] = { "index", "apiPreference", "params", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "index"), index, ArgInfo("index", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "apiPreference"), apiPreference, ArgInfo("apiPreference", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "params"), params, ArgInfo("params", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::VideoCapture>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::VideoCapture>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::VideoCapture(index, apiPreference, params)), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::VideoCapture>>(env, self->val, ret, "VideoCapture", success);;
        }
    }

    }

    return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_videoCapture_get(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::VideoCapture> * self1 = 0;
    if (!evision_VideoCapture_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::VideoCapture>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::VideoCapture> _self_ = *(self1);
    int propId=0;
    double retval;

    // const char* keywords[] = { "propId", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "propId"), propId, ArgInfo("propId", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->get(propId), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_videoCapture_getBackendName(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::VideoCapture> * self1 = 0;
    if (!evision_VideoCapture_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::VideoCapture>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::VideoCapture> _self_ = *(self1);
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getBackendName(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_videoCapture_getExceptionMode(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::VideoCapture> * self1 = 0;
    if (!evision_VideoCapture_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::VideoCapture>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::VideoCapture> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getExceptionMode(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_videoCapture_grab(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::VideoCapture> * self1 = 0;
    if (!evision_VideoCapture_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::VideoCapture>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::VideoCapture> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->grab(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_videoCapture_isOpened(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::VideoCapture> * self1 = 0;
    if (!evision_VideoCapture_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::VideoCapture>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::VideoCapture> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->isOpened(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_videoCapture_open(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::VideoCapture> * self1 = 0;
    if (!evision_VideoCapture_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::VideoCapture>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::VideoCapture> _self_ = *(self1);

    {
    String filename;
    int apiPreference=CAP_ANY;
    bool retval;

    // const char* keywords[] = { "filename", "apiPreference", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "apiPreference"), apiPreference, ArgInfo("apiPreference", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->open(filename, apiPreference), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    String filename;
    int apiPreference=0;
    vector_int params;
    bool retval;

    // const char* keywords[] = { "filename", "apiPreference", "params", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "apiPreference"), apiPreference, ArgInfo("apiPreference", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "params"), params, ArgInfo("params", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->open(filename, apiPreference, params), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    int index=0;
    int apiPreference=CAP_ANY;
    bool retval;

    // const char* keywords[] = { "index", "apiPreference", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "index"), index, ArgInfo("index", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "apiPreference"), apiPreference, ArgInfo("apiPreference", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->open(index, apiPreference), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    int index=0;
    int apiPreference=0;
    vector_int params;
    bool retval;

    // const char* keywords[] = { "index", "apiPreference", "params", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "index"), index, ArgInfo("index", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "apiPreference"), apiPreference, ArgInfo("apiPreference", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "params"), params, ArgInfo("params", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->open(index, apiPreference, params), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_videoCapture_read(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::VideoCapture> * self1 = 0;
    if (!evision_VideoCapture_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::VideoCapture>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::VideoCapture> _self_ = *(self1);

    {
    Mat image;
    bool retval;

    // const char* keywords[] = { "image", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->read(image), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_1_tuple_except_bool
                return evision_from(env, image);
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    UMat image;
    bool retval;

    // const char* keywords[] = { "image", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->read(image), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_1_tuple_except_bool
                return evision_from(env, image);
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_videoCapture_release(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::VideoCapture> * self1 = 0;
    if (!evision_VideoCapture_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::VideoCapture>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::VideoCapture> _self_ = *(self1);

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->release(), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "VideoCapture", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_videoCapture_retrieve(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::VideoCapture> * self1 = 0;
    if (!evision_VideoCapture_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::VideoCapture>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::VideoCapture> _self_ = *(self1);

    {
    Mat image;
    int flag=0;
    bool retval;

    // const char* keywords[] = { "image", "flag", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flag"), flag, ArgInfo("flag", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->retrieve(image, flag), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_1_tuple_except_bool
                return evision_from(env, image);
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    UMat image;
    int flag=0;
    bool retval;

    // const char* keywords[] = { "image", "flag", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flag"), flag, ArgInfo("flag", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->retrieve(image, flag), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_1_tuple_except_bool
                return evision_from(env, image);
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_videoCapture_set(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::VideoCapture> * self1 = 0;
    if (!evision_VideoCapture_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::VideoCapture>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::VideoCapture> _self_ = *(self1);
    int propId=0;
    double value=0;
    bool retval;

    // const char* keywords[] = { "propId", "value", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "propId"), propId, ArgInfo("propId", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "value"), value, ArgInfo("value", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->set(propId, value), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_videoCapture_setExceptionMode(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::VideoCapture> * self1 = 0;
    if (!evision_VideoCapture_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::VideoCapture>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::VideoCapture> _self_ = *(self1);
    bool enable=0;

    // const char* keywords[] = { "enable", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "enable"), enable, ArgInfo("enable", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setExceptionMode(enable), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "VideoCapture", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (VideoCapture)

template<>
struct Evision_Converter< Ptr<cv::VideoCapture> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::VideoCapture>& r)
    {
        return evision_VideoCapture_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::VideoCapture>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::VideoCapture> * dst_ = nullptr;
        if (evision_VideoCapture_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::VideoCapture> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// VideoWriter (Generic)
//================================================================================

// GetSet (VideoWriter)



// Methods (VideoWriter)

static ERL_NIF_TERM evision_cv_videoWriter_VideoWriter(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    {

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        evision_res<Ptr<cv::VideoWriter>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::VideoWriter>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::VideoWriter()), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::VideoWriter>>(env, self->val, ret, "VideoWriter", success);;
        }
    }

    }
    

    {
    String filename;
    int fourcc=0;
    double fps=0;
    Size frameSize;
    bool isColor=true;

    // const char* keywords[] = { "filename", "fourcc", "fps", "frameSize", "isColor", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "fourcc"), fourcc, ArgInfo("fourcc", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "fps"), fps, ArgInfo("fps", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "frameSize"), frameSize, ArgInfo("frameSize", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "isColor"), isColor, ArgInfo("isColor", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::VideoWriter>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::VideoWriter>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::VideoWriter(filename, fourcc, fps, frameSize, isColor)), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::VideoWriter>>(env, self->val, ret, "VideoWriter", success);;
        }
    }

    }
    

    {
    String filename;
    int apiPreference=0;
    int fourcc=0;
    double fps=0;
    Size frameSize;
    bool isColor=true;

    // const char* keywords[] = { "filename", "apiPreference", "fourcc", "fps", "frameSize", "isColor", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "apiPreference"), apiPreference, ArgInfo("apiPreference", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "fourcc"), fourcc, ArgInfo("fourcc", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "fps"), fps, ArgInfo("fps", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "frameSize"), frameSize, ArgInfo("frameSize", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "isColor"), isColor, ArgInfo("isColor", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::VideoWriter>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::VideoWriter>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::VideoWriter(filename, apiPreference, fourcc, fps, frameSize, isColor)), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::VideoWriter>>(env, self->val, ret, "VideoWriter", success);;
        }
    }

    }
    

    {
    String filename;
    int fourcc=0;
    double fps=0;
    Size frameSize;
    vector_int params;

    // const char* keywords[] = { "filename", "fourcc", "fps", "frameSize", "params", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "fourcc"), fourcc, ArgInfo("fourcc", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "fps"), fps, ArgInfo("fps", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "frameSize"), frameSize, ArgInfo("frameSize", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "params"), params, ArgInfo("params", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::VideoWriter>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::VideoWriter>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::VideoWriter(filename, fourcc, fps, frameSize, params)), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::VideoWriter>>(env, self->val, ret, "VideoWriter", success);;
        }
    }

    }
    

    {
    String filename;
    int apiPreference=0;
    int fourcc=0;
    double fps=0;
    Size frameSize;
    vector_int params;

    // const char* keywords[] = { "filename", "apiPreference", "fourcc", "fps", "frameSize", "params", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "apiPreference"), apiPreference, ArgInfo("apiPreference", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "fourcc"), fourcc, ArgInfo("fourcc", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "fps"), fps, ArgInfo("fps", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "frameSize"), frameSize, ArgInfo("frameSize", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "params"), params, ArgInfo("params", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::VideoWriter>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::VideoWriter>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::VideoWriter(filename, apiPreference, fourcc, fps, frameSize, params)), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::VideoWriter>>(env, self->val, ret, "VideoWriter", success);;
        }
    }

    }

    return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_videoWriter_fourcc_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    char c1;
    char c2;
    char c3;
    char c4;
    int retval;

    // const char* keywords[] = { "c1", "c2", "c3", "c4", NULL }; // <- no more in use, left for debugging purpose
    if( convert_to_char(env, evision_get_kw(env, erl_terms, "c1"), &c1, ArgInfo("c1", 0)) && 
        convert_to_char(env, evision_get_kw(env, erl_terms, "c2"), &c2, ArgInfo("c2", 0)) && 
        convert_to_char(env, evision_get_kw(env, erl_terms, "c3"), &c3, ArgInfo("c3", 0)) && 
        convert_to_char(env, evision_get_kw(env, erl_terms, "c4"), &c4, ArgInfo("c4", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::VideoWriter::fourcc(c1, c2, c3, c4), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_videoWriter_get(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::VideoWriter> * self1 = 0;
    if (!evision_VideoWriter_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::VideoWriter>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::VideoWriter> _self_ = *(self1);
    int propId=0;
    double retval;

    // const char* keywords[] = { "propId", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "propId"), propId, ArgInfo("propId", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->get(propId), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_videoWriter_getBackendName(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::VideoWriter> * self1 = 0;
    if (!evision_VideoWriter_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::VideoWriter>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::VideoWriter> _self_ = *(self1);
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getBackendName(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_videoWriter_isOpened(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::VideoWriter> * self1 = 0;
    if (!evision_VideoWriter_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::VideoWriter>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::VideoWriter> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->isOpened(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_videoWriter_open(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::VideoWriter> * self1 = 0;
    if (!evision_VideoWriter_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::VideoWriter>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::VideoWriter> _self_ = *(self1);

    {
    String filename;
    int fourcc=0;
    double fps=0;
    Size frameSize;
    bool isColor=true;
    bool retval;

    // const char* keywords[] = { "filename", "fourcc", "fps", "frameSize", "isColor", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "fourcc"), fourcc, ArgInfo("fourcc", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "fps"), fps, ArgInfo("fps", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "frameSize"), frameSize, ArgInfo("frameSize", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "isColor"), isColor, ArgInfo("isColor", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->open(filename, fourcc, fps, frameSize, isColor), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    String filename;
    int apiPreference=0;
    int fourcc=0;
    double fps=0;
    Size frameSize;
    bool isColor=true;
    bool retval;

    // const char* keywords[] = { "filename", "apiPreference", "fourcc", "fps", "frameSize", "isColor", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "apiPreference"), apiPreference, ArgInfo("apiPreference", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "fourcc"), fourcc, ArgInfo("fourcc", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "fps"), fps, ArgInfo("fps", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "frameSize"), frameSize, ArgInfo("frameSize", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "isColor"), isColor, ArgInfo("isColor", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->open(filename, apiPreference, fourcc, fps, frameSize, isColor), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    String filename;
    int fourcc=0;
    double fps=0;
    Size frameSize;
    vector_int params;
    bool retval;

    // const char* keywords[] = { "filename", "fourcc", "fps", "frameSize", "params", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "fourcc"), fourcc, ArgInfo("fourcc", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "fps"), fps, ArgInfo("fps", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "frameSize"), frameSize, ArgInfo("frameSize", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "params"), params, ArgInfo("params", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->open(filename, fourcc, fps, frameSize, params), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    String filename;
    int apiPreference=0;
    int fourcc=0;
    double fps=0;
    Size frameSize;
    vector_int params;
    bool retval;

    // const char* keywords[] = { "filename", "apiPreference", "fourcc", "fps", "frameSize", "params", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "apiPreference"), apiPreference, ArgInfo("apiPreference", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "fourcc"), fourcc, ArgInfo("fourcc", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "fps"), fps, ArgInfo("fps", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "frameSize"), frameSize, ArgInfo("frameSize", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "params"), params, ArgInfo("params", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->open(filename, apiPreference, fourcc, fps, frameSize, params), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_videoWriter_release(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::VideoWriter> * self1 = 0;
    if (!evision_VideoWriter_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::VideoWriter>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::VideoWriter> _self_ = *(self1);

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->release(), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "VideoWriter", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_videoWriter_set(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::VideoWriter> * self1 = 0;
    if (!evision_VideoWriter_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::VideoWriter>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::VideoWriter> _self_ = *(self1);
    int propId=0;
    double value=0;
    bool retval;

    // const char* keywords[] = { "propId", "value", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "propId"), propId, ArgInfo("propId", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "value"), value, ArgInfo("value", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->set(propId, value), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_videoWriter_write(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::VideoWriter> * self1 = 0;
    if (!evision_VideoWriter_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::VideoWriter>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::VideoWriter> _self_ = *(self1);

    {
    Mat image;

    // const char* keywords[] = { "image", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->write(image), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "VideoWriter", success);
        }
    }

    }
    

    {
    UMat image;

    // const char* keywords[] = { "image", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->write(image), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "VideoWriter", success);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (VideoWriter)

template<>
struct Evision_Converter< Ptr<cv::VideoWriter> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::VideoWriter>& r)
    {
        return evision_VideoWriter_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::VideoWriter>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::VideoWriter> * dst_ = nullptr;
        if (evision_VideoWriter_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::VideoWriter> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// WarperCreator (Generic)
//================================================================================

// GetSet (WarperCreator)



// Methods (WarperCreator)



// Converter (WarperCreator)

template<>
struct Evision_Converter< Ptr<cv::WarperCreator> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::WarperCreator>& r)
    {
        return evision_WarperCreator_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::WarperCreator>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::WarperCreator> * dst_ = nullptr;
        if (evision_WarperCreator_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::WarperCreator> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// cuda_BufferPool (Generic)
//================================================================================

// GetSet (cuda_BufferPool)



// Methods (cuda_BufferPool)

static ERL_NIF_TERM evision_cv_cuda_cuda_BufferPool_BufferPool(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    Stream stream=Stream::Null();

    // const char* keywords[] = { "stream", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "stream"), stream, ArgInfo("stream", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::cuda::BufferPool>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::cuda::BufferPool>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::cuda::BufferPool(stream)), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::cuda::BufferPool>>(env, self->val, ret, "CUDA.BufferPool", success);;
        }
    }

    return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_BufferPool_getAllocator(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::BufferPool> * self1 = 0;
    if (!evision_cuda_BufferPool_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::BufferPool>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::BufferPool> _self_ = *(self1);
    Ptr<GpuMat::Allocator> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getAllocator(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_BufferPool_getBuffer(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::BufferPool> * self1 = 0;
    if (!evision_cuda_BufferPool_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::BufferPool>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::BufferPool> _self_ = *(self1);

    {
    int rows=0;
    int cols=0;
    int type=0;
    GpuMat retval;

    // const char* keywords[] = { "rows", "cols", "type", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "rows"), rows, ArgInfo("rows", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cols"), cols, ArgInfo("cols", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "type"), type, ArgInfo("type", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getBuffer(rows, cols, type), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Size size;
    int type=0;
    GpuMat retval;

    // const char* keywords[] = { "size", "type", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "size"), size, ArgInfo("size", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "type"), type, ArgInfo("type", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getBuffer(size, type), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (cuda_BufferPool)

template<>
struct Evision_Converter< Ptr<cv::cuda::BufferPool> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::cuda::BufferPool>& r)
    {
        return evision_cuda_BufferPool_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::cuda::BufferPool>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::cuda::BufferPool> * dst_ = nullptr;
        if (evision_cuda_BufferPool_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::cuda::BufferPool> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// cuda_DeviceInfo (Generic)
//================================================================================

// GetSet (cuda_DeviceInfo)



// Methods (cuda_DeviceInfo)

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_DeviceInfo(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    {

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        evision_res<Ptr<cv::cuda::DeviceInfo>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::cuda::DeviceInfo>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::cuda::DeviceInfo()), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::cuda::DeviceInfo>>(env, self->val, ret, "CUDA.DeviceInfo", success);;
        }
    }

    }
    

    {
    int device_id=0;

    // const char* keywords[] = { "device_id", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "device_id"), device_id, ArgInfo("device_id", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::cuda::DeviceInfo>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::cuda::DeviceInfo>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::cuda::DeviceInfo(device_id)), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::cuda::DeviceInfo>>(env, self->val, ret, "CUDA.DeviceInfo", success);;
        }
    }

    }

    return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_ECCEnabled(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!evision_cuda_DeviceInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::DeviceInfo>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->ECCEnabled(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_asyncEngineCount(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!evision_cuda_DeviceInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::DeviceInfo>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->asyncEngineCount(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_canMapHostMemory(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!evision_cuda_DeviceInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::DeviceInfo>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->canMapHostMemory(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_clockRate(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!evision_cuda_DeviceInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::DeviceInfo>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->clockRate(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_computeMode(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!evision_cuda_DeviceInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::DeviceInfo>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    DeviceInfo::ComputeMode retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->computeMode(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_concurrentKernels(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!evision_cuda_DeviceInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::DeviceInfo>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->concurrentKernels(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_deviceID(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!evision_cuda_DeviceInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::DeviceInfo>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->deviceID(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_freeMemory(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!evision_cuda_DeviceInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::DeviceInfo>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    size_t retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->freeMemory(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_integrated(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!evision_cuda_DeviceInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::DeviceInfo>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->integrated(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_isCompatible(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!evision_cuda_DeviceInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::DeviceInfo>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->isCompatible(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_kernelExecTimeoutEnabled(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!evision_cuda_DeviceInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::DeviceInfo>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->kernelExecTimeoutEnabled(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_l2CacheSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!evision_cuda_DeviceInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::DeviceInfo>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->l2CacheSize(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_majorVersion(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!evision_cuda_DeviceInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::DeviceInfo>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->majorVersion(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_maxGridSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!evision_cuda_DeviceInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::DeviceInfo>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    Vec3i retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->maxGridSize(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_maxSurface1D(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!evision_cuda_DeviceInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::DeviceInfo>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->maxSurface1D(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_maxSurface1DLayered(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!evision_cuda_DeviceInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::DeviceInfo>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    Vec2i retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->maxSurface1DLayered(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_maxSurface2D(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!evision_cuda_DeviceInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::DeviceInfo>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    Vec2i retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->maxSurface2D(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_maxSurface2DLayered(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!evision_cuda_DeviceInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::DeviceInfo>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    Vec3i retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->maxSurface2DLayered(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_maxSurface3D(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!evision_cuda_DeviceInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::DeviceInfo>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    Vec3i retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->maxSurface3D(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_maxSurfaceCubemap(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!evision_cuda_DeviceInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::DeviceInfo>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->maxSurfaceCubemap(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_maxSurfaceCubemapLayered(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!evision_cuda_DeviceInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::DeviceInfo>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    Vec2i retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->maxSurfaceCubemapLayered(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_maxTexture1D(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!evision_cuda_DeviceInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::DeviceInfo>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->maxTexture1D(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_maxTexture1DLayered(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!evision_cuda_DeviceInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::DeviceInfo>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    Vec2i retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->maxTexture1DLayered(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_maxTexture1DLinear(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!evision_cuda_DeviceInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::DeviceInfo>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->maxTexture1DLinear(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_maxTexture1DMipmap(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!evision_cuda_DeviceInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::DeviceInfo>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->maxTexture1DMipmap(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_maxTexture2D(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!evision_cuda_DeviceInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::DeviceInfo>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    Vec2i retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->maxTexture2D(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_maxTexture2DGather(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!evision_cuda_DeviceInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::DeviceInfo>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    Vec2i retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->maxTexture2DGather(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_maxTexture2DLayered(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!evision_cuda_DeviceInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::DeviceInfo>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    Vec3i retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->maxTexture2DLayered(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_maxTexture2DLinear(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!evision_cuda_DeviceInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::DeviceInfo>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    Vec3i retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->maxTexture2DLinear(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_maxTexture2DMipmap(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!evision_cuda_DeviceInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::DeviceInfo>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    Vec2i retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->maxTexture2DMipmap(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_maxTexture3D(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!evision_cuda_DeviceInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::DeviceInfo>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    Vec3i retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->maxTexture3D(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_maxTextureCubemap(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!evision_cuda_DeviceInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::DeviceInfo>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->maxTextureCubemap(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_maxTextureCubemapLayered(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!evision_cuda_DeviceInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::DeviceInfo>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    Vec2i retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->maxTextureCubemapLayered(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_maxThreadsDim(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!evision_cuda_DeviceInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::DeviceInfo>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    Vec3i retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->maxThreadsDim(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_maxThreadsPerBlock(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!evision_cuda_DeviceInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::DeviceInfo>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->maxThreadsPerBlock(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_maxThreadsPerMultiProcessor(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!evision_cuda_DeviceInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::DeviceInfo>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->maxThreadsPerMultiProcessor(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_memPitch(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!evision_cuda_DeviceInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::DeviceInfo>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    size_t retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->memPitch(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_memoryBusWidth(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!evision_cuda_DeviceInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::DeviceInfo>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->memoryBusWidth(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_memoryClockRate(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!evision_cuda_DeviceInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::DeviceInfo>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->memoryClockRate(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_minorVersion(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!evision_cuda_DeviceInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::DeviceInfo>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->minorVersion(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_multiProcessorCount(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!evision_cuda_DeviceInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::DeviceInfo>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->multiProcessorCount(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_pciBusID(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!evision_cuda_DeviceInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::DeviceInfo>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->pciBusID(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_pciDeviceID(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!evision_cuda_DeviceInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::DeviceInfo>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->pciDeviceID(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_pciDomainID(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!evision_cuda_DeviceInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::DeviceInfo>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->pciDomainID(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_queryMemory(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!evision_cuda_DeviceInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::DeviceInfo>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    size_t totalMemory=0;
    size_t freeMemory=0;

    // const char* keywords[] = { "totalMemory", "freeMemory", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "totalMemory"), totalMemory, ArgInfo("totalMemory", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "freeMemory"), freeMemory, ArgInfo("freeMemory", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->queryMemory(totalMemory, freeMemory), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "CUDA.DeviceInfo", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_regsPerBlock(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!evision_cuda_DeviceInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::DeviceInfo>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->regsPerBlock(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_sharedMemPerBlock(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!evision_cuda_DeviceInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::DeviceInfo>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    size_t retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->sharedMemPerBlock(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_surfaceAlignment(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!evision_cuda_DeviceInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::DeviceInfo>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    size_t retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->surfaceAlignment(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_tccDriver(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!evision_cuda_DeviceInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::DeviceInfo>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->tccDriver(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_textureAlignment(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!evision_cuda_DeviceInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::DeviceInfo>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    size_t retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->textureAlignment(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_texturePitchAlignment(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!evision_cuda_DeviceInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::DeviceInfo>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    size_t retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->texturePitchAlignment(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_totalConstMem(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!evision_cuda_DeviceInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::DeviceInfo>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    size_t retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->totalConstMem(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_totalGlobalMem(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!evision_cuda_DeviceInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::DeviceInfo>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    size_t retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->totalGlobalMem(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_totalMemory(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!evision_cuda_DeviceInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::DeviceInfo>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    size_t retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->totalMemory(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_unifiedAddressing(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!evision_cuda_DeviceInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::DeviceInfo>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->unifiedAddressing(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_DeviceInfo_warpSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!evision_cuda_DeviceInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::DeviceInfo>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->warpSize(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (cuda_DeviceInfo)

template<>
struct Evision_Converter< Ptr<cv::cuda::DeviceInfo> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::cuda::DeviceInfo>& r)
    {
        return evision_cuda_DeviceInfo_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::cuda::DeviceInfo>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::cuda::DeviceInfo> * dst_ = nullptr;
        if (evision_cuda_DeviceInfo_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::cuda::DeviceInfo> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// cuda_Event (Generic)
//================================================================================

// GetSet (cuda_Event)



// Methods (cuda_Event)

static ERL_NIF_TERM evision_cv_cuda_cuda_Event_Event(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    std::underlying_type_t<Event_CreateFlags> flags=static_cast<std::underlying_type_t<Event_CreateFlags>>(Event::CreateFlags::DEFAULT);

    // const char* keywords[] = { "flags", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::cuda::Event>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::cuda::Event>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::cuda::Event(static_cast<Event_CreateFlags>(flags))), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::cuda::Event>>(env, self->val, ret, "CUDA.Event", success);;
        }
    }

    return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_Event_elapsedTime_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    Event start;
    Event end_;
    float retval;

    // const char* keywords[] = { "start", "end_", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "start"), start, ArgInfo("start", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "end_"), end_, ArgInfo("end_", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::cuda::Event::elapsedTime(start, end_), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_Event_queryIfComplete(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::Event> * self1 = 0;
    if (!evision_cuda_Event_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::Event>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::Event> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->queryIfComplete(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_Event_record(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::Event> * self1 = 0;
    if (!evision_cuda_Event_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::Event>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::Event> _self_ = *(self1);
    Stream stream=Stream::Null();

    // const char* keywords[] = { "stream", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "stream"), stream, ArgInfo("stream", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->record(stream), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "CUDA.Event", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_Event_waitForCompletion(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::Event> * self1 = 0;
    if (!evision_cuda_Event_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::Event>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::Event> _self_ = *(self1);

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->waitForCompletion(), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "CUDA.Event", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (cuda_Event)

template<>
struct Evision_Converter< Ptr<cv::cuda::Event> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::cuda::Event>& r)
    {
        return evision_cuda_Event_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::cuda::Event>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::cuda::Event> * dst_ = nullptr;
        if (evision_cuda_Event_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::cuda::Event> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// cuda_GpuData (Generic)
//================================================================================

// GetSet (cuda_GpuData)



// Methods (cuda_GpuData)



// Converter (cuda_GpuData)

template<>
struct Evision_Converter< Ptr<cv::cuda::GpuData> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::cuda::GpuData>& r)
    {
        return evision_cuda_GpuData_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::cuda::GpuData>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::cuda::GpuData> * dst_ = nullptr;
        if (evision_cuda_GpuData_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::cuda::GpuData> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// cuda_GpuMat (Generic)
//================================================================================

// GetSet (cuda_GpuMat)


static ERL_NIF_TERM evision_cuda_GpuMat_get_step(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::GpuMat>* self_ptr = 0;
    if (!evision_cuda_GpuMat_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::GpuMat>` from `self`: mismatched type or invalid resource?");
    }

    Ptr<cv::cuda::GpuMat> &self2 = *self_ptr;
    cv::cuda::GpuMat* _self_ = dynamic_cast<cv::cuda::GpuMat*>(self2.get());
    return evision_from(env, _self_->step);
}


// Methods (cuda_GpuMat)

static ERL_NIF_TERM evision_cv_cuda_cuda_GpuMat_GpuMat(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    {
    GpuMat_Allocator* allocator=GpuMat::defaultAllocator();

    // const char* keywords[] = { "allocator", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "allocator"), allocator, ArgInfo("allocator", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::cuda::GpuMat>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::cuda::GpuMat>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::cuda::GpuMat(allocator)), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::cuda::GpuMat>>(env, self->val, ret, "CUDA.GpuMat", success);;
        }
    }

    }
    

    {
    int rows=0;
    int cols=0;
    int type=0;
    GpuMat_Allocator* allocator=GpuMat::defaultAllocator();

    // const char* keywords[] = { "rows", "cols", "type", "allocator", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "rows"), rows, ArgInfo("rows", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cols"), cols, ArgInfo("cols", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "type"), type, ArgInfo("type", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "allocator"), allocator, ArgInfo("allocator", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::cuda::GpuMat>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::cuda::GpuMat>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::cuda::GpuMat(rows, cols, type, allocator)), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::cuda::GpuMat>>(env, self->val, ret, "CUDA.GpuMat", success);;
        }
    }

    }
    

    {
    Size size;
    int type=0;
    GpuMat_Allocator* allocator=GpuMat::defaultAllocator();

    // const char* keywords[] = { "size", "type", "allocator", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "size"), size, ArgInfo("size", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "type"), type, ArgInfo("type", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "allocator"), allocator, ArgInfo("allocator", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::cuda::GpuMat>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::cuda::GpuMat>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::cuda::GpuMat(size, type, allocator)), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::cuda::GpuMat>>(env, self->val, ret, "CUDA.GpuMat", success);;
        }
    }

    }
    

    {
    int rows=0;
    int cols=0;
    int type=0;
    Scalar s;
    GpuMat_Allocator* allocator=GpuMat::defaultAllocator();

    // const char* keywords[] = { "rows", "cols", "type", "s", "allocator", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "rows"), rows, ArgInfo("rows", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cols"), cols, ArgInfo("cols", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "type"), type, ArgInfo("type", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "s"), s, ArgInfo("s", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "allocator"), allocator, ArgInfo("allocator", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::cuda::GpuMat>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::cuda::GpuMat>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::cuda::GpuMat(rows, cols, type, s, allocator)), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::cuda::GpuMat>>(env, self->val, ret, "CUDA.GpuMat", success);;
        }
    }

    }
    

    {
    Size size;
    int type=0;
    Scalar s;
    GpuMat_Allocator* allocator=GpuMat::defaultAllocator();

    // const char* keywords[] = { "size", "type", "s", "allocator", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "size"), size, ArgInfo("size", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "type"), type, ArgInfo("type", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "s"), s, ArgInfo("s", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "allocator"), allocator, ArgInfo("allocator", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::cuda::GpuMat>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::cuda::GpuMat>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::cuda::GpuMat(size, type, s, allocator)), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::cuda::GpuMat>>(env, self->val, ret, "CUDA.GpuMat", success);;
        }
    }

    }
    

    {
    GpuMat m;

    // const char* keywords[] = { "m", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "m"), m, ArgInfo("m", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::cuda::GpuMat>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::cuda::GpuMat>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::cuda::GpuMat(m)), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::cuda::GpuMat>>(env, self->val, ret, "CUDA.GpuMat", success);;
        }
    }

    }
    

    {
    GpuMat m;
    Range rowRange;
    Range colRange;

    // const char* keywords[] = { "m", "rowRange", "colRange", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "m"), m, ArgInfo("m", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rowRange"), rowRange, ArgInfo("rowRange", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "colRange"), colRange, ArgInfo("colRange", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::cuda::GpuMat>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::cuda::GpuMat>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::cuda::GpuMat(m, rowRange, colRange)), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::cuda::GpuMat>>(env, self->val, ret, "CUDA.GpuMat", success);;
        }
    }

    }
    

    {
    GpuMat m;
    Rect roi;

    // const char* keywords[] = { "m", "roi", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "m"), m, ArgInfo("m", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "roi"), roi, ArgInfo("roi", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::cuda::GpuMat>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::cuda::GpuMat>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::cuda::GpuMat(m, roi)), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::cuda::GpuMat>>(env, self->val, ret, "CUDA.GpuMat", success);;
        }
    }

    }
    

    {
    Mat arr;
    GpuMat_Allocator* allocator=GpuMat::defaultAllocator();

    // const char* keywords[] = { "arr", "allocator", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "arr"), arr, ArgInfo("arr", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "allocator"), allocator, ArgInfo("allocator", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::cuda::GpuMat>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::cuda::GpuMat>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::cuda::GpuMat(arr, allocator)), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::cuda::GpuMat>>(env, self->val, ret, "CUDA.GpuMat", success);;
        }
    }

    }
    

    {
    cuda::GpuMat arr;
    GpuMat_Allocator* allocator=GpuMat::defaultAllocator();

    // const char* keywords[] = { "arr", "allocator", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "arr"), arr, ArgInfo("arr", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "allocator"), allocator, ArgInfo("allocator", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::cuda::GpuMat>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::cuda::GpuMat>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::cuda::GpuMat(arr, allocator)), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::cuda::GpuMat>>(env, self->val, ret, "CUDA.GpuMat", success);;
        }
    }

    }
    

    {
    UMat arr;
    GpuMat_Allocator* allocator=GpuMat::defaultAllocator();

    // const char* keywords[] = { "arr", "allocator", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "arr"), arr, ArgInfo("arr", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "allocator"), allocator, ArgInfo("allocator", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::cuda::GpuMat>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::cuda::GpuMat>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::cuda::GpuMat(arr, allocator)), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::cuda::GpuMat>>(env, self->val, ret, "CUDA.GpuMat", success);;
        }
    }

    }

    return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_GpuMat_adjustROI(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::GpuMat> * self1 = 0;
    if (!evision_cuda_GpuMat_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::GpuMat>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::GpuMat> _self_ = *(self1);
    int dtop=0;
    int dbottom=0;
    int dleft=0;
    int dright=0;
    GpuMat retval;

    // const char* keywords[] = { "dtop", "dbottom", "dleft", "dright", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "dtop"), dtop, ArgInfo("dtop", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dbottom"), dbottom, ArgInfo("dbottom", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dleft"), dleft, ArgInfo("dleft", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dright"), dright, ArgInfo("dright", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->adjustROI(dtop, dbottom, dleft, dright), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_GpuMat_assignTo(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::GpuMat> * self1 = 0;
    if (!evision_cuda_GpuMat_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::GpuMat>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::GpuMat> _self_ = *(self1);
    GpuMat m;
    int type=-1;

    // const char* keywords[] = { "m", "type", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "m"), m, ArgInfo("m", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "type"), type, ArgInfo("type", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->assignTo(m, type), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "CUDA.GpuMat", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_GpuMat_channels(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::GpuMat> * self1 = 0;
    if (!evision_cuda_GpuMat_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::GpuMat>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::GpuMat> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->channels(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_GpuMat_clone(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::GpuMat> * self1 = 0;
    if (!evision_cuda_GpuMat_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::GpuMat>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::GpuMat> _self_ = *(self1);
    GpuMat retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->clone(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_GpuMat_col(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::GpuMat> * self1 = 0;
    if (!evision_cuda_GpuMat_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::GpuMat>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::GpuMat> _self_ = *(self1);
    int x=0;
    GpuMat retval;

    // const char* keywords[] = { "x", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "x"), x, ArgInfo("x", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->col(x), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_GpuMat_colRange(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::GpuMat> * self1 = 0;
    if (!evision_cuda_GpuMat_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::GpuMat>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::GpuMat> _self_ = *(self1);

    {
    int startcol=0;
    int endcol=0;
    GpuMat retval;

    // const char* keywords[] = { "startcol", "endcol", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "startcol"), startcol, ArgInfo("startcol", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "endcol"), endcol, ArgInfo("endcol", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->colRange(startcol, endcol), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Range r;
    GpuMat retval;

    // const char* keywords[] = { "r", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), r, ArgInfo("r", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->colRange(r), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_GpuMat_convertTo(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::GpuMat> * self1 = 0;
    if (!evision_cuda_GpuMat_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::GpuMat>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::GpuMat> _self_ = *(self1);

    {
    Mat dst;
    int rtype=0;

    // const char* keywords[] = { "rtype", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rtype"), rtype, ArgInfo("rtype", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->convertTo(dst, rtype), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    cuda::GpuMat dst;
    int rtype=0;

    // const char* keywords[] = { "rtype", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rtype"), rtype, ArgInfo("rtype", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->convertTo(dst, rtype), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    UMat dst;
    int rtype=0;

    // const char* keywords[] = { "rtype", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rtype"), rtype, ArgInfo("rtype", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->convertTo(dst, rtype), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Mat dst;
    int rtype=0;
    Stream stream=Stream::Null();

    // const char* keywords[] = { "rtype", "stream", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rtype"), rtype, ArgInfo("rtype", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stream"), stream, ArgInfo("stream", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->convertTo(dst, rtype, stream), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    cuda::GpuMat dst;
    int rtype=0;
    Stream stream=Stream::Null();

    // const char* keywords[] = { "rtype", "stream", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rtype"), rtype, ArgInfo("rtype", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stream"), stream, ArgInfo("stream", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->convertTo(dst, rtype, stream), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    UMat dst;
    int rtype=0;
    Stream stream=Stream::Null();

    // const char* keywords[] = { "rtype", "stream", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rtype"), rtype, ArgInfo("rtype", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stream"), stream, ArgInfo("stream", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->convertTo(dst, rtype, stream), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Mat dst;
    int rtype=0;
    double alpha=0;
    double beta=0.0;

    // const char* keywords[] = { "rtype", "alpha", "dst", "beta", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rtype"), rtype, ArgInfo("rtype", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "alpha"), alpha, ArgInfo("alpha", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "beta"), beta, ArgInfo("beta", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->convertTo(dst, rtype, alpha, beta), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    cuda::GpuMat dst;
    int rtype=0;
    double alpha=0;
    double beta=0.0;

    // const char* keywords[] = { "rtype", "alpha", "dst", "beta", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rtype"), rtype, ArgInfo("rtype", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "alpha"), alpha, ArgInfo("alpha", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "beta"), beta, ArgInfo("beta", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->convertTo(dst, rtype, alpha, beta), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    UMat dst;
    int rtype=0;
    double alpha=0;
    double beta=0.0;

    // const char* keywords[] = { "rtype", "alpha", "dst", "beta", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rtype"), rtype, ArgInfo("rtype", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "alpha"), alpha, ArgInfo("alpha", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "beta"), beta, ArgInfo("beta", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->convertTo(dst, rtype, alpha, beta), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Mat dst;
    int rtype=0;
    double alpha=0;
    Stream stream=Stream::Null();

    // const char* keywords[] = { "rtype", "alpha", "stream", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rtype"), rtype, ArgInfo("rtype", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "alpha"), alpha, ArgInfo("alpha", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stream"), stream, ArgInfo("stream", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->convertTo(dst, rtype, alpha, stream), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    cuda::GpuMat dst;
    int rtype=0;
    double alpha=0;
    Stream stream=Stream::Null();

    // const char* keywords[] = { "rtype", "alpha", "stream", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rtype"), rtype, ArgInfo("rtype", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "alpha"), alpha, ArgInfo("alpha", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stream"), stream, ArgInfo("stream", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->convertTo(dst, rtype, alpha, stream), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    UMat dst;
    int rtype=0;
    double alpha=0;
    Stream stream=Stream::Null();

    // const char* keywords[] = { "rtype", "alpha", "stream", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rtype"), rtype, ArgInfo("rtype", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "alpha"), alpha, ArgInfo("alpha", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stream"), stream, ArgInfo("stream", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->convertTo(dst, rtype, alpha, stream), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Mat dst;
    int rtype=0;
    double alpha=0;
    double beta=0;
    Stream stream=Stream::Null();

    // const char* keywords[] = { "rtype", "alpha", "beta", "stream", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rtype"), rtype, ArgInfo("rtype", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "alpha"), alpha, ArgInfo("alpha", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "beta"), beta, ArgInfo("beta", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stream"), stream, ArgInfo("stream", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->convertTo(dst, rtype, alpha, beta, stream), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    cuda::GpuMat dst;
    int rtype=0;
    double alpha=0;
    double beta=0;
    Stream stream=Stream::Null();

    // const char* keywords[] = { "rtype", "alpha", "beta", "stream", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rtype"), rtype, ArgInfo("rtype", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "alpha"), alpha, ArgInfo("alpha", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "beta"), beta, ArgInfo("beta", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stream"), stream, ArgInfo("stream", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->convertTo(dst, rtype, alpha, beta, stream), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    UMat dst;
    int rtype=0;
    double alpha=0;
    double beta=0;
    Stream stream=Stream::Null();

    // const char* keywords[] = { "rtype", "alpha", "beta", "stream", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rtype"), rtype, ArgInfo("rtype", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "alpha"), alpha, ArgInfo("alpha", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "beta"), beta, ArgInfo("beta", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stream"), stream, ArgInfo("stream", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->convertTo(dst, rtype, alpha, beta, stream), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_GpuMat_copyTo(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::GpuMat> * self1 = 0;
    if (!evision_cuda_GpuMat_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::GpuMat>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::GpuMat> _self_ = *(self1);

    {
    Mat dst;

    // const char* keywords[] = { "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->copyTo(dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    cuda::GpuMat dst;

    // const char* keywords[] = { "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->copyTo(dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    UMat dst;

    // const char* keywords[] = { "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->copyTo(dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Mat dst;
    Stream stream=Stream::Null();

    // const char* keywords[] = { "stream", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stream"), stream, ArgInfo("stream", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->copyTo(dst, stream), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    cuda::GpuMat dst;
    Stream stream=Stream::Null();

    // const char* keywords[] = { "stream", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stream"), stream, ArgInfo("stream", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->copyTo(dst, stream), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    UMat dst;
    Stream stream=Stream::Null();

    // const char* keywords[] = { "stream", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stream"), stream, ArgInfo("stream", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->copyTo(dst, stream), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Mat dst;
    Mat mask;

    // const char* keywords[] = { "mask", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->copyTo(dst, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    cuda::GpuMat dst;
    cuda::GpuMat mask;

    // const char* keywords[] = { "mask", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->copyTo(dst, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    UMat dst;
    UMat mask;

    // const char* keywords[] = { "mask", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->copyTo(dst, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Mat dst;
    Mat mask;
    Stream stream=Stream::Null();

    // const char* keywords[] = { "mask", "stream", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stream"), stream, ArgInfo("stream", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->copyTo(dst, mask, stream), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    cuda::GpuMat dst;
    cuda::GpuMat mask;
    Stream stream=Stream::Null();

    // const char* keywords[] = { "mask", "stream", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stream"), stream, ArgInfo("stream", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->copyTo(dst, mask, stream), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    UMat dst;
    UMat mask;
    Stream stream=Stream::Null();

    // const char* keywords[] = { "mask", "stream", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stream"), stream, ArgInfo("stream", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->copyTo(dst, mask, stream), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_GpuMat_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::GpuMat> * self1 = 0;
    if (!evision_cuda_GpuMat_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::GpuMat>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::GpuMat> _self_ = *(self1);

    {
    int rows=0;
    int cols=0;
    int type=0;

    // const char* keywords[] = { "rows", "cols", "type", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "rows"), rows, ArgInfo("rows", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cols"), cols, ArgInfo("cols", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "type"), type, ArgInfo("type", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->create(rows, cols, type), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "CUDA.GpuMat", success);
        }
    }

    }
    

    {
    Size size;
    int type=0;

    // const char* keywords[] = { "size", "type", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "size"), size, ArgInfo("size", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "type"), type, ArgInfo("type", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->create(size, type), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "CUDA.GpuMat", success);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_GpuMat_cudaPtr(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::GpuMat> * self1 = 0;
    if (!evision_cuda_GpuMat_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::GpuMat>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::GpuMat> _self_ = *(self1);
    void* retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->cudaPtr(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_GpuMat_defaultAllocator_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    GpuMat::Allocator* retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::cuda::GpuMat::defaultAllocator(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_GpuMat_depth(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::GpuMat> * self1 = 0;
    if (!evision_cuda_GpuMat_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::GpuMat>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::GpuMat> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->depth(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_GpuMat_download(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::GpuMat> * self1 = 0;
    if (!evision_cuda_GpuMat_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::GpuMat>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::GpuMat> _self_ = *(self1);

    {
    Mat dst;

    // const char* keywords[] = { "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->download(dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    cuda::GpuMat dst;

    // const char* keywords[] = { "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->download(dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    UMat dst;

    // const char* keywords[] = { "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->download(dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Mat dst;
    Stream stream=Stream::Null();

    // const char* keywords[] = { "stream", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stream"), stream, ArgInfo("stream", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->download(dst, stream), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    cuda::GpuMat dst;
    Stream stream=Stream::Null();

    // const char* keywords[] = { "stream", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stream"), stream, ArgInfo("stream", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->download(dst, stream), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    UMat dst;
    Stream stream=Stream::Null();

    // const char* keywords[] = { "stream", "dst", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stream"), stream, ArgInfo("stream", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->download(dst, stream), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_GpuMat_elemSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::GpuMat> * self1 = 0;
    if (!evision_cuda_GpuMat_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::GpuMat>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::GpuMat> _self_ = *(self1);
    size_t retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->elemSize(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_GpuMat_elemSize1(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::GpuMat> * self1 = 0;
    if (!evision_cuda_GpuMat_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::GpuMat>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::GpuMat> _self_ = *(self1);
    size_t retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->elemSize1(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_GpuMat_empty(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::GpuMat> * self1 = 0;
    if (!evision_cuda_GpuMat_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::GpuMat>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::GpuMat> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->empty(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_GpuMat_isContinuous(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::GpuMat> * self1 = 0;
    if (!evision_cuda_GpuMat_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::GpuMat>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::GpuMat> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->isContinuous(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_GpuMat_locateROI(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::GpuMat> * self1 = 0;
    if (!evision_cuda_GpuMat_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::GpuMat>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::GpuMat> _self_ = *(self1);
    Size wholeSize;
    Point ofs;

    // const char* keywords[] = { "wholeSize", "ofs", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "wholeSize"), wholeSize, ArgInfo("wholeSize", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ofs"), ofs, ArgInfo("ofs", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->locateROI(wholeSize, ofs), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "CUDA.GpuMat", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_GpuMat_release(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::GpuMat> * self1 = 0;
    if (!evision_cuda_GpuMat_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::GpuMat>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::GpuMat> _self_ = *(self1);

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->release(), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "CUDA.GpuMat", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_GpuMat_reshape(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::GpuMat> * self1 = 0;
    if (!evision_cuda_GpuMat_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::GpuMat>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::GpuMat> _self_ = *(self1);
    int cn=0;
    int rows=0;
    GpuMat retval;

    // const char* keywords[] = { "cn", "rows", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "cn"), cn, ArgInfo("cn", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rows"), rows, ArgInfo("rows", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->reshape(cn, rows), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_GpuMat_row(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::GpuMat> * self1 = 0;
    if (!evision_cuda_GpuMat_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::GpuMat>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::GpuMat> _self_ = *(self1);
    int y=0;
    GpuMat retval;

    // const char* keywords[] = { "y", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "y"), y, ArgInfo("y", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->row(y), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_GpuMat_rowRange(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::GpuMat> * self1 = 0;
    if (!evision_cuda_GpuMat_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::GpuMat>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::GpuMat> _self_ = *(self1);

    {
    int startrow=0;
    int endrow=0;
    GpuMat retval;

    // const char* keywords[] = { "startrow", "endrow", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "startrow"), startrow, ArgInfo("startrow", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "endrow"), endrow, ArgInfo("endrow", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->rowRange(startrow, endrow), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Range r;
    GpuMat retval;

    // const char* keywords[] = { "r", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), r, ArgInfo("r", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->rowRange(r), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_GpuMat_setDefaultAllocator_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    GpuMat_Allocator* allocator;

    // const char* keywords[] = { "allocator", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "allocator"), allocator, ArgInfo("allocator", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(cv::cuda::GpuMat::setDefaultAllocator(allocator), env, error_flag, error_term);
        if (!error_flag) {
            return evision::nif::atom(env, "ok");
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_GpuMat_setTo(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::GpuMat> * self1 = 0;
    if (!evision_cuda_GpuMat_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::GpuMat>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::GpuMat> _self_ = *(self1);

    {
    Scalar s;
    GpuMat retval;

    // const char* keywords[] = { "s", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "s"), s, ArgInfo("s", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->setTo(s), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Scalar s;
    Stream stream=Stream::Null();
    GpuMat retval;

    // const char* keywords[] = { "s", "stream", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "s"), s, ArgInfo("s", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stream"), stream, ArgInfo("stream", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->setTo(s, stream), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Scalar s;
    Mat mask;
    GpuMat retval;

    // const char* keywords[] = { "s", "mask", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "s"), s, ArgInfo("s", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->setTo(s, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Scalar s;
    cuda::GpuMat mask;
    GpuMat retval;

    // const char* keywords[] = { "s", "mask", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "s"), s, ArgInfo("s", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->setTo(s, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Scalar s;
    UMat mask;
    GpuMat retval;

    // const char* keywords[] = { "s", "mask", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "s"), s, ArgInfo("s", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->setTo(s, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Scalar s;
    Mat mask;
    Stream stream=Stream::Null();
    GpuMat retval;

    // const char* keywords[] = { "s", "mask", "stream", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "s"), s, ArgInfo("s", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stream"), stream, ArgInfo("stream", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->setTo(s, mask, stream), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Scalar s;
    cuda::GpuMat mask;
    Stream stream=Stream::Null();
    GpuMat retval;

    // const char* keywords[] = { "s", "mask", "stream", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "s"), s, ArgInfo("s", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stream"), stream, ArgInfo("stream", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->setTo(s, mask, stream), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Scalar s;
    UMat mask;
    Stream stream=Stream::Null();
    GpuMat retval;

    // const char* keywords[] = { "s", "mask", "stream", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "s"), s, ArgInfo("s", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stream"), stream, ArgInfo("stream", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->setTo(s, mask, stream), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_GpuMat_size(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::GpuMat> * self1 = 0;
    if (!evision_cuda_GpuMat_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::GpuMat>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::GpuMat> _self_ = *(self1);
    Size retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->size(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_GpuMat_step1(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::GpuMat> * self1 = 0;
    if (!evision_cuda_GpuMat_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::GpuMat>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::GpuMat> _self_ = *(self1);
    size_t retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->step1(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_GpuMat_swap(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::GpuMat> * self1 = 0;
    if (!evision_cuda_GpuMat_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::GpuMat>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::GpuMat> _self_ = *(self1);
    GpuMat mat;

    // const char* keywords[] = { "mat", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "mat"), mat, ArgInfo("mat", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->swap(mat), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "CUDA.GpuMat", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_GpuMat_type(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::GpuMat> * self1 = 0;
    if (!evision_cuda_GpuMat_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::GpuMat>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::GpuMat> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->type(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_GpuMat_updateContinuityFlag(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::GpuMat> * self1 = 0;
    if (!evision_cuda_GpuMat_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::GpuMat>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::GpuMat> _self_ = *(self1);

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->updateContinuityFlag(), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "CUDA.GpuMat", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_GpuMat_upload(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::GpuMat> * self1 = 0;
    if (!evision_cuda_GpuMat_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::GpuMat>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::GpuMat> _self_ = *(self1);

    {
    Mat arr;

    // const char* keywords[] = { "arr", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "arr"), arr, ArgInfo("arr", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->upload(arr), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "CUDA.GpuMat", success);
        }
    }

    }
    

    {
    cuda::GpuMat arr;

    // const char* keywords[] = { "arr", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "arr"), arr, ArgInfo("arr", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->upload(arr), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "CUDA.GpuMat", success);
        }
    }

    }
    

    {
    UMat arr;

    // const char* keywords[] = { "arr", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "arr"), arr, ArgInfo("arr", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->upload(arr), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "CUDA.GpuMat", success);
        }
    }

    }
    

    {
    Mat arr;
    Stream stream=Stream::Null();

    // const char* keywords[] = { "arr", "stream", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "arr"), arr, ArgInfo("arr", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stream"), stream, ArgInfo("stream", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->upload(arr, stream), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "CUDA.GpuMat", success);
        }
    }

    }
    

    {
    cuda::GpuMat arr;
    Stream stream=Stream::Null();

    // const char* keywords[] = { "arr", "stream", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "arr"), arr, ArgInfo("arr", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stream"), stream, ArgInfo("stream", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->upload(arr, stream), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "CUDA.GpuMat", success);
        }
    }

    }
    

    {
    UMat arr;
    Stream stream=Stream::Null();

    // const char* keywords[] = { "arr", "stream", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "arr"), arr, ArgInfo("arr", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stream"), stream, ArgInfo("stream", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->upload(arr, stream), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "CUDA.GpuMat", success);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (cuda_GpuMat)

template<>
struct Evision_Converter< Ptr<cv::cuda::GpuMat> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::cuda::GpuMat>& r)
    {
        return evision_cuda_GpuMat_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::cuda::GpuMat>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::cuda::GpuMat> * dst_ = nullptr;
        if (evision_cuda_GpuMat_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::cuda::GpuMat> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// cuda_GpuMatND (Generic)
//================================================================================

// GetSet (cuda_GpuMatND)



// Methods (cuda_GpuMatND)



// Converter (cuda_GpuMatND)

template<>
struct Evision_Converter< Ptr<cv::cuda::GpuMatND> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::cuda::GpuMatND>& r)
    {
        return evision_cuda_GpuMatND_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::cuda::GpuMatND>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::cuda::GpuMatND> * dst_ = nullptr;
        if (evision_cuda_GpuMatND_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::cuda::GpuMatND> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// cuda_GpuMat_Allocator (Generic)
//================================================================================

// GetSet (cuda_GpuMat_Allocator)



// Methods (cuda_GpuMat_Allocator)



// Converter (cuda_GpuMat_Allocator)

template<>
struct Evision_Converter< Ptr<cv::cuda::GpuMat::Allocator> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::cuda::GpuMat::Allocator>& r)
    {
        return evision_cuda_GpuMat_Allocator_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::cuda::GpuMat::Allocator>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::cuda::GpuMat::Allocator> * dst_ = nullptr;
        if (evision_cuda_GpuMat_Allocator_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::cuda::GpuMat::Allocator> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// cuda_HostMem (Generic)
//================================================================================

// GetSet (cuda_HostMem)


static ERL_NIF_TERM evision_cuda_HostMem_get_step(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::HostMem>* self_ptr = 0;
    if (!evision_cuda_HostMem_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::HostMem>` from `self`: mismatched type or invalid resource?");
    }

    Ptr<cv::cuda::HostMem> &self2 = *self_ptr;
    cv::cuda::HostMem* _self_ = dynamic_cast<cv::cuda::HostMem*>(self2.get());
    return evision_from(env, _self_->step);
}


// Methods (cuda_HostMem)

static ERL_NIF_TERM evision_cv_cuda_cuda_HostMem_HostMem(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    {
    std::underlying_type_t<HostMem_AllocType> alloc_type=static_cast<std::underlying_type_t<HostMem_AllocType>>(HostMem::AllocType::PAGE_LOCKED);

    // const char* keywords[] = { "alloc_type", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "alloc_type"), alloc_type, ArgInfo("alloc_type", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::cuda::HostMem>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::cuda::HostMem>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::cuda::HostMem(static_cast<HostMem_AllocType>(alloc_type))), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::cuda::HostMem>>(env, self->val, ret, "CUDA.HostMem", success);;
        }
    }

    }
    

    {
    int rows=0;
    int cols=0;
    int type=0;
    std::underlying_type_t<HostMem_AllocType> alloc_type=static_cast<std::underlying_type_t<HostMem_AllocType>>(HostMem::AllocType::PAGE_LOCKED);

    // const char* keywords[] = { "rows", "cols", "type", "alloc_type", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "rows"), rows, ArgInfo("rows", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cols"), cols, ArgInfo("cols", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "type"), type, ArgInfo("type", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "alloc_type"), alloc_type, ArgInfo("alloc_type", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::cuda::HostMem>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::cuda::HostMem>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::cuda::HostMem(rows, cols, type, static_cast<HostMem_AllocType>(alloc_type))), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::cuda::HostMem>>(env, self->val, ret, "CUDA.HostMem", success);;
        }
    }

    }
    

    {
    Size size;
    int type=0;
    std::underlying_type_t<HostMem_AllocType> alloc_type=static_cast<std::underlying_type_t<HostMem_AllocType>>(HostMem::AllocType::PAGE_LOCKED);

    // const char* keywords[] = { "size", "type", "alloc_type", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "size"), size, ArgInfo("size", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "type"), type, ArgInfo("type", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "alloc_type"), alloc_type, ArgInfo("alloc_type", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::cuda::HostMem>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::cuda::HostMem>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::cuda::HostMem(size, type, static_cast<HostMem_AllocType>(alloc_type))), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::cuda::HostMem>>(env, self->val, ret, "CUDA.HostMem", success);;
        }
    }

    }
    

    {
    Mat arr;
    std::underlying_type_t<HostMem_AllocType> alloc_type=static_cast<std::underlying_type_t<HostMem_AllocType>>(HostMem::AllocType::PAGE_LOCKED);

    // const char* keywords[] = { "arr", "alloc_type", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "arr"), arr, ArgInfo("arr", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "alloc_type"), alloc_type, ArgInfo("alloc_type", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::cuda::HostMem>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::cuda::HostMem>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::cuda::HostMem(arr, static_cast<HostMem_AllocType>(alloc_type))), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::cuda::HostMem>>(env, self->val, ret, "CUDA.HostMem", success);;
        }
    }

    }
    

    {
    cuda::GpuMat arr;
    std::underlying_type_t<HostMem_AllocType> alloc_type=static_cast<std::underlying_type_t<HostMem_AllocType>>(HostMem::AllocType::PAGE_LOCKED);

    // const char* keywords[] = { "arr", "alloc_type", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "arr"), arr, ArgInfo("arr", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "alloc_type"), alloc_type, ArgInfo("alloc_type", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::cuda::HostMem>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::cuda::HostMem>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::cuda::HostMem(arr, static_cast<HostMem_AllocType>(alloc_type))), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::cuda::HostMem>>(env, self->val, ret, "CUDA.HostMem", success);;
        }
    }

    }
    

    {
    UMat arr;
    std::underlying_type_t<HostMem_AllocType> alloc_type=static_cast<std::underlying_type_t<HostMem_AllocType>>(HostMem::AllocType::PAGE_LOCKED);

    // const char* keywords[] = { "arr", "alloc_type", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "arr"), arr, ArgInfo("arr", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "alloc_type"), alloc_type, ArgInfo("alloc_type", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::cuda::HostMem>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::cuda::HostMem>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::cuda::HostMem(arr, static_cast<HostMem_AllocType>(alloc_type))), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::cuda::HostMem>>(env, self->val, ret, "CUDA.HostMem", success);;
        }
    }

    }

    return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_HostMem_channels(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::HostMem> * self1 = 0;
    if (!evision_cuda_HostMem_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::HostMem>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::HostMem> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->channels(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_HostMem_clone(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::HostMem> * self1 = 0;
    if (!evision_cuda_HostMem_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::HostMem>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::HostMem> _self_ = *(self1);
    HostMem retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->clone(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_HostMem_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::HostMem> * self1 = 0;
    if (!evision_cuda_HostMem_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::HostMem>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::HostMem> _self_ = *(self1);
    int rows=0;
    int cols=0;
    int type=0;

    // const char* keywords[] = { "rows", "cols", "type", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "rows"), rows, ArgInfo("rows", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cols"), cols, ArgInfo("cols", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "type"), type, ArgInfo("type", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->create(rows, cols, type), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "CUDA.HostMem", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_HostMem_createMatHeader(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::HostMem> * self1 = 0;
    if (!evision_cuda_HostMem_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::HostMem>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::HostMem> _self_ = *(self1);
    Mat retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->createMatHeader(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_HostMem_depth(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::HostMem> * self1 = 0;
    if (!evision_cuda_HostMem_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::HostMem>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::HostMem> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->depth(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_HostMem_elemSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::HostMem> * self1 = 0;
    if (!evision_cuda_HostMem_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::HostMem>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::HostMem> _self_ = *(self1);
    size_t retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->elemSize(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_HostMem_elemSize1(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::HostMem> * self1 = 0;
    if (!evision_cuda_HostMem_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::HostMem>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::HostMem> _self_ = *(self1);
    size_t retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->elemSize1(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_HostMem_empty(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::HostMem> * self1 = 0;
    if (!evision_cuda_HostMem_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::HostMem>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::HostMem> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->empty(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_HostMem_isContinuous(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::HostMem> * self1 = 0;
    if (!evision_cuda_HostMem_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::HostMem>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::HostMem> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->isContinuous(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_HostMem_reshape(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::HostMem> * self1 = 0;
    if (!evision_cuda_HostMem_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::HostMem>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::HostMem> _self_ = *(self1);
    int cn=0;
    int rows=0;
    HostMem retval;

    // const char* keywords[] = { "cn", "rows", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "cn"), cn, ArgInfo("cn", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rows"), rows, ArgInfo("rows", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->reshape(cn, rows), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_HostMem_size(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::HostMem> * self1 = 0;
    if (!evision_cuda_HostMem_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::HostMem>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::HostMem> _self_ = *(self1);
    Size retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->size(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_HostMem_step1(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::HostMem> * self1 = 0;
    if (!evision_cuda_HostMem_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::HostMem>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::HostMem> _self_ = *(self1);
    size_t retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->step1(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_HostMem_swap(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::HostMem> * self1 = 0;
    if (!evision_cuda_HostMem_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::HostMem>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::HostMem> _self_ = *(self1);
    HostMem b;

    // const char* keywords[] = { "b", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "b"), b, ArgInfo("b", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->swap(b), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "CUDA.HostMem", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_HostMem_type(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::HostMem> * self1 = 0;
    if (!evision_cuda_HostMem_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::HostMem>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::HostMem> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->type(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (cuda_HostMem)

template<>
struct Evision_Converter< Ptr<cv::cuda::HostMem> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::cuda::HostMem>& r)
    {
        return evision_cuda_HostMem_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::cuda::HostMem>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::cuda::HostMem> * dst_ = nullptr;
        if (evision_cuda_HostMem_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::cuda::HostMem> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// cuda_Stream (Generic)
//================================================================================

// GetSet (cuda_Stream)



// Methods (cuda_Stream)

static ERL_NIF_TERM evision_cv_cuda_cuda_Stream_Stream(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    {

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        evision_res<Ptr<cv::cuda::Stream>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::cuda::Stream>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::cuda::Stream()), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::cuda::Stream>>(env, self->val, ret, "CUDA.Stream", success);;
        }
    }

    }
    

    {
    Ptr<GpuMat::Allocator> allocator;

    // const char* keywords[] = { "allocator", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "allocator"), allocator, ArgInfo("allocator", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::cuda::Stream>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::cuda::Stream>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::cuda::Stream(allocator)), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::cuda::Stream>>(env, self->val, ret, "CUDA.Stream", success);;
        }
    }

    }
    

    {
    size_t cudaFlags=0;

    // const char* keywords[] = { "cudaFlags", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "cudaFlags"), cudaFlags, ArgInfo("cudaFlags", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::cuda::Stream>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::cuda::Stream>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::cuda::Stream(cudaFlags)), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::cuda::Stream>>(env, self->val, ret, "CUDA.Stream", success);;
        }
    }

    }

    return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_Stream_Null_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    Stream retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::cuda::Stream::Null(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_Stream_cudaPtr(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::Stream> * self1 = 0;
    if (!evision_cuda_Stream_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::Stream>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::Stream> _self_ = *(self1);
    void* retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->cudaPtr(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_Stream_queryIfComplete(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::Stream> * self1 = 0;
    if (!evision_cuda_Stream_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::Stream>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::Stream> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->queryIfComplete(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_Stream_waitEvent(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::Stream> * self1 = 0;
    if (!evision_cuda_Stream_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::Stream>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::Stream> _self_ = *(self1);
    Event event;

    // const char* keywords[] = { "event", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "event"), event, ArgInfo("event", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->waitEvent(event), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "CUDA.Stream", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_Stream_waitForCompletion(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::cuda::Stream> * self1 = 0;
    if (!evision_cuda_Stream_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::cuda::Stream>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::cuda::Stream> _self_ = *(self1);

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->waitForCompletion(), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "CUDA.Stream", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (cuda_Stream)

template<>
struct Evision_Converter< Ptr<cv::cuda::Stream> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::cuda::Stream>& r)
    {
        return evision_cuda_Stream_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::cuda::Stream>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::cuda::Stream> * dst_ = nullptr;
        if (evision_cuda_Stream_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::cuda::Stream> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// cuda_TargetArchs (Generic)
//================================================================================

// GetSet (cuda_TargetArchs)



// Methods (cuda_TargetArchs)

static ERL_NIF_TERM evision_cv_cuda_cuda_TargetArchs_has_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    int major=0;
    int minor=0;
    bool retval;

    // const char* keywords[] = { "major", "minor", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "major"), major, ArgInfo("major", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minor"), minor, ArgInfo("minor", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::cuda::TargetArchs::has(major, minor), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_TargetArchs_hasBin_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    int major=0;
    int minor=0;
    bool retval;

    // const char* keywords[] = { "major", "minor", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "major"), major, ArgInfo("major", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minor"), minor, ArgInfo("minor", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::cuda::TargetArchs::hasBin(major, minor), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_TargetArchs_hasEqualOrGreater_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    int major=0;
    int minor=0;
    bool retval;

    // const char* keywords[] = { "major", "minor", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "major"), major, ArgInfo("major", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minor"), minor, ArgInfo("minor", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::cuda::TargetArchs::hasEqualOrGreater(major, minor), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_TargetArchs_hasEqualOrGreaterBin_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    int major=0;
    int minor=0;
    bool retval;

    // const char* keywords[] = { "major", "minor", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "major"), major, ArgInfo("major", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minor"), minor, ArgInfo("minor", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::cuda::TargetArchs::hasEqualOrGreaterBin(major, minor), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_TargetArchs_hasEqualOrGreaterPtx_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    int major=0;
    int minor=0;
    bool retval;

    // const char* keywords[] = { "major", "minor", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "major"), major, ArgInfo("major", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minor"), minor, ArgInfo("minor", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::cuda::TargetArchs::hasEqualOrGreaterPtx(major, minor), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_TargetArchs_hasEqualOrLessPtx_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    int major=0;
    int minor=0;
    bool retval;

    // const char* keywords[] = { "major", "minor", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "major"), major, ArgInfo("major", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minor"), minor, ArgInfo("minor", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::cuda::TargetArchs::hasEqualOrLessPtx(major, minor), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_cuda_TargetArchs_hasPtx_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    int major=0;
    int minor=0;
    bool retval;

    // const char* keywords[] = { "major", "minor", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "major"), major, ArgInfo("major", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minor"), minor, ArgInfo("minor", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::cuda::TargetArchs::hasPtx(major, minor), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (cuda_TargetArchs)

template<>
struct Evision_Converter< Ptr<cv::cuda::TargetArchs> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::cuda::TargetArchs>& r)
    {
        return evision_cuda_TargetArchs_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::cuda::TargetArchs>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::cuda::TargetArchs> * dst_ = nullptr;
        if (evision_cuda_TargetArchs_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::cuda::TargetArchs> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// detail_AffineBasedEstimator (Generic)
//================================================================================

// GetSet (detail_AffineBasedEstimator)



// Methods (detail_AffineBasedEstimator)

static ERL_NIF_TERM evision_cv_detail_detail_AffineBasedEstimator_AffineBasedEstimator(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        evision_res<Ptr<cv::detail::AffineBasedEstimator>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::detail::AffineBasedEstimator>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::detail::AffineBasedEstimator()), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::detail::AffineBasedEstimator>>(env, self->val, ret, "Detail.AffineBasedEstimator", success);;
        }
    }

    return enif_make_badarg(env);
}



// Converter (detail_AffineBasedEstimator)

template<>
struct Evision_Converter< Ptr<cv::detail::AffineBasedEstimator> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::detail::AffineBasedEstimator>& r)
    {
        return evision_detail_AffineBasedEstimator_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::detail::AffineBasedEstimator>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::detail::AffineBasedEstimator> * dst_ = nullptr;
        if (evision_detail_AffineBasedEstimator_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::detail::AffineBasedEstimator> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// detail_AffineBestOf2NearestMatcher (Generic)
//================================================================================

// GetSet (detail_AffineBestOf2NearestMatcher)



// Methods (detail_AffineBestOf2NearestMatcher)

static ERL_NIF_TERM evision_cv_detail_detail_AffineBestOf2NearestMatcher_AffineBestOf2NearestMatcher(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    bool full_affine=false;
    bool try_use_gpu=false;
    float match_conf=0.3f;
    int num_matches_thresh1=6;

    // const char* keywords[] = { "full_affine", "try_use_gpu", "match_conf", "num_matches_thresh1", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "full_affine"), full_affine, ArgInfo("full_affine", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "try_use_gpu"), try_use_gpu, ArgInfo("try_use_gpu", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "match_conf"), match_conf, ArgInfo("match_conf", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "num_matches_thresh1"), num_matches_thresh1, ArgInfo("num_matches_thresh1", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::detail::AffineBestOf2NearestMatcher>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::detail::AffineBestOf2NearestMatcher>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::detail::AffineBestOf2NearestMatcher(full_affine, try_use_gpu, match_conf, num_matches_thresh1)), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::detail::AffineBestOf2NearestMatcher>>(env, self->val, ret, "Detail.AffineBestOf2NearestMatcher", success);;
        }
    }

    return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_AffineBestOf2NearestMatcher_apply(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::AffineBestOf2NearestMatcher> * self1 = 0;
    if (!evision_detail_AffineBestOf2NearestMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::AffineBestOf2NearestMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::AffineBestOf2NearestMatcher> _self_ = *(self1);
    ImageFeatures features1;
    ImageFeatures features2;
    MatchesInfo matches_info;

    // const char* keywords[] = { "features1", "features2", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "features1"), features1, ArgInfo("features1", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "features2"), features2, ArgInfo("features2", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detail::FeaturesMatcher::operator ()(features1, features2, matches_info), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, matches_info);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_AffineBestOf2NearestMatcher_apply2(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::AffineBestOf2NearestMatcher> * self1 = 0;
    if (!evision_detail_AffineBestOf2NearestMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::AffineBestOf2NearestMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::AffineBestOf2NearestMatcher> _self_ = *(self1);
    vector_ImageFeatures features;
    vector_MatchesInfo pairwise_matches;
    UMat mask=cv::UMat();

    // const char* keywords[] = { "features", "mask", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "features"), features, ArgInfo("features", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detail::FeaturesMatcher::operator ()(features, pairwise_matches, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, pairwise_matches);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_AffineBestOf2NearestMatcher_collectGarbage(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::AffineBestOf2NearestMatcher> * self1 = 0;
    if (!evision_detail_AffineBestOf2NearestMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::AffineBestOf2NearestMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::AffineBestOf2NearestMatcher> _self_ = *(self1);

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->detail::BestOf2NearestMatcher::collectGarbage(), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Detail.AffineBestOf2NearestMatcher", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_AffineBestOf2NearestMatcher_create_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    bool try_use_gpu=false;
    float match_conf=0.3f;
    int num_matches_thresh1=6;
    int num_matches_thresh2=6;
    Ptr<BestOf2NearestMatcher> retval;

    // const char* keywords[] = { "try_use_gpu", "match_conf", "num_matches_thresh1", "num_matches_thresh2", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "try_use_gpu"), try_use_gpu, ArgInfo("try_use_gpu", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "match_conf"), match_conf, ArgInfo("match_conf", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "num_matches_thresh1"), num_matches_thresh1, ArgInfo("num_matches_thresh1", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "num_matches_thresh2"), num_matches_thresh2, ArgInfo("num_matches_thresh2", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::detail::BestOf2NearestMatcher::create(try_use_gpu, match_conf, num_matches_thresh1, num_matches_thresh2), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_AffineBestOf2NearestMatcher_isThreadSafe(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::AffineBestOf2NearestMatcher> * self1 = 0;
    if (!evision_detail_AffineBestOf2NearestMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::AffineBestOf2NearestMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::AffineBestOf2NearestMatcher> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->detail::FeaturesMatcher::isThreadSafe(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (detail_AffineBestOf2NearestMatcher)

template<>
struct Evision_Converter< Ptr<cv::detail::AffineBestOf2NearestMatcher> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::detail::AffineBestOf2NearestMatcher>& r)
    {
        return evision_detail_AffineBestOf2NearestMatcher_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::detail::AffineBestOf2NearestMatcher>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::detail::AffineBestOf2NearestMatcher> * dst_ = nullptr;
        if (evision_detail_AffineBestOf2NearestMatcher_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::detail::AffineBestOf2NearestMatcher> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// detail_BestOf2NearestMatcher (Generic)
//================================================================================

// GetSet (detail_BestOf2NearestMatcher)



// Methods (detail_BestOf2NearestMatcher)

static ERL_NIF_TERM evision_cv_detail_detail_BestOf2NearestMatcher_BestOf2NearestMatcher(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    bool try_use_gpu=false;
    float match_conf=0.3f;
    int num_matches_thresh1=6;
    int num_matches_thresh2=6;

    // const char* keywords[] = { "try_use_gpu", "match_conf", "num_matches_thresh1", "num_matches_thresh2", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "try_use_gpu"), try_use_gpu, ArgInfo("try_use_gpu", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "match_conf"), match_conf, ArgInfo("match_conf", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "num_matches_thresh1"), num_matches_thresh1, ArgInfo("num_matches_thresh1", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "num_matches_thresh2"), num_matches_thresh2, ArgInfo("num_matches_thresh2", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::detail::BestOf2NearestMatcher>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::detail::BestOf2NearestMatcher>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::detail::BestOf2NearestMatcher(try_use_gpu, match_conf, num_matches_thresh1, num_matches_thresh2)), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::detail::BestOf2NearestMatcher>>(env, self->val, ret, "Detail.BestOf2NearestMatcher", success);;
        }
    }

    return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_BestOf2NearestMatcher_apply(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::BestOf2NearestMatcher> * self1 = 0;
    if (!evision_detail_BestOf2NearestMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::BestOf2NearestMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::BestOf2NearestMatcher> _self_ = *(self1);
    ImageFeatures features1;
    ImageFeatures features2;
    MatchesInfo matches_info;

    // const char* keywords[] = { "features1", "features2", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "features1"), features1, ArgInfo("features1", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "features2"), features2, ArgInfo("features2", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detail::FeaturesMatcher::operator ()(features1, features2, matches_info), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, matches_info);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_BestOf2NearestMatcher_apply2(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::BestOf2NearestMatcher> * self1 = 0;
    if (!evision_detail_BestOf2NearestMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::BestOf2NearestMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::BestOf2NearestMatcher> _self_ = *(self1);
    vector_ImageFeatures features;
    vector_MatchesInfo pairwise_matches;
    UMat mask=cv::UMat();

    // const char* keywords[] = { "features", "mask", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "features"), features, ArgInfo("features", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detail::FeaturesMatcher::operator ()(features, pairwise_matches, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, pairwise_matches);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_BestOf2NearestMatcher_collectGarbage(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::BestOf2NearestMatcher> * self1 = 0;
    if (!evision_detail_BestOf2NearestMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::BestOf2NearestMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::BestOf2NearestMatcher> _self_ = *(self1);

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->detail::BestOf2NearestMatcher::collectGarbage(), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Detail.BestOf2NearestMatcher", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_BestOf2NearestMatcher_create_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    bool try_use_gpu=false;
    float match_conf=0.3f;
    int num_matches_thresh1=6;
    int num_matches_thresh2=6;
    Ptr<BestOf2NearestMatcher> retval;

    // const char* keywords[] = { "try_use_gpu", "match_conf", "num_matches_thresh1", "num_matches_thresh2", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "try_use_gpu"), try_use_gpu, ArgInfo("try_use_gpu", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "match_conf"), match_conf, ArgInfo("match_conf", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "num_matches_thresh1"), num_matches_thresh1, ArgInfo("num_matches_thresh1", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "num_matches_thresh2"), num_matches_thresh2, ArgInfo("num_matches_thresh2", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::detail::BestOf2NearestMatcher::create(try_use_gpu, match_conf, num_matches_thresh1, num_matches_thresh2), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_BestOf2NearestMatcher_isThreadSafe(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::BestOf2NearestMatcher> * self1 = 0;
    if (!evision_detail_BestOf2NearestMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::BestOf2NearestMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::BestOf2NearestMatcher> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->detail::FeaturesMatcher::isThreadSafe(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (detail_BestOf2NearestMatcher)

template<>
struct Evision_Converter< Ptr<cv::detail::BestOf2NearestMatcher> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::detail::BestOf2NearestMatcher>& r)
    {
        return evision_detail_BestOf2NearestMatcher_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::detail::BestOf2NearestMatcher>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::detail::BestOf2NearestMatcher> * dst_ = nullptr;
        if (evision_detail_BestOf2NearestMatcher_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::detail::BestOf2NearestMatcher> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// detail_BestOf2NearestRangeMatcher (Generic)
//================================================================================

// GetSet (detail_BestOf2NearestRangeMatcher)



// Methods (detail_BestOf2NearestRangeMatcher)

static ERL_NIF_TERM evision_cv_detail_detail_BestOf2NearestRangeMatcher_BestOf2NearestRangeMatcher(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    int range_width=5;
    bool try_use_gpu=false;
    float match_conf=0.3f;
    int num_matches_thresh1=6;
    int num_matches_thresh2=6;

    // const char* keywords[] = { "range_width", "try_use_gpu", "match_conf", "num_matches_thresh1", "num_matches_thresh2", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "range_width"), range_width, ArgInfo("range_width", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "try_use_gpu"), try_use_gpu, ArgInfo("try_use_gpu", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "match_conf"), match_conf, ArgInfo("match_conf", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "num_matches_thresh1"), num_matches_thresh1, ArgInfo("num_matches_thresh1", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "num_matches_thresh2"), num_matches_thresh2, ArgInfo("num_matches_thresh2", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::detail::BestOf2NearestRangeMatcher>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::detail::BestOf2NearestRangeMatcher>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::detail::BestOf2NearestRangeMatcher(range_width, try_use_gpu, match_conf, num_matches_thresh1, num_matches_thresh2)), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::detail::BestOf2NearestRangeMatcher>>(env, self->val, ret, "Detail.BestOf2NearestRangeMatcher", success);;
        }
    }

    return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_BestOf2NearestRangeMatcher_apply(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::BestOf2NearestRangeMatcher> * self1 = 0;
    if (!evision_detail_BestOf2NearestRangeMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::BestOf2NearestRangeMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::BestOf2NearestRangeMatcher> _self_ = *(self1);
    ImageFeatures features1;
    ImageFeatures features2;
    MatchesInfo matches_info;

    // const char* keywords[] = { "features1", "features2", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "features1"), features1, ArgInfo("features1", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "features2"), features2, ArgInfo("features2", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detail::FeaturesMatcher::operator ()(features1, features2, matches_info), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, matches_info);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_BestOf2NearestRangeMatcher_apply2(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::BestOf2NearestRangeMatcher> * self1 = 0;
    if (!evision_detail_BestOf2NearestRangeMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::BestOf2NearestRangeMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::BestOf2NearestRangeMatcher> _self_ = *(self1);
    vector_ImageFeatures features;
    vector_MatchesInfo pairwise_matches;
    UMat mask=cv::UMat();

    // const char* keywords[] = { "features", "mask", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "features"), features, ArgInfo("features", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detail::FeaturesMatcher::operator ()(features, pairwise_matches, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, pairwise_matches);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_BestOf2NearestRangeMatcher_collectGarbage(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::BestOf2NearestRangeMatcher> * self1 = 0;
    if (!evision_detail_BestOf2NearestRangeMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::BestOf2NearestRangeMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::BestOf2NearestRangeMatcher> _self_ = *(self1);

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->detail::BestOf2NearestMatcher::collectGarbage(), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Detail.BestOf2NearestRangeMatcher", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_BestOf2NearestRangeMatcher_create_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    bool try_use_gpu=false;
    float match_conf=0.3f;
    int num_matches_thresh1=6;
    int num_matches_thresh2=6;
    Ptr<BestOf2NearestMatcher> retval;

    // const char* keywords[] = { "try_use_gpu", "match_conf", "num_matches_thresh1", "num_matches_thresh2", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "try_use_gpu"), try_use_gpu, ArgInfo("try_use_gpu", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "match_conf"), match_conf, ArgInfo("match_conf", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "num_matches_thresh1"), num_matches_thresh1, ArgInfo("num_matches_thresh1", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "num_matches_thresh2"), num_matches_thresh2, ArgInfo("num_matches_thresh2", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::detail::BestOf2NearestMatcher::create(try_use_gpu, match_conf, num_matches_thresh1, num_matches_thresh2), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_BestOf2NearestRangeMatcher_isThreadSafe(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::BestOf2NearestRangeMatcher> * self1 = 0;
    if (!evision_detail_BestOf2NearestRangeMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::BestOf2NearestRangeMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::BestOf2NearestRangeMatcher> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->detail::FeaturesMatcher::isThreadSafe(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (detail_BestOf2NearestRangeMatcher)

template<>
struct Evision_Converter< Ptr<cv::detail::BestOf2NearestRangeMatcher> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::detail::BestOf2NearestRangeMatcher>& r)
    {
        return evision_detail_BestOf2NearestRangeMatcher_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::detail::BestOf2NearestRangeMatcher>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::detail::BestOf2NearestRangeMatcher> * dst_ = nullptr;
        if (evision_detail_BestOf2NearestRangeMatcher_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::detail::BestOf2NearestRangeMatcher> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// detail_Blender (Generic)
//================================================================================

// GetSet (detail_Blender)



// Methods (detail_Blender)

static ERL_NIF_TERM evision_cv_detail_detail_Blender_blend(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::Blender> * self1 = 0;
    if (!evision_detail_Blender_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::Blender>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::Blender> _self_ = *(self1);

    {
    Mat dst;
    Mat dst_mask;

    // const char* keywords[] = { "dst", "dst_mask", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst_mask"), dst_mask, ArgInfo("dst_mask", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->blend(dst, dst_mask), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, dst), evision_from(env, dst_mask));
        }
    }

    }
    

    {
    UMat dst;
    UMat dst_mask;

    // const char* keywords[] = { "dst", "dst_mask", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst_mask"), dst_mask, ArgInfo("dst_mask", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->blend(dst, dst_mask), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, dst), evision_from(env, dst_mask));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_Blender_createDefault_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    int type=0;
    bool try_gpu=false;
    Ptr<Blender> retval;

    // const char* keywords[] = { "type", "try_gpu", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "type"), type, ArgInfo("type", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "try_gpu"), try_gpu, ArgInfo("try_gpu", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::detail::Blender::createDefault(type, try_gpu), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_Blender_feed(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::Blender> * self1 = 0;
    if (!evision_detail_Blender_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::Blender>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::Blender> _self_ = *(self1);

    {
    Mat img;
    Mat mask;
    Point tl;

    // const char* keywords[] = { "img", "mask", "tl", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tl"), tl, ArgInfo("tl", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->feed(img, mask, tl), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Detail.Blender", success);
        }
    }

    }
    

    {
    UMat img;
    UMat mask;
    Point tl;

    // const char* keywords[] = { "img", "mask", "tl", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tl"), tl, ArgInfo("tl", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->feed(img, mask, tl), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Detail.Blender", success);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_Blender_prepare(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::Blender> * self1 = 0;
    if (!evision_detail_Blender_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::Blender>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::Blender> _self_ = *(self1);

    {
    vector_Point corners;
    vector_Size sizes;

    // const char* keywords[] = { "corners", "sizes", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "corners"), corners, ArgInfo("corners", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sizes"), sizes, ArgInfo("sizes", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->prepare(corners, sizes), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Detail.Blender", success);
        }
    }

    }
    

    {
    Rect dst_roi;

    // const char* keywords[] = { "dst_roi", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "dst_roi"), dst_roi, ArgInfo("dst_roi", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->prepare(dst_roi), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Detail.Blender", success);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (detail_Blender)

template<>
struct Evision_Converter< Ptr<cv::detail::Blender> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::detail::Blender>& r)
    {
        return evision_detail_Blender_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::detail::Blender>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::detail::Blender> * dst_ = nullptr;
        if (evision_detail_Blender_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::detail::Blender> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// detail_BlocksChannelsCompensator (Generic)
//================================================================================

// GetSet (detail_BlocksChannelsCompensator)



// Methods (detail_BlocksChannelsCompensator)

static ERL_NIF_TERM evision_cv_detail_detail_BlocksChannelsCompensator_BlocksChannelsCompensator(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    int bl_width=32;
    int bl_height=32;
    int nr_feeds=1;

    // const char* keywords[] = { "bl_width", "bl_height", "nr_feeds", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "bl_width"), bl_width, ArgInfo("bl_width", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "bl_height"), bl_height, ArgInfo("bl_height", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nr_feeds"), nr_feeds, ArgInfo("nr_feeds", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::detail::BlocksChannelsCompensator>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::detail::BlocksChannelsCompensator>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::detail::BlocksChannelsCompensator(bl_width, bl_height, nr_feeds)), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::detail::BlocksChannelsCompensator>>(env, self->val, ret, "Detail.BlocksChannelsCompensator", success);;
        }
    }

    return enif_make_badarg(env);
}



// Converter (detail_BlocksChannelsCompensator)

template<>
struct Evision_Converter< Ptr<cv::detail::BlocksChannelsCompensator> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::detail::BlocksChannelsCompensator>& r)
    {
        return evision_detail_BlocksChannelsCompensator_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::detail::BlocksChannelsCompensator>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::detail::BlocksChannelsCompensator> * dst_ = nullptr;
        if (evision_detail_BlocksChannelsCompensator_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::detail::BlocksChannelsCompensator> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// detail_BlocksCompensator (Generic)
//================================================================================

// GetSet (detail_BlocksCompensator)



// Methods (detail_BlocksCompensator)

static ERL_NIF_TERM evision_cv_detail_detail_BlocksCompensator_apply(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::BlocksCompensator> * self1 = 0;
    if (!evision_detail_BlocksCompensator_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::BlocksCompensator>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::BlocksCompensator> _self_ = *(self1);

    {
    int index=0;
    Point corner;
    Mat image;
    Mat mask;

    // const char* keywords[] = { "index", "corner", "image", "mask", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "index"), index, ArgInfo("index", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "corner"), corner, ArgInfo("corner", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->apply(index, corner, image, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, image);
        }
    }

    }
    

    {
    int index=0;
    Point corner;
    UMat image;
    UMat mask;

    // const char* keywords[] = { "index", "corner", "image", "mask", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "index"), index, ArgInfo("index", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "corner"), corner, ArgInfo("corner", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->apply(index, corner, image, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, image);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_BlocksCompensator_getBlockSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::BlocksCompensator> * self1 = 0;
    if (!evision_detail_BlocksCompensator_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::BlocksCompensator>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::BlocksCompensator> _self_ = *(self1);
    Size retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getBlockSize(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_BlocksCompensator_getMatGains(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::BlocksCompensator> * self1 = 0;
    if (!evision_detail_BlocksCompensator_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::BlocksCompensator>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::BlocksCompensator> _self_ = *(self1);
    vector_Mat umv;

    // const char* keywords[] = { "umv", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "umv"), umv, ArgInfo("umv", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->getMatGains(umv), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, umv);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_BlocksCompensator_getNrFeeds(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::BlocksCompensator> * self1 = 0;
    if (!evision_detail_BlocksCompensator_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::BlocksCompensator>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::BlocksCompensator> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getNrFeeds(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_BlocksCompensator_getNrGainsFilteringIterations(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::BlocksCompensator> * self1 = 0;
    if (!evision_detail_BlocksCompensator_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::BlocksCompensator>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::BlocksCompensator> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getNrGainsFilteringIterations(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_BlocksCompensator_getSimilarityThreshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::BlocksCompensator> * self1 = 0;
    if (!evision_detail_BlocksCompensator_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::BlocksCompensator>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::BlocksCompensator> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getSimilarityThreshold(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_BlocksCompensator_setBlockSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::BlocksCompensator> * self1 = 0;
    if (!evision_detail_BlocksCompensator_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::BlocksCompensator>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::BlocksCompensator> _self_ = *(self1);

    {
    int width=0;
    int height=0;

    // const char* keywords[] = { "width", "height", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "width"), width, ArgInfo("width", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "height"), height, ArgInfo("height", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setBlockSize(width, height), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Detail.BlocksCompensator", success);
        }
    }

    }
    

    {
    Size size;

    // const char* keywords[] = { "size", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "size"), size, ArgInfo("size", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setBlockSize(size), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Detail.BlocksCompensator", success);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_BlocksCompensator_setMatGains(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::BlocksCompensator> * self1 = 0;
    if (!evision_detail_BlocksCompensator_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::BlocksCompensator>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::BlocksCompensator> _self_ = *(self1);
    vector_Mat umv;

    // const char* keywords[] = { "umv", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "umv"), umv, ArgInfo("umv", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setMatGains(umv), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Detail.BlocksCompensator", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_BlocksCompensator_setNrFeeds(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::BlocksCompensator> * self1 = 0;
    if (!evision_detail_BlocksCompensator_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::BlocksCompensator>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::BlocksCompensator> _self_ = *(self1);
    int nr_feeds=0;

    // const char* keywords[] = { "nr_feeds", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "nr_feeds"), nr_feeds, ArgInfo("nr_feeds", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setNrFeeds(nr_feeds), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Detail.BlocksCompensator", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_BlocksCompensator_setNrGainsFilteringIterations(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::BlocksCompensator> * self1 = 0;
    if (!evision_detail_BlocksCompensator_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::BlocksCompensator>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::BlocksCompensator> _self_ = *(self1);
    int nr_iterations=0;

    // const char* keywords[] = { "nr_iterations", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "nr_iterations"), nr_iterations, ArgInfo("nr_iterations", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setNrGainsFilteringIterations(nr_iterations), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Detail.BlocksCompensator", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_BlocksCompensator_setSimilarityThreshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::BlocksCompensator> * self1 = 0;
    if (!evision_detail_BlocksCompensator_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::BlocksCompensator>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::BlocksCompensator> _self_ = *(self1);
    double similarity_threshold=0;

    // const char* keywords[] = { "similarity_threshold", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "similarity_threshold"), similarity_threshold, ArgInfo("similarity_threshold", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setSimilarityThreshold(similarity_threshold), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Detail.BlocksCompensator", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (detail_BlocksCompensator)

template<>
struct Evision_Converter< Ptr<cv::detail::BlocksCompensator> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::detail::BlocksCompensator>& r)
    {
        return evision_detail_BlocksCompensator_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::detail::BlocksCompensator>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::detail::BlocksCompensator> * dst_ = nullptr;
        if (evision_detail_BlocksCompensator_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::detail::BlocksCompensator> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// detail_BlocksGainCompensator (Generic)
//================================================================================

// GetSet (detail_BlocksGainCompensator)



// Methods (detail_BlocksGainCompensator)

static ERL_NIF_TERM evision_cv_detail_detail_BlocksGainCompensator_BlocksGainCompensator(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    {
    int bl_width=32;
    int bl_height=32;

    // const char* keywords[] = { "bl_width", "bl_height", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "bl_width"), bl_width, ArgInfo("bl_width", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "bl_height"), bl_height, ArgInfo("bl_height", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::detail::BlocksGainCompensator>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::detail::BlocksGainCompensator>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::detail::BlocksGainCompensator(bl_width, bl_height)), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::detail::BlocksGainCompensator>>(env, self->val, ret, "Detail.BlocksGainCompensator", success);;
        }
    }

    }
    

    {
    int bl_width=0;
    int bl_height=0;
    int nr_feeds=0;

    // const char* keywords[] = { "bl_width", "bl_height", "nr_feeds", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "bl_width"), bl_width, ArgInfo("bl_width", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "bl_height"), bl_height, ArgInfo("bl_height", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nr_feeds"), nr_feeds, ArgInfo("nr_feeds", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::detail::BlocksGainCompensator>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::detail::BlocksGainCompensator>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::detail::BlocksGainCompensator(bl_width, bl_height, nr_feeds)), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::detail::BlocksGainCompensator>>(env, self->val, ret, "Detail.BlocksGainCompensator", success);;
        }
    }

    }

    return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_BlocksGainCompensator_apply(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::BlocksGainCompensator> * self1 = 0;
    if (!evision_detail_BlocksGainCompensator_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::BlocksGainCompensator>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::BlocksGainCompensator> _self_ = *(self1);

    {
    int index=0;
    Point corner;
    Mat image;
    Mat mask;

    // const char* keywords[] = { "index", "corner", "image", "mask", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "index"), index, ArgInfo("index", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "corner"), corner, ArgInfo("corner", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->apply(index, corner, image, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, image);
        }
    }

    }
    

    {
    int index=0;
    Point corner;
    UMat image;
    UMat mask;

    // const char* keywords[] = { "index", "corner", "image", "mask", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "index"), index, ArgInfo("index", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "corner"), corner, ArgInfo("corner", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->apply(index, corner, image, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, image);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_BlocksGainCompensator_getMatGains(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::BlocksGainCompensator> * self1 = 0;
    if (!evision_detail_BlocksGainCompensator_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::BlocksGainCompensator>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::BlocksGainCompensator> _self_ = *(self1);
    vector_Mat umv;

    // const char* keywords[] = { "umv", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "umv"), umv, ArgInfo("umv", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->getMatGains(umv), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, umv);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_BlocksGainCompensator_setMatGains(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::BlocksGainCompensator> * self1 = 0;
    if (!evision_detail_BlocksGainCompensator_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::BlocksGainCompensator>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::BlocksGainCompensator> _self_ = *(self1);
    vector_Mat umv;

    // const char* keywords[] = { "umv", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "umv"), umv, ArgInfo("umv", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setMatGains(umv), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Detail.BlocksGainCompensator", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (detail_BlocksGainCompensator)

template<>
struct Evision_Converter< Ptr<cv::detail::BlocksGainCompensator> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::detail::BlocksGainCompensator>& r)
    {
        return evision_detail_BlocksGainCompensator_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::detail::BlocksGainCompensator>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::detail::BlocksGainCompensator> * dst_ = nullptr;
        if (evision_detail_BlocksGainCompensator_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::detail::BlocksGainCompensator> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// detail_BundleAdjusterAffine (Generic)
//================================================================================

// GetSet (detail_BundleAdjusterAffine)



// Methods (detail_BundleAdjusterAffine)

static ERL_NIF_TERM evision_cv_detail_detail_BundleAdjusterAffine_BundleAdjusterAffine(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        evision_res<Ptr<cv::detail::BundleAdjusterAffine>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::detail::BundleAdjusterAffine>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::detail::BundleAdjusterAffine()), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::detail::BundleAdjusterAffine>>(env, self->val, ret, "Detail.BundleAdjusterAffine", success);;
        }
    }

    return enif_make_badarg(env);
}



// Converter (detail_BundleAdjusterAffine)

template<>
struct Evision_Converter< Ptr<cv::detail::BundleAdjusterAffine> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::detail::BundleAdjusterAffine>& r)
    {
        return evision_detail_BundleAdjusterAffine_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::detail::BundleAdjusterAffine>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::detail::BundleAdjusterAffine> * dst_ = nullptr;
        if (evision_detail_BundleAdjusterAffine_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::detail::BundleAdjusterAffine> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// detail_BundleAdjusterAffinePartial (Generic)
//================================================================================

// GetSet (detail_BundleAdjusterAffinePartial)



// Methods (detail_BundleAdjusterAffinePartial)

static ERL_NIF_TERM evision_cv_detail_detail_BundleAdjusterAffinePartial_BundleAdjusterAffinePartial(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        evision_res<Ptr<cv::detail::BundleAdjusterAffinePartial>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::detail::BundleAdjusterAffinePartial>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::detail::BundleAdjusterAffinePartial()), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::detail::BundleAdjusterAffinePartial>>(env, self->val, ret, "Detail.BundleAdjusterAffinePartial", success);;
        }
    }

    return enif_make_badarg(env);
}



// Converter (detail_BundleAdjusterAffinePartial)

template<>
struct Evision_Converter< Ptr<cv::detail::BundleAdjusterAffinePartial> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::detail::BundleAdjusterAffinePartial>& r)
    {
        return evision_detail_BundleAdjusterAffinePartial_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::detail::BundleAdjusterAffinePartial>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::detail::BundleAdjusterAffinePartial> * dst_ = nullptr;
        if (evision_detail_BundleAdjusterAffinePartial_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::detail::BundleAdjusterAffinePartial> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// detail_BundleAdjusterBase (Generic)
//================================================================================

// GetSet (detail_BundleAdjusterBase)



// Methods (detail_BundleAdjusterBase)

static ERL_NIF_TERM evision_cv_detail_detail_BundleAdjusterBase_confThresh(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::BundleAdjusterBase> * self1 = 0;
    if (!evision_detail_BundleAdjusterBase_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::BundleAdjusterBase>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::BundleAdjusterBase> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->confThresh(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_BundleAdjusterBase_refinementMask(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::BundleAdjusterBase> * self1 = 0;
    if (!evision_detail_BundleAdjusterBase_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::BundleAdjusterBase>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::BundleAdjusterBase> _self_ = *(self1);
    Mat retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->refinementMask(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_BundleAdjusterBase_setConfThresh(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::BundleAdjusterBase> * self1 = 0;
    if (!evision_detail_BundleAdjusterBase_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::BundleAdjusterBase>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::BundleAdjusterBase> _self_ = *(self1);
    double conf_thresh=0;

    // const char* keywords[] = { "conf_thresh", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "conf_thresh"), conf_thresh, ArgInfo("conf_thresh", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setConfThresh(conf_thresh), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Detail.BundleAdjusterBase", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_BundleAdjusterBase_setRefinementMask(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::BundleAdjusterBase> * self1 = 0;
    if (!evision_detail_BundleAdjusterBase_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::BundleAdjusterBase>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::BundleAdjusterBase> _self_ = *(self1);
    Mat mask;

    // const char* keywords[] = { "mask", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setRefinementMask(mask), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Detail.BundleAdjusterBase", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_BundleAdjusterBase_setTermCriteria(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::BundleAdjusterBase> * self1 = 0;
    if (!evision_detail_BundleAdjusterBase_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::BundleAdjusterBase>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::BundleAdjusterBase> _self_ = *(self1);
    TermCriteria term_criteria;

    // const char* keywords[] = { "term_criteria", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "term_criteria"), term_criteria, ArgInfo("term_criteria", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setTermCriteria(term_criteria), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Detail.BundleAdjusterBase", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_BundleAdjusterBase_termCriteria(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::BundleAdjusterBase> * self1 = 0;
    if (!evision_detail_BundleAdjusterBase_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::BundleAdjusterBase>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::BundleAdjusterBase> _self_ = *(self1);
    TermCriteria retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->termCriteria(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (detail_BundleAdjusterBase)

template<>
struct Evision_Converter< Ptr<cv::detail::BundleAdjusterBase> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::detail::BundleAdjusterBase>& r)
    {
        return evision_detail_BundleAdjusterBase_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::detail::BundleAdjusterBase>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::detail::BundleAdjusterBase> * dst_ = nullptr;
        if (evision_detail_BundleAdjusterBase_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::detail::BundleAdjusterBase> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// detail_BundleAdjusterRay (Generic)
//================================================================================

// GetSet (detail_BundleAdjusterRay)



// Methods (detail_BundleAdjusterRay)

static ERL_NIF_TERM evision_cv_detail_detail_BundleAdjusterRay_BundleAdjusterRay(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        evision_res<Ptr<cv::detail::BundleAdjusterRay>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::detail::BundleAdjusterRay>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::detail::BundleAdjusterRay()), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::detail::BundleAdjusterRay>>(env, self->val, ret, "Detail.BundleAdjusterRay", success);;
        }
    }

    return enif_make_badarg(env);
}



// Converter (detail_BundleAdjusterRay)

template<>
struct Evision_Converter< Ptr<cv::detail::BundleAdjusterRay> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::detail::BundleAdjusterRay>& r)
    {
        return evision_detail_BundleAdjusterRay_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::detail::BundleAdjusterRay>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::detail::BundleAdjusterRay> * dst_ = nullptr;
        if (evision_detail_BundleAdjusterRay_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::detail::BundleAdjusterRay> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// detail_BundleAdjusterReproj (Generic)
//================================================================================

// GetSet (detail_BundleAdjusterReproj)



// Methods (detail_BundleAdjusterReproj)

static ERL_NIF_TERM evision_cv_detail_detail_BundleAdjusterReproj_BundleAdjusterReproj(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        evision_res<Ptr<cv::detail::BundleAdjusterReproj>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::detail::BundleAdjusterReproj>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::detail::BundleAdjusterReproj()), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::detail::BundleAdjusterReproj>>(env, self->val, ret, "Detail.BundleAdjusterReproj", success);;
        }
    }

    return enif_make_badarg(env);
}



// Converter (detail_BundleAdjusterReproj)

template<>
struct Evision_Converter< Ptr<cv::detail::BundleAdjusterReproj> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::detail::BundleAdjusterReproj>& r)
    {
        return evision_detail_BundleAdjusterReproj_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::detail::BundleAdjusterReproj>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::detail::BundleAdjusterReproj> * dst_ = nullptr;
        if (evision_detail_BundleAdjusterReproj_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::detail::BundleAdjusterReproj> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// detail_CameraParams (Generic)
//================================================================================

// GetSet (detail_CameraParams)


static ERL_NIF_TERM evision_detail_CameraParams_get_R(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::detail::CameraParams* self_ptr = 0;
    if (!evision_detail_CameraParams_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::detail::CameraParams` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->R);
}

static ERL_NIF_TERM evision_detail_CameraParams_set_R(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::detail::CameraParams* self_ptr = 0;

    if (!evision_detail_CameraParams_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::detail::CameraParams` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->R, ArgInfo("R", false))) {
        bool success;
        return evision_from_as_map<cv::detail::CameraParams>(env, *self_ptr, self, "\"Detail.CameraParams\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_detail_CameraParams_get_aspect(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::detail::CameraParams* self_ptr = 0;
    if (!evision_detail_CameraParams_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::detail::CameraParams` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->aspect);
}

static ERL_NIF_TERM evision_detail_CameraParams_set_aspect(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::detail::CameraParams* self_ptr = 0;

    if (!evision_detail_CameraParams_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::detail::CameraParams` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->aspect, ArgInfo("aspect", false))) {
        bool success;
        return evision_from_as_map<cv::detail::CameraParams>(env, *self_ptr, self, "\"Detail.CameraParams\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_detail_CameraParams_get_focal(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::detail::CameraParams* self_ptr = 0;
    if (!evision_detail_CameraParams_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::detail::CameraParams` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->focal);
}

static ERL_NIF_TERM evision_detail_CameraParams_set_focal(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::detail::CameraParams* self_ptr = 0;

    if (!evision_detail_CameraParams_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::detail::CameraParams` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->focal, ArgInfo("focal", false))) {
        bool success;
        return evision_from_as_map<cv::detail::CameraParams>(env, *self_ptr, self, "\"Detail.CameraParams\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_detail_CameraParams_get_ppx(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::detail::CameraParams* self_ptr = 0;
    if (!evision_detail_CameraParams_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::detail::CameraParams` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->ppx);
}

static ERL_NIF_TERM evision_detail_CameraParams_set_ppx(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::detail::CameraParams* self_ptr = 0;

    if (!evision_detail_CameraParams_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::detail::CameraParams` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->ppx, ArgInfo("ppx", false))) {
        bool success;
        return evision_from_as_map<cv::detail::CameraParams>(env, *self_ptr, self, "\"Detail.CameraParams\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_detail_CameraParams_get_ppy(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::detail::CameraParams* self_ptr = 0;
    if (!evision_detail_CameraParams_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::detail::CameraParams` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->ppy);
}

static ERL_NIF_TERM evision_detail_CameraParams_set_ppy(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::detail::CameraParams* self_ptr = 0;

    if (!evision_detail_CameraParams_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::detail::CameraParams` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->ppy, ArgInfo("ppy", false))) {
        bool success;
        return evision_from_as_map<cv::detail::CameraParams>(env, *self_ptr, self, "\"Detail.CameraParams\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_detail_CameraParams_get_t(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::detail::CameraParams* self_ptr = 0;
    if (!evision_detail_CameraParams_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::detail::CameraParams` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->t);
}

static ERL_NIF_TERM evision_detail_CameraParams_set_t(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::detail::CameraParams* self_ptr = 0;

    if (!evision_detail_CameraParams_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::detail::CameraParams` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->t, ArgInfo("t", false))) {
        bool success;
        return evision_from_as_map<cv::detail::CameraParams>(env, *self_ptr, self, "\"Detail.CameraParams\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}


// Methods (detail_CameraParams)

static ERL_NIF_TERM evision_cv_detail_detail_CameraParams_K(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::detail::CameraParams * self1 = 0;
    if (!evision_detail_CameraParams_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::detail::CameraParams` from `self`: mismatched type or invalid resource?");
    }
    cv::detail::CameraParams* _self_ = (self1);
    Mat retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->K(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (detail_CameraParams)

template<>
struct Evision_Converter< cv::detail::CameraParams >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const cv::detail::CameraParams& r)
    {
        return evision_detail_CameraParams_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, cv::detail::CameraParams& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        cv::detail::CameraParams * dst_ = nullptr;
        if (evision_detail_CameraParams_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected cv::detail::CameraParams for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// detail_ChannelsCompensator (Generic)
//================================================================================

// GetSet (detail_ChannelsCompensator)



// Methods (detail_ChannelsCompensator)

static ERL_NIF_TERM evision_cv_detail_detail_ChannelsCompensator_ChannelsCompensator(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    int nr_feeds=1;

    // const char* keywords[] = { "nr_feeds", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "nr_feeds"), nr_feeds, ArgInfo("nr_feeds", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::detail::ChannelsCompensator>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::detail::ChannelsCompensator>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::detail::ChannelsCompensator(nr_feeds)), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::detail::ChannelsCompensator>>(env, self->val, ret, "Detail.ChannelsCompensator", success);;
        }
    }

    return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_ChannelsCompensator_apply(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::ChannelsCompensator> * self1 = 0;
    if (!evision_detail_ChannelsCompensator_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::ChannelsCompensator>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::ChannelsCompensator> _self_ = *(self1);

    {
    int index=0;
    Point corner;
    Mat image;
    Mat mask;

    // const char* keywords[] = { "index", "corner", "image", "mask", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "index"), index, ArgInfo("index", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "corner"), corner, ArgInfo("corner", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->apply(index, corner, image, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, image);
        }
    }

    }
    

    {
    int index=0;
    Point corner;
    UMat image;
    UMat mask;

    // const char* keywords[] = { "index", "corner", "image", "mask", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "index"), index, ArgInfo("index", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "corner"), corner, ArgInfo("corner", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->apply(index, corner, image, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, image);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_ChannelsCompensator_getMatGains(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::ChannelsCompensator> * self1 = 0;
    if (!evision_detail_ChannelsCompensator_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::ChannelsCompensator>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::ChannelsCompensator> _self_ = *(self1);
    vector_Mat umv;

    // const char* keywords[] = { "umv", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "umv"), umv, ArgInfo("umv", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->getMatGains(umv), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, umv);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_ChannelsCompensator_getNrFeeds(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::ChannelsCompensator> * self1 = 0;
    if (!evision_detail_ChannelsCompensator_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::ChannelsCompensator>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::ChannelsCompensator> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getNrFeeds(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_ChannelsCompensator_getSimilarityThreshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::ChannelsCompensator> * self1 = 0;
    if (!evision_detail_ChannelsCompensator_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::ChannelsCompensator>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::ChannelsCompensator> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getSimilarityThreshold(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_ChannelsCompensator_setMatGains(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::ChannelsCompensator> * self1 = 0;
    if (!evision_detail_ChannelsCompensator_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::ChannelsCompensator>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::ChannelsCompensator> _self_ = *(self1);
    vector_Mat umv;

    // const char* keywords[] = { "umv", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "umv"), umv, ArgInfo("umv", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setMatGains(umv), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Detail.ChannelsCompensator", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_ChannelsCompensator_setNrFeeds(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::ChannelsCompensator> * self1 = 0;
    if (!evision_detail_ChannelsCompensator_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::ChannelsCompensator>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::ChannelsCompensator> _self_ = *(self1);
    int nr_feeds=0;

    // const char* keywords[] = { "nr_feeds", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "nr_feeds"), nr_feeds, ArgInfo("nr_feeds", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setNrFeeds(nr_feeds), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Detail.ChannelsCompensator", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_ChannelsCompensator_setSimilarityThreshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::ChannelsCompensator> * self1 = 0;
    if (!evision_detail_ChannelsCompensator_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::ChannelsCompensator>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::ChannelsCompensator> _self_ = *(self1);
    double similarity_threshold=0;

    // const char* keywords[] = { "similarity_threshold", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "similarity_threshold"), similarity_threshold, ArgInfo("similarity_threshold", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setSimilarityThreshold(similarity_threshold), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Detail.ChannelsCompensator", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (detail_ChannelsCompensator)

template<>
struct Evision_Converter< Ptr<cv::detail::ChannelsCompensator> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::detail::ChannelsCompensator>& r)
    {
        return evision_detail_ChannelsCompensator_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::detail::ChannelsCompensator>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::detail::ChannelsCompensator> * dst_ = nullptr;
        if (evision_detail_ChannelsCompensator_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::detail::ChannelsCompensator> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// detail_DpSeamFinder (Generic)
//================================================================================

// GetSet (detail_DpSeamFinder)



// Methods (detail_DpSeamFinder)

static ERL_NIF_TERM evision_cv_detail_detail_DpSeamFinder_DpSeamFinder(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    String costFunc;

    // const char* keywords[] = { "costFunc", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "costFunc"), costFunc, ArgInfo("costFunc", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::detail::DpSeamFinder>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::detail::DpSeamFinder>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::detail::DpSeamFinder(costFunc)), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::detail::DpSeamFinder>>(env, self->val, ret, "Detail.DpSeamFinder", success);;
        }
    }

    return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_DpSeamFinder_setCostFunction(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::DpSeamFinder> * self1 = 0;
    if (!evision_detail_DpSeamFinder_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::DpSeamFinder>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::DpSeamFinder> _self_ = *(self1);
    String val;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setCostFunction(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Detail.DpSeamFinder", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (detail_DpSeamFinder)

template<>
struct Evision_Converter< Ptr<cv::detail::DpSeamFinder> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::detail::DpSeamFinder>& r)
    {
        return evision_detail_DpSeamFinder_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::detail::DpSeamFinder>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::detail::DpSeamFinder> * dst_ = nullptr;
        if (evision_detail_DpSeamFinder_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::detail::DpSeamFinder> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// detail_Estimator (Generic)
//================================================================================

// GetSet (detail_Estimator)



// Methods (detail_Estimator)

static ERL_NIF_TERM evision_cv_detail_detail_Estimator_apply(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::Estimator> * self1 = 0;
    if (!evision_detail_Estimator_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::Estimator>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::Estimator> _self_ = *(self1);
    vector_ImageFeatures features;
    vector_MatchesInfo pairwise_matches;
    vector_CameraParams cameras;
    bool retval;

    // const char* keywords[] = { "features", "pairwise_matches", "cameras", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "features"), features, ArgInfo("features", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pairwise_matches"), pairwise_matches, ArgInfo("pairwise_matches", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameras"), cameras, ArgInfo("cameras", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->operator ()(features, pairwise_matches, cameras), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_1_tuple_except_bool
                return evision_from(env, cameras);
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (detail_Estimator)

template<>
struct Evision_Converter< Ptr<cv::detail::Estimator> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::detail::Estimator>& r)
    {
        return evision_detail_Estimator_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::detail::Estimator>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::detail::Estimator> * dst_ = nullptr;
        if (evision_detail_Estimator_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::detail::Estimator> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// detail_ExposureCompensator (Generic)
//================================================================================

// GetSet (detail_ExposureCompensator)



// Methods (detail_ExposureCompensator)

static ERL_NIF_TERM evision_cv_detail_detail_ExposureCompensator_apply(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::ExposureCompensator> * self1 = 0;
    if (!evision_detail_ExposureCompensator_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::ExposureCompensator>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::ExposureCompensator> _self_ = *(self1);

    {
    int index=0;
    Point corner;
    Mat image;
    Mat mask;

    // const char* keywords[] = { "index", "corner", "image", "mask", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "index"), index, ArgInfo("index", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "corner"), corner, ArgInfo("corner", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->apply(index, corner, image, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, image);
        }
    }

    }
    

    {
    int index=0;
    Point corner;
    UMat image;
    UMat mask;

    // const char* keywords[] = { "index", "corner", "image", "mask", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "index"), index, ArgInfo("index", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "corner"), corner, ArgInfo("corner", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->apply(index, corner, image, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, image);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_ExposureCompensator_createDefault_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    int type=0;
    Ptr<ExposureCompensator> retval;

    // const char* keywords[] = { "type", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "type"), type, ArgInfo("type", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::detail::ExposureCompensator::createDefault(type), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_ExposureCompensator_feed(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::ExposureCompensator> * self1 = 0;
    if (!evision_detail_ExposureCompensator_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::ExposureCompensator>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::ExposureCompensator> _self_ = *(self1);
    vector_Point corners;
    vector_UMat images;
    vector_UMat masks;

    // const char* keywords[] = { "corners", "images", "masks", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "corners"), corners, ArgInfo("corners", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "masks"), masks, ArgInfo("masks", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->feed(corners, images, masks), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Detail.ExposureCompensator", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_ExposureCompensator_getMatGains(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::ExposureCompensator> * self1 = 0;
    if (!evision_detail_ExposureCompensator_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::ExposureCompensator>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::ExposureCompensator> _self_ = *(self1);
    vector_Mat arg1;

    // const char* keywords[] = { "arg1", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "arg1"), arg1, ArgInfo("arg1", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->getMatGains(arg1), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, arg1);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_ExposureCompensator_getUpdateGain(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::ExposureCompensator> * self1 = 0;
    if (!evision_detail_ExposureCompensator_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::ExposureCompensator>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::ExposureCompensator> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getUpdateGain(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_ExposureCompensator_setMatGains(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::ExposureCompensator> * self1 = 0;
    if (!evision_detail_ExposureCompensator_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::ExposureCompensator>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::ExposureCompensator> _self_ = *(self1);
    vector_Mat arg1;

    // const char* keywords[] = { "arg1", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "arg1"), arg1, ArgInfo("arg1", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setMatGains(arg1), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Detail.ExposureCompensator", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_ExposureCompensator_setUpdateGain(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::ExposureCompensator> * self1 = 0;
    if (!evision_detail_ExposureCompensator_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::ExposureCompensator>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::ExposureCompensator> _self_ = *(self1);
    bool b=0;

    // const char* keywords[] = { "b", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "b"), b, ArgInfo("b", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setUpdateGain(b), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Detail.ExposureCompensator", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (detail_ExposureCompensator)

template<>
struct Evision_Converter< Ptr<cv::detail::ExposureCompensator> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::detail::ExposureCompensator>& r)
    {
        return evision_detail_ExposureCompensator_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::detail::ExposureCompensator>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::detail::ExposureCompensator> * dst_ = nullptr;
        if (evision_detail_ExposureCompensator_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::detail::ExposureCompensator> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// detail_FeatherBlender (Generic)
//================================================================================

// GetSet (detail_FeatherBlender)



// Methods (detail_FeatherBlender)

static ERL_NIF_TERM evision_cv_detail_detail_FeatherBlender_FeatherBlender(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    float sharpness=0.02f;

    // const char* keywords[] = { "sharpness", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "sharpness"), sharpness, ArgInfo("sharpness", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::detail::FeatherBlender>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::detail::FeatherBlender>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::detail::FeatherBlender(sharpness)), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::detail::FeatherBlender>>(env, self->val, ret, "Detail.FeatherBlender", success);;
        }
    }

    return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_FeatherBlender_blend(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::FeatherBlender> * self1 = 0;
    if (!evision_detail_FeatherBlender_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::FeatherBlender>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::FeatherBlender> _self_ = *(self1);

    {
    Mat dst;
    Mat dst_mask;

    // const char* keywords[] = { "dst", "dst_mask", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst_mask"), dst_mask, ArgInfo("dst_mask", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->blend(dst, dst_mask), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, dst), evision_from(env, dst_mask));
        }
    }

    }
    

    {
    UMat dst;
    UMat dst_mask;

    // const char* keywords[] = { "dst", "dst_mask", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst_mask"), dst_mask, ArgInfo("dst_mask", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->blend(dst, dst_mask), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, dst), evision_from(env, dst_mask));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_FeatherBlender_createWeightMaps(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::FeatherBlender> * self1 = 0;
    if (!evision_detail_FeatherBlender_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::FeatherBlender>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::FeatherBlender> _self_ = *(self1);
    vector_UMat masks;
    vector_Point corners;
    vector_UMat weight_maps;
    Rect retval;

    // const char* keywords[] = { "masks", "corners", "weight_maps", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "masks"), masks, ArgInfo("masks", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "corners"), corners, ArgInfo("corners", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "weight_maps"), weight_maps, ArgInfo("weight_maps", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->createWeightMaps(masks, corners, weight_maps), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, weight_maps));
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_FeatherBlender_feed(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::FeatherBlender> * self1 = 0;
    if (!evision_detail_FeatherBlender_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::FeatherBlender>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::FeatherBlender> _self_ = *(self1);

    {
    Mat img;
    Mat mask;
    Point tl;

    // const char* keywords[] = { "img", "mask", "tl", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tl"), tl, ArgInfo("tl", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->feed(img, mask, tl), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Detail.FeatherBlender", success);
        }
    }

    }
    

    {
    UMat img;
    UMat mask;
    Point tl;

    // const char* keywords[] = { "img", "mask", "tl", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tl"), tl, ArgInfo("tl", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->feed(img, mask, tl), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Detail.FeatherBlender", success);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_FeatherBlender_prepare(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::FeatherBlender> * self1 = 0;
    if (!evision_detail_FeatherBlender_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::FeatherBlender>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::FeatherBlender> _self_ = *(self1);
    Rect dst_roi;

    // const char* keywords[] = { "dst_roi", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "dst_roi"), dst_roi, ArgInfo("dst_roi", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->prepare(dst_roi), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Detail.FeatherBlender", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_FeatherBlender_setSharpness(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::FeatherBlender> * self1 = 0;
    if (!evision_detail_FeatherBlender_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::FeatherBlender>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::FeatherBlender> _self_ = *(self1);
    float val=0.f;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setSharpness(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Detail.FeatherBlender", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_FeatherBlender_sharpness(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::FeatherBlender> * self1 = 0;
    if (!evision_detail_FeatherBlender_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::FeatherBlender>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::FeatherBlender> _self_ = *(self1);
    float retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->sharpness(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (detail_FeatherBlender)

template<>
struct Evision_Converter< Ptr<cv::detail::FeatherBlender> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::detail::FeatherBlender>& r)
    {
        return evision_detail_FeatherBlender_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::detail::FeatherBlender>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::detail::FeatherBlender> * dst_ = nullptr;
        if (evision_detail_FeatherBlender_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::detail::FeatherBlender> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// detail_FeaturesMatcher (Generic)
//================================================================================

// GetSet (detail_FeaturesMatcher)



// Methods (detail_FeaturesMatcher)

static ERL_NIF_TERM evision_cv_detail_detail_FeaturesMatcher_apply(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::FeaturesMatcher> * self1 = 0;
    if (!evision_detail_FeaturesMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::FeaturesMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::FeaturesMatcher> _self_ = *(self1);
    ImageFeatures features1;
    ImageFeatures features2;
    MatchesInfo matches_info;

    // const char* keywords[] = { "features1", "features2", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "features1"), features1, ArgInfo("features1", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "features2"), features2, ArgInfo("features2", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detail::FeaturesMatcher::operator ()(features1, features2, matches_info), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, matches_info);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_FeaturesMatcher_apply2(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::FeaturesMatcher> * self1 = 0;
    if (!evision_detail_FeaturesMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::FeaturesMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::FeaturesMatcher> _self_ = *(self1);
    vector_ImageFeatures features;
    vector_MatchesInfo pairwise_matches;
    UMat mask=cv::UMat();

    // const char* keywords[] = { "features", "mask", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "features"), features, ArgInfo("features", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detail::FeaturesMatcher::operator ()(features, pairwise_matches, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, pairwise_matches);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_FeaturesMatcher_collectGarbage(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::FeaturesMatcher> * self1 = 0;
    if (!evision_detail_FeaturesMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::FeaturesMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::FeaturesMatcher> _self_ = *(self1);

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->detail::FeaturesMatcher::collectGarbage(), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Detail.FeaturesMatcher", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_FeaturesMatcher_isThreadSafe(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::FeaturesMatcher> * self1 = 0;
    if (!evision_detail_FeaturesMatcher_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::FeaturesMatcher>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::FeaturesMatcher> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->detail::FeaturesMatcher::isThreadSafe(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (detail_FeaturesMatcher)

template<>
struct Evision_Converter< Ptr<cv::detail::FeaturesMatcher> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::detail::FeaturesMatcher>& r)
    {
        return evision_detail_FeaturesMatcher_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::detail::FeaturesMatcher>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::detail::FeaturesMatcher> * dst_ = nullptr;
        if (evision_detail_FeaturesMatcher_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::detail::FeaturesMatcher> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// detail_GainCompensator (Generic)
//================================================================================

// GetSet (detail_GainCompensator)



// Methods (detail_GainCompensator)

static ERL_NIF_TERM evision_cv_detail_detail_GainCompensator_GainCompensator(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    {

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        evision_res<Ptr<cv::detail::GainCompensator>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::detail::GainCompensator>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::detail::GainCompensator()), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::detail::GainCompensator>>(env, self->val, ret, "Detail.GainCompensator", success);;
        }
    }

    }
    

    {
    int nr_feeds=0;

    // const char* keywords[] = { "nr_feeds", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "nr_feeds"), nr_feeds, ArgInfo("nr_feeds", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::detail::GainCompensator>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::detail::GainCompensator>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::detail::GainCompensator(nr_feeds)), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::detail::GainCompensator>>(env, self->val, ret, "Detail.GainCompensator", success);;
        }
    }

    }

    return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_GainCompensator_apply(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::GainCompensator> * self1 = 0;
    if (!evision_detail_GainCompensator_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::GainCompensator>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::GainCompensator> _self_ = *(self1);

    {
    int index=0;
    Point corner;
    Mat image;
    Mat mask;

    // const char* keywords[] = { "index", "corner", "image", "mask", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "index"), index, ArgInfo("index", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "corner"), corner, ArgInfo("corner", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->apply(index, corner, image, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, image);
        }
    }

    }
    

    {
    int index=0;
    Point corner;
    UMat image;
    UMat mask;

    // const char* keywords[] = { "index", "corner", "image", "mask", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "index"), index, ArgInfo("index", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "corner"), corner, ArgInfo("corner", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->apply(index, corner, image, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, image);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_GainCompensator_getMatGains(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::GainCompensator> * self1 = 0;
    if (!evision_detail_GainCompensator_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::GainCompensator>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::GainCompensator> _self_ = *(self1);
    vector_Mat umv;

    // const char* keywords[] = { "umv", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "umv"), umv, ArgInfo("umv", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->getMatGains(umv), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, umv);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_GainCompensator_getNrFeeds(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::GainCompensator> * self1 = 0;
    if (!evision_detail_GainCompensator_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::GainCompensator>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::GainCompensator> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getNrFeeds(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_GainCompensator_getSimilarityThreshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::GainCompensator> * self1 = 0;
    if (!evision_detail_GainCompensator_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::GainCompensator>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::GainCompensator> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getSimilarityThreshold(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_GainCompensator_setMatGains(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::GainCompensator> * self1 = 0;
    if (!evision_detail_GainCompensator_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::GainCompensator>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::GainCompensator> _self_ = *(self1);
    vector_Mat umv;

    // const char* keywords[] = { "umv", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "umv"), umv, ArgInfo("umv", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setMatGains(umv), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Detail.GainCompensator", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_GainCompensator_setNrFeeds(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::GainCompensator> * self1 = 0;
    if (!evision_detail_GainCompensator_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::GainCompensator>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::GainCompensator> _self_ = *(self1);
    int nr_feeds=0;

    // const char* keywords[] = { "nr_feeds", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "nr_feeds"), nr_feeds, ArgInfo("nr_feeds", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setNrFeeds(nr_feeds), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Detail.GainCompensator", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_GainCompensator_setSimilarityThreshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::GainCompensator> * self1 = 0;
    if (!evision_detail_GainCompensator_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::GainCompensator>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::GainCompensator> _self_ = *(self1);
    double similarity_threshold=0;

    // const char* keywords[] = { "similarity_threshold", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "similarity_threshold"), similarity_threshold, ArgInfo("similarity_threshold", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setSimilarityThreshold(similarity_threshold), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Detail.GainCompensator", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (detail_GainCompensator)

template<>
struct Evision_Converter< Ptr<cv::detail::GainCompensator> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::detail::GainCompensator>& r)
    {
        return evision_detail_GainCompensator_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::detail::GainCompensator>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::detail::GainCompensator> * dst_ = nullptr;
        if (evision_detail_GainCompensator_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::detail::GainCompensator> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// detail_GraphCutSeamFinder (Generic)
//================================================================================

// GetSet (detail_GraphCutSeamFinder)



// Methods (detail_GraphCutSeamFinder)

static ERL_NIF_TERM evision_cv_detail_detail_GraphCutSeamFinder_GraphCutSeamFinder(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    String cost_type;
    float terminal_cost=10000.f;
    float bad_region_penalty=1000.f;

    // const char* keywords[] = { "cost_type", "terminal_cost", "bad_region_penalty", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "cost_type"), cost_type, ArgInfo("cost_type", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "terminal_cost"), terminal_cost, ArgInfo("terminal_cost", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "bad_region_penalty"), bad_region_penalty, ArgInfo("bad_region_penalty", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::detail::GraphCutSeamFinder>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::detail::GraphCutSeamFinder>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::detail::GraphCutSeamFinder(cost_type, terminal_cost, bad_region_penalty)), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::detail::GraphCutSeamFinder>>(env, self->val, ret, "Detail.GraphCutSeamFinder", success);;
        }
    }

    return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_GraphCutSeamFinder_find(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::GraphCutSeamFinder> * self1 = 0;
    if (!evision_detail_GraphCutSeamFinder_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::GraphCutSeamFinder>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::GraphCutSeamFinder> _self_ = *(self1);
    vector_UMat src;
    vector_Point corners;
    vector_UMat masks;

    // const char* keywords[] = { "src", "corners", "masks", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "corners"), corners, ArgInfo("corners", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "masks"), masks, ArgInfo("masks", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->find(src, corners, masks), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Detail.GraphCutSeamFinder", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (detail_GraphCutSeamFinder)

template<>
struct Evision_Converter< Ptr<cv::detail::GraphCutSeamFinder> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::detail::GraphCutSeamFinder>& r)
    {
        return evision_detail_GraphCutSeamFinder_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::detail::GraphCutSeamFinder>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::detail::GraphCutSeamFinder> * dst_ = nullptr;
        if (evision_detail_GraphCutSeamFinder_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::detail::GraphCutSeamFinder> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// detail_HomographyBasedEstimator (Generic)
//================================================================================

// GetSet (detail_HomographyBasedEstimator)



// Methods (detail_HomographyBasedEstimator)

static ERL_NIF_TERM evision_cv_detail_detail_HomographyBasedEstimator_HomographyBasedEstimator(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    bool is_focals_estimated=false;

    // const char* keywords[] = { "is_focals_estimated", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "is_focals_estimated"), is_focals_estimated, ArgInfo("is_focals_estimated", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::detail::HomographyBasedEstimator>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::detail::HomographyBasedEstimator>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::detail::HomographyBasedEstimator(is_focals_estimated)), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::detail::HomographyBasedEstimator>>(env, self->val, ret, "Detail.HomographyBasedEstimator", success);;
        }
    }

    return enif_make_badarg(env);
}



// Converter (detail_HomographyBasedEstimator)

template<>
struct Evision_Converter< Ptr<cv::detail::HomographyBasedEstimator> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::detail::HomographyBasedEstimator>& r)
    {
        return evision_detail_HomographyBasedEstimator_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::detail::HomographyBasedEstimator>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::detail::HomographyBasedEstimator> * dst_ = nullptr;
        if (evision_detail_HomographyBasedEstimator_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::detail::HomographyBasedEstimator> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// detail_ImageFeatures (Generic)
//================================================================================

// GetSet (detail_ImageFeatures)


static ERL_NIF_TERM evision_detail_ImageFeatures_get_descriptors(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::detail::ImageFeatures* self_ptr = 0;
    if (!evision_detail_ImageFeatures_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::detail::ImageFeatures` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->descriptors);
}

static ERL_NIF_TERM evision_detail_ImageFeatures_set_descriptors(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::detail::ImageFeatures* self_ptr = 0;

    if (!evision_detail_ImageFeatures_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::detail::ImageFeatures` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->descriptors, ArgInfo("descriptors", false))) {
        bool success;
        return evision_from_as_map<cv::detail::ImageFeatures>(env, *self_ptr, self, "\"Detail.ImageFeatures\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_detail_ImageFeatures_get_img_idx(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::detail::ImageFeatures* self_ptr = 0;
    if (!evision_detail_ImageFeatures_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::detail::ImageFeatures` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->img_idx);
}

static ERL_NIF_TERM evision_detail_ImageFeatures_set_img_idx(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::detail::ImageFeatures* self_ptr = 0;

    if (!evision_detail_ImageFeatures_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::detail::ImageFeatures` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->img_idx, ArgInfo("img_idx", false))) {
        bool success;
        return evision_from_as_map<cv::detail::ImageFeatures>(env, *self_ptr, self, "\"Detail.ImageFeatures\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_detail_ImageFeatures_get_img_size(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::detail::ImageFeatures* self_ptr = 0;
    if (!evision_detail_ImageFeatures_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::detail::ImageFeatures` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->img_size);
}

static ERL_NIF_TERM evision_detail_ImageFeatures_set_img_size(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::detail::ImageFeatures* self_ptr = 0;

    if (!evision_detail_ImageFeatures_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::detail::ImageFeatures` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->img_size, ArgInfo("img_size", false))) {
        bool success;
        return evision_from_as_map<cv::detail::ImageFeatures>(env, *self_ptr, self, "\"Detail.ImageFeatures\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_detail_ImageFeatures_get_keypoints(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::detail::ImageFeatures* self_ptr = 0;
    if (!evision_detail_ImageFeatures_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::detail::ImageFeatures` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->keypoints);
}

static ERL_NIF_TERM evision_detail_ImageFeatures_set_keypoints(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::detail::ImageFeatures* self_ptr = 0;

    if (!evision_detail_ImageFeatures_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::detail::ImageFeatures` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->keypoints, ArgInfo("keypoints", false))) {
        bool success;
        return evision_from_as_map<cv::detail::ImageFeatures>(env, *self_ptr, self, "\"Detail.ImageFeatures\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}


// Methods (detail_ImageFeatures)

static ERL_NIF_TERM evision_cv_detail_detail_ImageFeatures_getKeypoints(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::detail::ImageFeatures * self1 = 0;
    if (!evision_detail_ImageFeatures_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::detail::ImageFeatures` from `self`: mismatched type or invalid resource?");
    }
    cv::detail::ImageFeatures* _self_ = (self1);
    std::vector<KeyPoint> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getKeypoints(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (detail_ImageFeatures)

template<>
struct Evision_Converter< cv::detail::ImageFeatures >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const cv::detail::ImageFeatures& r)
    {
        return evision_detail_ImageFeatures_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, cv::detail::ImageFeatures& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        cv::detail::ImageFeatures * dst_ = nullptr;
        if (evision_detail_ImageFeatures_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected cv::detail::ImageFeatures for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// detail_MatchesInfo (Generic)
//================================================================================

// GetSet (detail_MatchesInfo)


static ERL_NIF_TERM evision_detail_MatchesInfo_get_H(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::detail::MatchesInfo* self_ptr = 0;
    if (!evision_detail_MatchesInfo_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::detail::MatchesInfo` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->H);
}

static ERL_NIF_TERM evision_detail_MatchesInfo_set_H(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::detail::MatchesInfo* self_ptr = 0;

    if (!evision_detail_MatchesInfo_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::detail::MatchesInfo` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->H, ArgInfo("H", false))) {
        bool success;
        return evision_from_as_map<cv::detail::MatchesInfo>(env, *self_ptr, self, "\"Detail.MatchesInfo\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_detail_MatchesInfo_get_confidence(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::detail::MatchesInfo* self_ptr = 0;
    if (!evision_detail_MatchesInfo_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::detail::MatchesInfo` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->confidence);
}

static ERL_NIF_TERM evision_detail_MatchesInfo_set_confidence(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::detail::MatchesInfo* self_ptr = 0;

    if (!evision_detail_MatchesInfo_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::detail::MatchesInfo` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->confidence, ArgInfo("confidence", false))) {
        bool success;
        return evision_from_as_map<cv::detail::MatchesInfo>(env, *self_ptr, self, "\"Detail.MatchesInfo\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_detail_MatchesInfo_get_dst_img_idx(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::detail::MatchesInfo* self_ptr = 0;
    if (!evision_detail_MatchesInfo_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::detail::MatchesInfo` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->dst_img_idx);
}

static ERL_NIF_TERM evision_detail_MatchesInfo_set_dst_img_idx(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::detail::MatchesInfo* self_ptr = 0;

    if (!evision_detail_MatchesInfo_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::detail::MatchesInfo` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->dst_img_idx, ArgInfo("dst_img_idx", false))) {
        bool success;
        return evision_from_as_map<cv::detail::MatchesInfo>(env, *self_ptr, self, "\"Detail.MatchesInfo\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_detail_MatchesInfo_get_inliers_mask(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::detail::MatchesInfo* self_ptr = 0;
    if (!evision_detail_MatchesInfo_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::detail::MatchesInfo` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->inliers_mask);
}

static ERL_NIF_TERM evision_detail_MatchesInfo_set_inliers_mask(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::detail::MatchesInfo* self_ptr = 0;

    if (!evision_detail_MatchesInfo_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::detail::MatchesInfo` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->inliers_mask, ArgInfo("inliers_mask", false))) {
        bool success;
        return evision_from_as_map<cv::detail::MatchesInfo>(env, *self_ptr, self, "\"Detail.MatchesInfo\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_detail_MatchesInfo_get_matches(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::detail::MatchesInfo* self_ptr = 0;
    if (!evision_detail_MatchesInfo_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::detail::MatchesInfo` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->matches);
}

static ERL_NIF_TERM evision_detail_MatchesInfo_set_matches(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::detail::MatchesInfo* self_ptr = 0;

    if (!evision_detail_MatchesInfo_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::detail::MatchesInfo` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->matches, ArgInfo("matches", false))) {
        bool success;
        return evision_from_as_map<cv::detail::MatchesInfo>(env, *self_ptr, self, "\"Detail.MatchesInfo\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_detail_MatchesInfo_get_num_inliers(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::detail::MatchesInfo* self_ptr = 0;
    if (!evision_detail_MatchesInfo_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::detail::MatchesInfo` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->num_inliers);
}

static ERL_NIF_TERM evision_detail_MatchesInfo_set_num_inliers(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::detail::MatchesInfo* self_ptr = 0;

    if (!evision_detail_MatchesInfo_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::detail::MatchesInfo` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->num_inliers, ArgInfo("num_inliers", false))) {
        bool success;
        return evision_from_as_map<cv::detail::MatchesInfo>(env, *self_ptr, self, "\"Detail.MatchesInfo\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_detail_MatchesInfo_get_src_img_idx(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::detail::MatchesInfo* self_ptr = 0;
    if (!evision_detail_MatchesInfo_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::detail::MatchesInfo` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->src_img_idx);
}

static ERL_NIF_TERM evision_detail_MatchesInfo_set_src_img_idx(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::detail::MatchesInfo* self_ptr = 0;

    if (!evision_detail_MatchesInfo_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::detail::MatchesInfo` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->src_img_idx, ArgInfo("src_img_idx", false))) {
        bool success;
        return evision_from_as_map<cv::detail::MatchesInfo>(env, *self_ptr, self, "\"Detail.MatchesInfo\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}


// Methods (detail_MatchesInfo)

static ERL_NIF_TERM evision_cv_detail_detail_MatchesInfo_getInliers(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::detail::MatchesInfo * self1 = 0;
    if (!evision_detail_MatchesInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::detail::MatchesInfo` from `self`: mismatched type or invalid resource?");
    }
    cv::detail::MatchesInfo* _self_ = (self1);
    std::vector<uchar> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getInliers(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_MatchesInfo_getMatches(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::detail::MatchesInfo * self1 = 0;
    if (!evision_detail_MatchesInfo_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::detail::MatchesInfo` from `self`: mismatched type or invalid resource?");
    }
    cv::detail::MatchesInfo* _self_ = (self1);
    std::vector<DMatch> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getMatches(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (detail_MatchesInfo)

template<>
struct Evision_Converter< cv::detail::MatchesInfo >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const cv::detail::MatchesInfo& r)
    {
        return evision_detail_MatchesInfo_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, cv::detail::MatchesInfo& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        cv::detail::MatchesInfo * dst_ = nullptr;
        if (evision_detail_MatchesInfo_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected cv::detail::MatchesInfo for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// detail_MultiBandBlender (Generic)
//================================================================================

// GetSet (detail_MultiBandBlender)



// Methods (detail_MultiBandBlender)

static ERL_NIF_TERM evision_cv_detail_detail_MultiBandBlender_MultiBandBlender(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    int try_gpu=false;
    int num_bands=5;
    int weight_type=CV_32F;

    // const char* keywords[] = { "try_gpu", "num_bands", "weight_type", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "try_gpu"), try_gpu, ArgInfo("try_gpu", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "num_bands"), num_bands, ArgInfo("num_bands", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "weight_type"), weight_type, ArgInfo("weight_type", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::detail::MultiBandBlender>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::detail::MultiBandBlender>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::detail::MultiBandBlender(try_gpu, num_bands, weight_type)), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::detail::MultiBandBlender>>(env, self->val, ret, "Detail.MultiBandBlender", success);;
        }
    }

    return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_MultiBandBlender_blend(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::MultiBandBlender> * self1 = 0;
    if (!evision_detail_MultiBandBlender_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::MultiBandBlender>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::MultiBandBlender> _self_ = *(self1);

    {
    Mat dst;
    Mat dst_mask;

    // const char* keywords[] = { "dst", "dst_mask", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst_mask"), dst_mask, ArgInfo("dst_mask", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->blend(dst, dst_mask), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, dst), evision_from(env, dst_mask));
        }
    }

    }
    

    {
    UMat dst;
    UMat dst_mask;

    // const char* keywords[] = { "dst", "dst_mask", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst_mask"), dst_mask, ArgInfo("dst_mask", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->blend(dst, dst_mask), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, dst), evision_from(env, dst_mask));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_MultiBandBlender_feed(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::MultiBandBlender> * self1 = 0;
    if (!evision_detail_MultiBandBlender_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::MultiBandBlender>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::MultiBandBlender> _self_ = *(self1);

    {
    Mat img;
    Mat mask;
    Point tl;

    // const char* keywords[] = { "img", "mask", "tl", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tl"), tl, ArgInfo("tl", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->feed(img, mask, tl), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Detail.MultiBandBlender", success);
        }
    }

    }
    

    {
    UMat img;
    UMat mask;
    Point tl;

    // const char* keywords[] = { "img", "mask", "tl", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tl"), tl, ArgInfo("tl", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->feed(img, mask, tl), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Detail.MultiBandBlender", success);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_MultiBandBlender_numBands(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::MultiBandBlender> * self1 = 0;
    if (!evision_detail_MultiBandBlender_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::MultiBandBlender>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::MultiBandBlender> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->numBands(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_MultiBandBlender_prepare(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::MultiBandBlender> * self1 = 0;
    if (!evision_detail_MultiBandBlender_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::MultiBandBlender>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::MultiBandBlender> _self_ = *(self1);
    Rect dst_roi;

    // const char* keywords[] = { "dst_roi", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "dst_roi"), dst_roi, ArgInfo("dst_roi", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->prepare(dst_roi), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Detail.MultiBandBlender", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_MultiBandBlender_setNumBands(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::MultiBandBlender> * self1 = 0;
    if (!evision_detail_MultiBandBlender_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::MultiBandBlender>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::MultiBandBlender> _self_ = *(self1);
    int val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setNumBands(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Detail.MultiBandBlender", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (detail_MultiBandBlender)

template<>
struct Evision_Converter< Ptr<cv::detail::MultiBandBlender> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::detail::MultiBandBlender>& r)
    {
        return evision_detail_MultiBandBlender_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::detail::MultiBandBlender>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::detail::MultiBandBlender> * dst_ = nullptr;
        if (evision_detail_MultiBandBlender_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::detail::MultiBandBlender> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// detail_NoBundleAdjuster (Generic)
//================================================================================

// GetSet (detail_NoBundleAdjuster)



// Methods (detail_NoBundleAdjuster)

static ERL_NIF_TERM evision_cv_detail_detail_NoBundleAdjuster_NoBundleAdjuster(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        evision_res<Ptr<cv::detail::NoBundleAdjuster>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::detail::NoBundleAdjuster>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::detail::NoBundleAdjuster()), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::detail::NoBundleAdjuster>>(env, self->val, ret, "Detail.NoBundleAdjuster", success);;
        }
    }

    return enif_make_badarg(env);
}



// Converter (detail_NoBundleAdjuster)

template<>
struct Evision_Converter< Ptr<cv::detail::NoBundleAdjuster> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::detail::NoBundleAdjuster>& r)
    {
        return evision_detail_NoBundleAdjuster_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::detail::NoBundleAdjuster>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::detail::NoBundleAdjuster> * dst_ = nullptr;
        if (evision_detail_NoBundleAdjuster_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::detail::NoBundleAdjuster> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// detail_NoExposureCompensator (Generic)
//================================================================================

// GetSet (detail_NoExposureCompensator)



// Methods (detail_NoExposureCompensator)

static ERL_NIF_TERM evision_cv_detail_detail_NoExposureCompensator_apply(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::NoExposureCompensator> * self1 = 0;
    if (!evision_detail_NoExposureCompensator_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::NoExposureCompensator>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::NoExposureCompensator> _self_ = *(self1);

    {
    int arg1=0;
    Point arg2;
    Mat arg3;
    Mat arg4;

    // const char* keywords[] = { "arg1", "arg2", "arg3", "arg4", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "arg1"), arg1, ArgInfo("arg1", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "arg2"), arg2, ArgInfo("arg2", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "arg3"), arg3, ArgInfo("arg3", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "arg4"), arg4, ArgInfo("arg4", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->apply(arg1, arg2, arg3, arg4), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, arg3);
        }
    }

    }
    

    {
    int arg1=0;
    Point arg2;
    UMat arg3;
    UMat arg4;

    // const char* keywords[] = { "arg1", "arg2", "arg3", "arg4", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "arg1"), arg1, ArgInfo("arg1", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "arg2"), arg2, ArgInfo("arg2", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "arg3"), arg3, ArgInfo("arg3", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "arg4"), arg4, ArgInfo("arg4", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->apply(arg1, arg2, arg3, arg4), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, arg3);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_NoExposureCompensator_getMatGains(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::NoExposureCompensator> * self1 = 0;
    if (!evision_detail_NoExposureCompensator_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::NoExposureCompensator>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::NoExposureCompensator> _self_ = *(self1);
    vector_Mat umv;

    // const char* keywords[] = { "umv", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "umv"), umv, ArgInfo("umv", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->getMatGains(umv), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, umv);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_NoExposureCompensator_setMatGains(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::NoExposureCompensator> * self1 = 0;
    if (!evision_detail_NoExposureCompensator_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::NoExposureCompensator>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::NoExposureCompensator> _self_ = *(self1);
    vector_Mat umv;

    // const char* keywords[] = { "umv", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "umv"), umv, ArgInfo("umv", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setMatGains(umv), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Detail.NoExposureCompensator", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (detail_NoExposureCompensator)

template<>
struct Evision_Converter< Ptr<cv::detail::NoExposureCompensator> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::detail::NoExposureCompensator>& r)
    {
        return evision_detail_NoExposureCompensator_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::detail::NoExposureCompensator>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::detail::NoExposureCompensator> * dst_ = nullptr;
        if (evision_detail_NoExposureCompensator_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::detail::NoExposureCompensator> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// detail_NoSeamFinder (Generic)
//================================================================================

// GetSet (detail_NoSeamFinder)



// Methods (detail_NoSeamFinder)

static ERL_NIF_TERM evision_cv_detail_detail_NoSeamFinder_find(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::NoSeamFinder> * self1 = 0;
    if (!evision_detail_NoSeamFinder_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::NoSeamFinder>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::NoSeamFinder> _self_ = *(self1);
    vector_UMat arg1;
    vector_Point arg2;
    vector_UMat arg3;

    // const char* keywords[] = { "arg1", "arg2", "arg3", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "arg1"), arg1, ArgInfo("arg1", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "arg2"), arg2, ArgInfo("arg2", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "arg3"), arg3, ArgInfo("arg3", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->find(arg1, arg2, arg3), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, arg3);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (detail_NoSeamFinder)

template<>
struct Evision_Converter< Ptr<cv::detail::NoSeamFinder> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::detail::NoSeamFinder>& r)
    {
        return evision_detail_NoSeamFinder_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::detail::NoSeamFinder>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::detail::NoSeamFinder> * dst_ = nullptr;
        if (evision_detail_NoSeamFinder_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::detail::NoSeamFinder> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// detail_PairwiseSeamFinder (Generic)
//================================================================================

// GetSet (detail_PairwiseSeamFinder)



// Methods (detail_PairwiseSeamFinder)

static ERL_NIF_TERM evision_cv_detail_detail_PairwiseSeamFinder_find(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::PairwiseSeamFinder> * self1 = 0;
    if (!evision_detail_PairwiseSeamFinder_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::PairwiseSeamFinder>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::PairwiseSeamFinder> _self_ = *(self1);
    vector_UMat src;
    vector_Point corners;
    vector_UMat masks;

    // const char* keywords[] = { "src", "corners", "masks", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "corners"), corners, ArgInfo("corners", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "masks"), masks, ArgInfo("masks", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->find(src, corners, masks), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, masks);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (detail_PairwiseSeamFinder)

template<>
struct Evision_Converter< Ptr<cv::detail::PairwiseSeamFinder> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::detail::PairwiseSeamFinder>& r)
    {
        return evision_detail_PairwiseSeamFinder_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::detail::PairwiseSeamFinder>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::detail::PairwiseSeamFinder> * dst_ = nullptr;
        if (evision_detail_PairwiseSeamFinder_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::detail::PairwiseSeamFinder> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// detail_ProjectorBase (Generic)
//================================================================================

// GetSet (detail_ProjectorBase)



// Methods (detail_ProjectorBase)



// Converter (detail_ProjectorBase)

template<>
struct Evision_Converter< cv::detail::ProjectorBase >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const cv::detail::ProjectorBase& r)
    {
        return evision_detail_ProjectorBase_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, cv::detail::ProjectorBase& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        cv::detail::ProjectorBase * dst_ = nullptr;
        if (evision_detail_ProjectorBase_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected cv::detail::ProjectorBase for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// detail_SeamFinder (Generic)
//================================================================================

// GetSet (detail_SeamFinder)



// Methods (detail_SeamFinder)

static ERL_NIF_TERM evision_cv_detail_detail_SeamFinder_createDefault_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    int type=0;
    Ptr<SeamFinder> retval;

    // const char* keywords[] = { "type", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "type"), type, ArgInfo("type", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::detail::SeamFinder::createDefault(type), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_SeamFinder_find(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::SeamFinder> * self1 = 0;
    if (!evision_detail_SeamFinder_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::SeamFinder>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::SeamFinder> _self_ = *(self1);
    vector_UMat src;
    vector_Point corners;
    vector_UMat masks;

    // const char* keywords[] = { "src", "corners", "masks", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "corners"), corners, ArgInfo("corners", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "masks"), masks, ArgInfo("masks", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->find(src, corners, masks), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, masks);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (detail_SeamFinder)

template<>
struct Evision_Converter< Ptr<cv::detail::SeamFinder> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::detail::SeamFinder>& r)
    {
        return evision_detail_SeamFinder_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::detail::SeamFinder>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::detail::SeamFinder> * dst_ = nullptr;
        if (evision_detail_SeamFinder_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::detail::SeamFinder> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// detail_SphericalProjector (Generic)
//================================================================================

// GetSet (detail_SphericalProjector)



// Methods (detail_SphericalProjector)

static ERL_NIF_TERM evision_cv_detail_detail_SphericalProjector_mapBackward(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::detail::SphericalProjector * self1 = 0;
    if (!evision_detail_SphericalProjector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::detail::SphericalProjector` from `self`: mismatched type or invalid resource?");
    }
    cv::detail::SphericalProjector* _self_ = (self1);
    float u=0.f;
    float v=0.f;
    float x=0.f;
    float y=0.f;

    // const char* keywords[] = { "u", "v", "x", "y", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "u"), u, ArgInfo("u", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "v"), v, ArgInfo("v", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "x"), x, ArgInfo("x", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "y"), y, ArgInfo("y", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->mapBackward(u, v, x, y), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Detail.SphericalProjector", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_SphericalProjector_mapForward(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::detail::SphericalProjector * self1 = 0;
    if (!evision_detail_SphericalProjector_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::detail::SphericalProjector` from `self`: mismatched type or invalid resource?");
    }
    cv::detail::SphericalProjector* _self_ = (self1);
    float x=0.f;
    float y=0.f;
    float u=0.f;
    float v=0.f;

    // const char* keywords[] = { "x", "y", "u", "v", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "x"), x, ArgInfo("x", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "y"), y, ArgInfo("y", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "u"), u, ArgInfo("u", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "v"), v, ArgInfo("v", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->mapForward(x, y, u, v), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Detail.SphericalProjector", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (detail_SphericalProjector)

template<>
struct Evision_Converter< cv::detail::SphericalProjector >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const cv::detail::SphericalProjector& r)
    {
        return evision_detail_SphericalProjector_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, cv::detail::SphericalProjector& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        cv::detail::SphericalProjector * dst_ = nullptr;
        if (evision_detail_SphericalProjector_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected cv::detail::SphericalProjector for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// detail_Timelapser (Generic)
//================================================================================

// GetSet (detail_Timelapser)



// Methods (detail_Timelapser)

static ERL_NIF_TERM evision_cv_detail_detail_Timelapser_createDefault_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    int type=0;
    Ptr<Timelapser> retval;

    // const char* keywords[] = { "type", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "type"), type, ArgInfo("type", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::detail::Timelapser::createDefault(type), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_Timelapser_getDst(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::Timelapser> * self1 = 0;
    if (!evision_detail_Timelapser_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::Timelapser>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::Timelapser> _self_ = *(self1);
    UMat retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getDst(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_Timelapser_initialize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::Timelapser> * self1 = 0;
    if (!evision_detail_Timelapser_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::Timelapser>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::Timelapser> _self_ = *(self1);
    vector_Point corners;
    vector_Size sizes;

    // const char* keywords[] = { "corners", "sizes", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "corners"), corners, ArgInfo("corners", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sizes"), sizes, ArgInfo("sizes", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->initialize(corners, sizes), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Detail.Timelapser", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_detail_Timelapser_process(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::Timelapser> * self1 = 0;
    if (!evision_detail_Timelapser_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::Timelapser>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::Timelapser> _self_ = *(self1);

    {
    Mat img;
    Mat mask;
    Point tl;

    // const char* keywords[] = { "img", "mask", "tl", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tl"), tl, ArgInfo("tl", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->process(img, mask, tl), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Detail.Timelapser", success);
        }
    }

    }
    

    {
    UMat img;
    UMat mask;
    Point tl;

    // const char* keywords[] = { "img", "mask", "tl", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tl"), tl, ArgInfo("tl", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->process(img, mask, tl), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Detail.Timelapser", success);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (detail_Timelapser)

template<>
struct Evision_Converter< Ptr<cv::detail::Timelapser> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::detail::Timelapser>& r)
    {
        return evision_detail_Timelapser_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::detail::Timelapser>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::detail::Timelapser> * dst_ = nullptr;
        if (evision_detail_Timelapser_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::detail::Timelapser> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// detail_TimelapserCrop (Generic)
//================================================================================

// GetSet (detail_TimelapserCrop)



// Methods (detail_TimelapserCrop)



// Converter (detail_TimelapserCrop)

template<>
struct Evision_Converter< Ptr<cv::detail::TimelapserCrop> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::detail::TimelapserCrop>& r)
    {
        return evision_detail_TimelapserCrop_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::detail::TimelapserCrop>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::detail::TimelapserCrop> * dst_ = nullptr;
        if (evision_detail_TimelapserCrop_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::detail::TimelapserCrop> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// detail_VoronoiSeamFinder (Generic)
//================================================================================

// GetSet (detail_VoronoiSeamFinder)



// Methods (detail_VoronoiSeamFinder)

static ERL_NIF_TERM evision_cv_detail_detail_VoronoiSeamFinder_find(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::detail::VoronoiSeamFinder> * self1 = 0;
    if (!evision_detail_VoronoiSeamFinder_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::detail::VoronoiSeamFinder>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::detail::VoronoiSeamFinder> _self_ = *(self1);
    vector_UMat src;
    vector_Point corners;
    vector_UMat masks;

    // const char* keywords[] = { "src", "corners", "masks", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "corners"), corners, ArgInfo("corners", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "masks"), masks, ArgInfo("masks", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->find(src, corners, masks), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, masks);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (detail_VoronoiSeamFinder)

template<>
struct Evision_Converter< Ptr<cv::detail::VoronoiSeamFinder> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::detail::VoronoiSeamFinder>& r)
    {
        return evision_detail_VoronoiSeamFinder_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::detail::VoronoiSeamFinder>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::detail::VoronoiSeamFinder> * dst_ = nullptr;
        if (evision_detail_VoronoiSeamFinder_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::detail::VoronoiSeamFinder> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// dnn_ClassificationModel (Generic)
//================================================================================

// GetSet (dnn_ClassificationModel)



// Methods (dnn_ClassificationModel)

static ERL_NIF_TERM evision_cv_dnn_dnn_ClassificationModel_ClassificationModel(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    {
    String model;
    String config="";

    // const char* keywords[] = { "model", "config", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "model"), model, ArgInfo("model", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "config"), config, ArgInfo("config", 0)) )
    {
        int error_flag = false;
        evision_res<cv::dnn::ClassificationModel> * self = nullptr;
        alloc_resource(&self);
        if(self) ERRWRAP2(new (&(self->val)) cv::dnn::ClassificationModel(model, config), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<cv::dnn::ClassificationModel>(env, self->val, ret, "DNN.ClassificationModel", success);;
        }
    }

    }
    

    {
    Net network;

    // const char* keywords[] = { "network", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "network"), network, ArgInfo("network", 0)) )
    {
        int error_flag = false;
        evision_res<cv::dnn::ClassificationModel> * self = nullptr;
        alloc_resource(&self);
        if(self) ERRWRAP2(new (&(self->val)) cv::dnn::ClassificationModel(network), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<cv::dnn::ClassificationModel>(env, self->val, ret, "DNN.ClassificationModel", success);;
        }
    }

    }

    return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_ClassificationModel_classify(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::ClassificationModel * self1 = 0;
    if (!evision_dnn_ClassificationModel_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::dnn::ClassificationModel` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::ClassificationModel* _self_ = (self1);

    {
    Mat frame;
    int classId;
    float conf;

    // const char* keywords[] = { "frame", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "frame"), frame, ArgInfo("frame", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->classify(frame, classId, conf), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, classId), evision_from(env, conf));
        }
    }

    }
    

    {
    UMat frame;
    int classId;
    float conf;

    // const char* keywords[] = { "frame", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "frame"), frame, ArgInfo("frame", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->classify(frame, classId, conf), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, classId), evision_from(env, conf));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_ClassificationModel_getEnableSoftmaxPostProcessing(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::ClassificationModel * self1 = 0;
    if (!evision_dnn_ClassificationModel_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::dnn::ClassificationModel` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::ClassificationModel* _self_ = (self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getEnableSoftmaxPostProcessing(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_ClassificationModel_setEnableSoftmaxPostProcessing(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::ClassificationModel * self1 = 0;
    if (!evision_dnn_ClassificationModel_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::dnn::ClassificationModel` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::ClassificationModel* _self_ = (self1);
    bool enable=0;
    ClassificationModel retval;

    // const char* keywords[] = { "enable", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "enable"), enable, ArgInfo("enable", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->setEnableSoftmaxPostProcessing(enable), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (dnn_ClassificationModel)

template<>
struct Evision_Converter< cv::dnn::ClassificationModel >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const cv::dnn::ClassificationModel& r)
    {
        return evision_dnn_ClassificationModel_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, cv::dnn::ClassificationModel& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        cv::dnn::ClassificationModel * dst_ = nullptr;
        if (evision_dnn_ClassificationModel_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected cv::dnn::ClassificationModel for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// dnn_DetectionModel (Generic)
//================================================================================

// GetSet (dnn_DetectionModel)



// Methods (dnn_DetectionModel)

static ERL_NIF_TERM evision_cv_dnn_dnn_DetectionModel_DetectionModel(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    {
    String model;
    String config="";

    // const char* keywords[] = { "model", "config", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "model"), model, ArgInfo("model", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "config"), config, ArgInfo("config", 0)) )
    {
        int error_flag = false;
        evision_res<cv::dnn::DetectionModel> * self = nullptr;
        alloc_resource(&self);
        if(self) ERRWRAP2(new (&(self->val)) cv::dnn::DetectionModel(model, config), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<cv::dnn::DetectionModel>(env, self->val, ret, "DNN.DetectionModel", success);;
        }
    }

    }
    

    {
    Net network;

    // const char* keywords[] = { "network", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "network"), network, ArgInfo("network", 0)) )
    {
        int error_flag = false;
        evision_res<cv::dnn::DetectionModel> * self = nullptr;
        alloc_resource(&self);
        if(self) ERRWRAP2(new (&(self->val)) cv::dnn::DetectionModel(network), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<cv::dnn::DetectionModel>(env, self->val, ret, "DNN.DetectionModel", success);;
        }
    }

    }

    return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_DetectionModel_detect(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::DetectionModel * self1 = 0;
    if (!evision_dnn_DetectionModel_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::dnn::DetectionModel` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::DetectionModel* _self_ = (self1);

    {
    Mat frame;
    vector_int classIds;
    vector_float confidences;
    vector_Rect boxes;
    float confThreshold=0.5f;
    float nmsThreshold=0.0f;

    // const char* keywords[] = { "frame", "confThreshold", "nmsThreshold", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "frame"), frame, ArgInfo("frame", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "confThreshold"), confThreshold, ArgInfo("confThreshold", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nmsThreshold"), nmsThreshold, ArgInfo("nmsThreshold", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(frame, classIds, confidences, boxes, confThreshold, nmsThreshold), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, classIds), evision_from(env, confidences), evision_from(env, boxes));
        }
    }

    }
    

    {
    UMat frame;
    vector_int classIds;
    vector_float confidences;
    vector_Rect boxes;
    float confThreshold=0.5f;
    float nmsThreshold=0.0f;

    // const char* keywords[] = { "frame", "confThreshold", "nmsThreshold", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "frame"), frame, ArgInfo("frame", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "confThreshold"), confThreshold, ArgInfo("confThreshold", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nmsThreshold"), nmsThreshold, ArgInfo("nmsThreshold", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(frame, classIds, confidences, boxes, confThreshold, nmsThreshold), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, classIds), evision_from(env, confidences), evision_from(env, boxes));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_DetectionModel_getNmsAcrossClasses(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::DetectionModel * self1 = 0;
    if (!evision_dnn_DetectionModel_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::dnn::DetectionModel` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::DetectionModel* _self_ = (self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getNmsAcrossClasses(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_DetectionModel_setNmsAcrossClasses(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::DetectionModel * self1 = 0;
    if (!evision_dnn_DetectionModel_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::dnn::DetectionModel` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::DetectionModel* _self_ = (self1);
    bool value=0;
    DetectionModel retval;

    // const char* keywords[] = { "value", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "value"), value, ArgInfo("value", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->setNmsAcrossClasses(value), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (dnn_DetectionModel)

template<>
struct Evision_Converter< cv::dnn::DetectionModel >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const cv::dnn::DetectionModel& r)
    {
        return evision_dnn_DetectionModel_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, cv::dnn::DetectionModel& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        cv::dnn::DetectionModel * dst_ = nullptr;
        if (evision_dnn_DetectionModel_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected cv::dnn::DetectionModel for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// dnn_DictValue (Generic)
//================================================================================

// GetSet (dnn_DictValue)



// Methods (dnn_DictValue)

static ERL_NIF_TERM evision_cv_dnn_dnn_DictValue_DictValue(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    {
    int i=0;

    // const char* keywords[] = { "i", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "i"), i, ArgInfo("i", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::dnn::DictValue>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::dnn::DictValue>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::dnn::DictValue(i)), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::dnn::DictValue>>(env, self->val, ret, "DNN.DictValue", success);;
        }
    }

    }
    

    {
    double p=0;

    // const char* keywords[] = { "p", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "p"), p, ArgInfo("p", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::dnn::DictValue>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::dnn::DictValue>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::dnn::DictValue(p)), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::dnn::DictValue>>(env, self->val, ret, "DNN.DictValue", success);;
        }
    }

    }
    

    {
    String s;

    // const char* keywords[] = { "s", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "s"), s, ArgInfo("s", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::dnn::DictValue>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::dnn::DictValue>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::dnn::DictValue(s)), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::dnn::DictValue>>(env, self->val, ret, "DNN.DictValue", success);;
        }
    }

    }

    return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_DictValue_getIntValue(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::dnn::DictValue> * self1 = 0;
    if (!evision_dnn_DictValue_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::dnn::DictValue>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::dnn::DictValue> _self_ = *(self1);
    int idx=-1;
    int retval;

    // const char* keywords[] = { "idx", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "idx"), idx, ArgInfo("idx", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getIntValue(idx), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_DictValue_getRealValue(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::dnn::DictValue> * self1 = 0;
    if (!evision_dnn_DictValue_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::dnn::DictValue>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::dnn::DictValue> _self_ = *(self1);
    int idx=-1;
    double retval;

    // const char* keywords[] = { "idx", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "idx"), idx, ArgInfo("idx", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getRealValue(idx), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_DictValue_getStringValue(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::dnn::DictValue> * self1 = 0;
    if (!evision_dnn_DictValue_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::dnn::DictValue>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::dnn::DictValue> _self_ = *(self1);
    int idx=-1;
    String retval;

    // const char* keywords[] = { "idx", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "idx"), idx, ArgInfo("idx", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getStringValue(idx), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_DictValue_isInt(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::dnn::DictValue> * self1 = 0;
    if (!evision_dnn_DictValue_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::dnn::DictValue>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::dnn::DictValue> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->isInt(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_DictValue_isReal(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::dnn::DictValue> * self1 = 0;
    if (!evision_dnn_DictValue_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::dnn::DictValue>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::dnn::DictValue> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->isReal(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_DictValue_isString(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::dnn::DictValue> * self1 = 0;
    if (!evision_dnn_DictValue_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::dnn::DictValue>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::dnn::DictValue> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->isString(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (dnn_DictValue)

template<>
struct Evision_Converter< Ptr<cv::dnn::DictValue> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::dnn::DictValue>& r)
    {
        return evision_dnn_DictValue_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::dnn::DictValue>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::dnn::DictValue> * dst_ = nullptr;
        if (evision_dnn_DictValue_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::dnn::DictValue> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// dnn_KeypointsModel (Generic)
//================================================================================

// GetSet (dnn_KeypointsModel)



// Methods (dnn_KeypointsModel)

static ERL_NIF_TERM evision_cv_dnn_dnn_KeypointsModel_KeypointsModel(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    {
    String model;
    String config="";

    // const char* keywords[] = { "model", "config", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "model"), model, ArgInfo("model", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "config"), config, ArgInfo("config", 0)) )
    {
        int error_flag = false;
        evision_res<cv::dnn::KeypointsModel> * self = nullptr;
        alloc_resource(&self);
        if(self) ERRWRAP2(new (&(self->val)) cv::dnn::KeypointsModel(model, config), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<cv::dnn::KeypointsModel>(env, self->val, ret, "DNN.KeypointsModel", success);;
        }
    }

    }
    

    {
    Net network;

    // const char* keywords[] = { "network", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "network"), network, ArgInfo("network", 0)) )
    {
        int error_flag = false;
        evision_res<cv::dnn::KeypointsModel> * self = nullptr;
        alloc_resource(&self);
        if(self) ERRWRAP2(new (&(self->val)) cv::dnn::KeypointsModel(network), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<cv::dnn::KeypointsModel>(env, self->val, ret, "DNN.KeypointsModel", success);;
        }
    }

    }

    return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_KeypointsModel_estimate(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::KeypointsModel * self1 = 0;
    if (!evision_dnn_KeypointsModel_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::dnn::KeypointsModel` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::KeypointsModel* _self_ = (self1);

    {
    Mat frame;
    float thresh=0.5;
    std::vector<Point2f> retval;

    // const char* keywords[] = { "frame", "thresh", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "frame"), frame, ArgInfo("frame", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "thresh"), thresh, ArgInfo("thresh", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->estimate(frame, thresh), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    UMat frame;
    float thresh=0.5;
    std::vector<Point2f> retval;

    // const char* keywords[] = { "frame", "thresh", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "frame"), frame, ArgInfo("frame", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "thresh"), thresh, ArgInfo("thresh", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->estimate(frame, thresh), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (dnn_KeypointsModel)

template<>
struct Evision_Converter< cv::dnn::KeypointsModel >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const cv::dnn::KeypointsModel& r)
    {
        return evision_dnn_KeypointsModel_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, cv::dnn::KeypointsModel& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        cv::dnn::KeypointsModel * dst_ = nullptr;
        if (evision_dnn_KeypointsModel_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected cv::dnn::KeypointsModel for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// dnn_Layer (Generic)
//================================================================================

// GetSet (dnn_Layer)


static ERL_NIF_TERM evision_dnn_Layer_get_blobs(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    Ptr<cv::dnn::Layer>* self_ptr = 0;
    if (!evision_dnn_Layer_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `Ptr<cv::dnn::Layer>` from `self`: mismatched type or invalid resource?");
    }

    cv::dnn::Layer* _self_algo_ = dynamic_cast<cv::dnn::Layer*>(self_ptr->get());
    if (!_self_algo_) {
        return failmsgp(env, "Incorrect type of object (must be 'dnn_Layer' or its derivative)");
    }

    return evision_from(env, _self_algo_->blobs);
}

static ERL_NIF_TERM evision_dnn_Layer_set_blobs(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    Ptr<cv::dnn::Layer>* self_ptr = 0;
    if (!evision_dnn_Layer_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `Ptr<cv::dnn::Layer>` from `self`: mismatched type or invalid resource?");
    }

    cv::dnn::Layer* _self_algo_ = dynamic_cast<cv::dnn::Layer*>(self_ptr->get());
    if (!_self_algo_) {
        return failmsgp(env, "Incorrect type of object (must be 'dnn_Layer' or its derivative)");
    }

    if (evision_to_safe(env, argv[1], _self_algo_->blobs, ArgInfo("blobs", false))) {
        bool success;
        return evision_from_as_map<cv::dnn::Layer>(env, *_self_algo_, self, "\"DNN.Layer\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_dnn_Layer_get_name(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    Ptr<cv::dnn::Layer>* self_ptr = 0;
    if (!evision_dnn_Layer_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `Ptr<cv::dnn::Layer>` from `self`: mismatched type or invalid resource?");
    }

    cv::dnn::Layer* _self_algo_ = dynamic_cast<cv::dnn::Layer*>(self_ptr->get());
    if (!_self_algo_) {
        return failmsgp(env, "Incorrect type of object (must be 'dnn_Layer' or its derivative)");
    }

    return evision_from(env, _self_algo_->name);
}

static ERL_NIF_TERM evision_dnn_Layer_get_preferableTarget(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    Ptr<cv::dnn::Layer>* self_ptr = 0;
    if (!evision_dnn_Layer_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `Ptr<cv::dnn::Layer>` from `self`: mismatched type or invalid resource?");
    }

    cv::dnn::Layer* _self_algo_ = dynamic_cast<cv::dnn::Layer*>(self_ptr->get());
    if (!_self_algo_) {
        return failmsgp(env, "Incorrect type of object (must be 'dnn_Layer' or its derivative)");
    }

    return evision_from(env, _self_algo_->preferableTarget);
}

static ERL_NIF_TERM evision_dnn_Layer_get_type(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    Ptr<cv::dnn::Layer>* self_ptr = 0;
    if (!evision_dnn_Layer_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `Ptr<cv::dnn::Layer>` from `self`: mismatched type or invalid resource?");
    }

    cv::dnn::Layer* _self_algo_ = dynamic_cast<cv::dnn::Layer*>(self_ptr->get());
    if (!_self_algo_) {
        return failmsgp(env, "Incorrect type of object (must be 'dnn_Layer' or its derivative)");
    }

    return evision_from(env, _self_algo_->type);
}


// Methods (dnn_Layer)

static ERL_NIF_TERM evision_cv_dnn_Layer_clear(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::dnn::Layer> * self1 = 0;
    if (!evision_dnn_Layer_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::dnn::Layer>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::dnn::Layer> _self_ = *(self1);

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::clear(), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "DNN.Layer", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_Layer_empty(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::dnn::Layer> * self1 = 0;
    if (!evision_dnn_Layer_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::dnn::Layer>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::dnn::Layer> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->Algorithm::empty(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_Layer_finalize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::dnn::Layer> * self1 = 0;
    if (!evision_dnn_Layer_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::dnn::Layer>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::dnn::Layer> _self_ = *(self1);

    {
    vector_Mat inputs;
    vector_Mat outputs;

    // const char* keywords[] = { "inputs", "outputs", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "inputs"), inputs, ArgInfo("inputs", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "outputs"), outputs, ArgInfo("outputs", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->finalize(inputs, outputs), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, outputs);
        }
    }

    }
    

    {
    vector_UMat inputs;
    vector_UMat outputs;

    // const char* keywords[] = { "inputs", "outputs", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "inputs"), inputs, ArgInfo("inputs", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "outputs"), outputs, ArgInfo("outputs", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->finalize(inputs, outputs), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, outputs);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_Layer_getDefaultName(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::dnn::Layer> * self1 = 0;
    if (!evision_dnn_Layer_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::dnn::Layer>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::dnn::Layer> _self_ = *(self1);
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->Algorithm::getDefaultName(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_Layer_outputNameToIndex(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::dnn::Layer> * self1 = 0;
    if (!evision_dnn_Layer_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::dnn::Layer>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::dnn::Layer> _self_ = *(self1);
    String outputName;
    int retval;

    // const char* keywords[] = { "outputName", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "outputName"), outputName, ArgInfo("outputName", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->outputNameToIndex(outputName), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_Layer_read(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::dnn::Layer> * self1 = 0;
    if (!evision_dnn_Layer_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::dnn::Layer>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::dnn::Layer> _self_ = *(self1);
    FileNode fn_;

    // const char* keywords[] = { "fn_", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fn_"), fn_, ArgInfo("fn_", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::read(fn_), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "DNN.Layer", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_Layer_run(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::dnn::Layer> * self1 = 0;
    if (!evision_dnn_Layer_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::dnn::Layer>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::dnn::Layer> _self_ = *(self1);
    vector_Mat inputs;
    vector_Mat outputs;
    vector_Mat internals;

    // const char* keywords[] = { "inputs", "internals", "outputs", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "inputs"), inputs, ArgInfo("inputs", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "outputs"), outputs, ArgInfo("outputs", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "internals"), internals, ArgInfo("internals", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->run(inputs, outputs, internals), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, outputs), evision_from(env, internals));
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_Layer_save(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::dnn::Layer> * self1 = 0;
    if (!evision_dnn_Layer_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::dnn::Layer>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::dnn::Layer> _self_ = *(self1);
    String filename;

    // const char* keywords[] = { "filename", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::save(filename), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "DNN.Layer", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_Layer_write(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::dnn::Layer> * self1 = 0;
    if (!evision_dnn_Layer_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::dnn::Layer>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::dnn::Layer> _self_ = *(self1);
    Ptr<FileStorage> fs;
    String name;

    // const char* keywords[] = { "fs", "name", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fs"), fs, ArgInfo("fs", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "name"), name, ArgInfo("name", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::write(fs, name), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "DNN.Layer", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (dnn_Layer)

template<>
struct Evision_Converter< Ptr<cv::dnn::Layer> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::dnn::Layer>& r)
    {
        return evision_dnn_Layer_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::dnn::Layer>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::dnn::Layer> * dst_ = nullptr;
        if (evision_dnn_Layer_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::dnn::Layer> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// dnn_Model (Generic)
//================================================================================

// GetSet (dnn_Model)



// Methods (dnn_Model)

static ERL_NIF_TERM evision_cv_dnn_dnn_Model_Model(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    {
    String model;
    String config="";

    // const char* keywords[] = { "model", "config", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "model"), model, ArgInfo("model", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "config"), config, ArgInfo("config", 0)) )
    {
        int error_flag = false;
        evision_res<cv::dnn::Model> * self = nullptr;
        alloc_resource(&self);
        if(self) ERRWRAP2(new (&(self->val)) cv::dnn::Model(model, config), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<cv::dnn::Model>(env, self->val, ret, "DNN.Model", success);;
        }
    }

    }
    

    {
    Net network;

    // const char* keywords[] = { "network", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "network"), network, ArgInfo("network", 0)) )
    {
        int error_flag = false;
        evision_res<cv::dnn::Model> * self = nullptr;
        alloc_resource(&self);
        if(self) ERRWRAP2(new (&(self->val)) cv::dnn::Model(network), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<cv::dnn::Model>(env, self->val, ret, "DNN.Model", success);;
        }
    }

    }

    return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_Model_predict(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::Model * self1 = 0;
    if (!evision_dnn_Model_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::dnn::Model` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::Model* _self_ = (self1);

    {
    Mat frame;
    vector_Mat outs;

    // const char* keywords[] = { "frame", "outs", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "frame"), frame, ArgInfo("frame", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "outs"), outs, ArgInfo("outs", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->predict(frame, outs), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, outs);
        }
    }

    }
    

    {
    UMat frame;
    vector_UMat outs;

    // const char* keywords[] = { "frame", "outs", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "frame"), frame, ArgInfo("frame", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "outs"), outs, ArgInfo("outs", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->predict(frame, outs), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, outs);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_Model_setInputCrop(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::Model * self1 = 0;
    if (!evision_dnn_Model_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::dnn::Model` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::Model* _self_ = (self1);
    bool crop=0;
    Model retval;

    // const char* keywords[] = { "crop", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "crop"), crop, ArgInfo("crop", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->setInputCrop(crop), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_Model_setInputMean(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::Model * self1 = 0;
    if (!evision_dnn_Model_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::dnn::Model` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::Model* _self_ = (self1);
    Scalar mean;
    Model retval;

    // const char* keywords[] = { "mean", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "mean"), mean, ArgInfo("mean", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->setInputMean(mean), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_Model_setInputParams(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::Model * self1 = 0;
    if (!evision_dnn_Model_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::dnn::Model` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::Model* _self_ = (self1);
    double scale=1.0;
    Size size;
    Scalar mean;
    bool swapRB=false;
    bool crop=false;

    // const char* keywords[] = { "scale", "size", "mean", "swapRB", "crop", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "scale"), scale, ArgInfo("scale", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "size"), size, ArgInfo("size", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mean"), mean, ArgInfo("mean", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "swapRB"), swapRB, ArgInfo("swapRB", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "crop"), crop, ArgInfo("crop", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setInputParams(scale, size, mean, swapRB, crop), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "DNN.Model", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_Model_setInputScale(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::Model * self1 = 0;
    if (!evision_dnn_Model_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::dnn::Model` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::Model* _self_ = (self1);
    double scale=0;
    Model retval;

    // const char* keywords[] = { "scale", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "scale"), scale, ArgInfo("scale", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->setInputScale(scale), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_Model_setInputSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::Model * self1 = 0;
    if (!evision_dnn_Model_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::dnn::Model` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::Model* _self_ = (self1);

    {
    Size size;
    Model retval;

    // const char* keywords[] = { "size", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "size"), size, ArgInfo("size", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->setInputSize(size), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    int width=0;
    int height=0;
    Model retval;

    // const char* keywords[] = { "width", "height", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "width"), width, ArgInfo("width", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "height"), height, ArgInfo("height", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->setInputSize(width, height), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_Model_setInputSwapRB(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::Model * self1 = 0;
    if (!evision_dnn_Model_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::dnn::Model` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::Model* _self_ = (self1);
    bool swapRB=0;
    Model retval;

    // const char* keywords[] = { "swapRB", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "swapRB"), swapRB, ArgInfo("swapRB", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->setInputSwapRB(swapRB), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_Model_setPreferableBackend(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::Model * self1 = 0;
    if (!evision_dnn_Model_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::dnn::Model` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::Model* _self_ = (self1);
    std::underlying_type_t<dnn_Backend> backendId=static_cast<std::underlying_type_t<dnn_Backend>>(static_cast<dnn_Backend>(0));
    Model retval;

    // const char* keywords[] = { "backendId", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "backendId"), backendId, ArgInfo("backendId", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->setPreferableBackend(static_cast<dnn_Backend>(backendId)), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_Model_setPreferableTarget(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::Model * self1 = 0;
    if (!evision_dnn_Model_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::dnn::Model` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::Model* _self_ = (self1);
    std::underlying_type_t<dnn_Target> targetId=static_cast<std::underlying_type_t<dnn_Target>>(static_cast<dnn_Target>(0));
    Model retval;

    // const char* keywords[] = { "targetId", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "targetId"), targetId, ArgInfo("targetId", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->setPreferableTarget(static_cast<dnn_Target>(targetId)), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (dnn_Model)

template<>
struct Evision_Converter< cv::dnn::Model >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const cv::dnn::Model& r)
    {
        return evision_dnn_Model_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, cv::dnn::Model& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        cv::dnn::Model * dst_ = nullptr;
        if (evision_dnn_Model_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected cv::dnn::Model for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// dnn_Net (Generic)
//================================================================================

// GetSet (dnn_Net)



// Methods (dnn_Net)

static ERL_NIF_TERM evision_cv_dnn_dnn_Net_Net(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        evision_res<cv::dnn::Net> * self = nullptr;
        alloc_resource(&self);
        if(self) ERRWRAP2(new (&(self->val)) cv::dnn::Net(), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<cv::dnn::Net>(env, self->val, ret, "DNN.Net", success);;
        }
    }

    return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_Net_connect(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::Net self1;
    const ArgInfo selfArg("self", false);
    if (!evision_to_safe(env, self, self1, selfArg)) {
        return failmsgp(env, "cannot get `cv::dnn::Net` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::Net* _self_ = &self1;
    String outPin;
    String inpPin;

    // const char* keywords[] = { "outPin", "inpPin", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "outPin"), outPin, ArgInfo("outPin", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "inpPin"), inpPin, ArgInfo("inpPin", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->connect(outPin, inpPin), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "DNN.Net", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_Net_dump(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::Net self1;
    const ArgInfo selfArg("self", false);
    if (!evision_to_safe(env, self, self1, selfArg)) {
        return failmsgp(env, "cannot get `cv::dnn::Net` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::Net* _self_ = &self1;
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->dump(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_Net_dumpToFile(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::Net self1;
    const ArgInfo selfArg("self", false);
    if (!evision_to_safe(env, self, self1, selfArg)) {
        return failmsgp(env, "cannot get `cv::dnn::Net` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::Net* _self_ = &self1;
    String path;

    // const char* keywords[] = { "path", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "path"), path, ArgInfo("path", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->dumpToFile(path), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "DNN.Net", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_Net_empty(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::Net self1;
    const ArgInfo selfArg("self", false);
    if (!evision_to_safe(env, self, self1, selfArg)) {
        return failmsgp(env, "cannot get `cv::dnn::Net` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::Net* _self_ = &self1;
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->empty(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_Net_enableFusion(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::Net self1;
    const ArgInfo selfArg("self", false);
    if (!evision_to_safe(env, self, self1, selfArg)) {
        return failmsgp(env, "cannot get `cv::dnn::Net` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::Net* _self_ = &self1;
    bool fusion=0;

    // const char* keywords[] = { "fusion", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fusion"), fusion, ArgInfo("fusion", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->enableFusion(fusion), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "DNN.Net", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_Net_forward(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::Net self1;
    const ArgInfo selfArg("self", false);
    if (!evision_to_safe(env, self, self1, selfArg)) {
        return failmsgp(env, "cannot get `cv::dnn::Net` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::Net* _self_ = &self1;

    {
    String outputName;
    Mat retval;

    // const char* keywords[] = { "outputName", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "outputName"), outputName, ArgInfo("outputName", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->forward(outputName), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    vector_Mat outputBlobs;
    String outputName;

    // const char* keywords[] = { "outputBlobs", "outputName", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "outputBlobs"), outputBlobs, ArgInfo("outputBlobs", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "outputName"), outputName, ArgInfo("outputName", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->forward(outputBlobs, outputName), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, outputBlobs);
        }
    }

    }
    

    {
    vector_UMat outputBlobs;
    String outputName;

    // const char* keywords[] = { "outputBlobs", "outputName", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "outputBlobs"), outputBlobs, ArgInfo("outputBlobs", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "outputName"), outputName, ArgInfo("outputName", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->forward(outputBlobs, outputName), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, outputBlobs);
        }
    }

    }
    

    {
    vector_Mat outputBlobs;
    vector_String outBlobNames;

    // const char* keywords[] = { "outBlobNames", "outputBlobs", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "outputBlobs"), outputBlobs, ArgInfo("outputBlobs", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "outBlobNames"), outBlobNames, ArgInfo("outBlobNames", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->forward(outputBlobs, outBlobNames), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, outputBlobs);
        }
    }

    }
    

    {
    vector_UMat outputBlobs;
    vector_String outBlobNames;

    // const char* keywords[] = { "outBlobNames", "outputBlobs", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "outputBlobs"), outputBlobs, ArgInfo("outputBlobs", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "outBlobNames"), outBlobNames, ArgInfo("outBlobNames", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->forward(outputBlobs, outBlobNames), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, outputBlobs);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_Net_forwardAndRetrieve(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::Net self1;
    const ArgInfo selfArg("self", false);
    if (!evision_to_safe(env, self, self1, selfArg)) {
        return failmsgp(env, "cannot get `cv::dnn::Net` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::Net* _self_ = &self1;
    vector_vector_Mat outputBlobs;
    vector_String outBlobNames;

    // const char* keywords[] = { "outBlobNames", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "outBlobNames"), outBlobNames, ArgInfo("outBlobNames", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->forward(outputBlobs, outBlobNames), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, outputBlobs);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_Net_forwardAsync(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::Net self1;
    const ArgInfo selfArg("self", false);
    if (!evision_to_safe(env, self, self1, selfArg)) {
        return failmsgp(env, "cannot get `cv::dnn::Net` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::Net* _self_ = &self1;
    String outputName;
    AsyncArray retval;

    // const char* keywords[] = { "outputName", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "outputName"), outputName, ArgInfo("outputName", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->forwardAsync(outputName), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_Net_getFLOPS(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::Net self1;
    const ArgInfo selfArg("self", false);
    if (!evision_to_safe(env, self, self1, selfArg)) {
        return failmsgp(env, "cannot get `cv::dnn::Net` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::Net* _self_ = &self1;

    {
    vector_MatShape netInputShapes;
    int64 retval;

    // const char* keywords[] = { "netInputShapes", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "netInputShapes"), netInputShapes, ArgInfo("netInputShapes", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getFLOPS(netInputShapes), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    MatShape netInputShape;
    int64 retval;

    // const char* keywords[] = { "netInputShape", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "netInputShape"), netInputShape, ArgInfo("netInputShape", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getFLOPS(netInputShape), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    int layerId=0;
    vector_MatShape netInputShapes;
    int64 retval;

    // const char* keywords[] = { "layerId", "netInputShapes", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "layerId"), layerId, ArgInfo("layerId", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "netInputShapes"), netInputShapes, ArgInfo("netInputShapes", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getFLOPS(layerId, netInputShapes), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    int layerId=0;
    MatShape netInputShape;
    int64 retval;

    // const char* keywords[] = { "layerId", "netInputShape", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "layerId"), layerId, ArgInfo("layerId", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "netInputShape"), netInputShape, ArgInfo("netInputShape", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getFLOPS(layerId, netInputShape), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_Net_getInputDetails(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::Net self1;
    const ArgInfo selfArg("self", false);
    if (!evision_to_safe(env, self, self1, selfArg)) {
        return failmsgp(env, "cannot get `cv::dnn::Net` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::Net* _self_ = &self1;
    vector_float scales;
    vector_int zeropoints;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->getInputDetails(scales, zeropoints), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, scales), evision_from(env, zeropoints));
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_Net_getLayer(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::Net self1;
    const ArgInfo selfArg("self", false);
    if (!evision_to_safe(env, self, self1, selfArg)) {
        return failmsgp(env, "cannot get `cv::dnn::Net` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::Net* _self_ = &self1;

    {
    int layerId=0;
    Ptr<Layer> retval;

    // const char* keywords[] = { "layerId", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "layerId"), layerId, ArgInfo("layerId", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getLayer(layerId), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    String layerName;
    Ptr<Layer> retval;

    // const char* keywords[] = { "layerName", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "layerName"), layerName, ArgInfo("layerName", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getLayer(layerName), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    LayerId layerId;
    Ptr<Layer> retval;

    // const char* keywords[] = { "layerId", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "layerId"), layerId, ArgInfo("layerId", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getLayer(layerId), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_Net_getLayerId(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::Net self1;
    const ArgInfo selfArg("self", false);
    if (!evision_to_safe(env, self, self1, selfArg)) {
        return failmsgp(env, "cannot get `cv::dnn::Net` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::Net* _self_ = &self1;
    String layer;
    int retval;

    // const char* keywords[] = { "layer", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "layer"), layer, ArgInfo("layer", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getLayerId(layer), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_Net_getLayerNames(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::Net self1;
    const ArgInfo selfArg("self", false);
    if (!evision_to_safe(env, self, self1, selfArg)) {
        return failmsgp(env, "cannot get `cv::dnn::Net` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::Net* _self_ = &self1;
    std::vector<String> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getLayerNames(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_Net_getLayerShapes(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::Net self1;
    const ArgInfo selfArg("self", false);
    if (!evision_to_safe(env, self, self1, selfArg)) {
        return failmsgp(env, "cannot get `cv::dnn::Net` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::Net* _self_ = &self1;

    {
    MatShape netInputShape;
    int layerId=0;
    vector_MatShape inLayerShapes;
    vector_MatShape outLayerShapes;

    // const char* keywords[] = { "netInputShape", "layerId", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "netInputShape"), netInputShape, ArgInfo("netInputShape", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "layerId"), layerId, ArgInfo("layerId", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->getLayerShapes(netInputShape, layerId, inLayerShapes, outLayerShapes), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, inLayerShapes), evision_from(env, outLayerShapes));
        }
    }

    }
    

    {
    vector_MatShape netInputShapes;
    int layerId=0;
    vector_MatShape inLayerShapes;
    vector_MatShape outLayerShapes;

    // const char* keywords[] = { "netInputShapes", "layerId", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "netInputShapes"), netInputShapes, ArgInfo("netInputShapes", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "layerId"), layerId, ArgInfo("layerId", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->getLayerShapes(netInputShapes, layerId, inLayerShapes, outLayerShapes), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, inLayerShapes), evision_from(env, outLayerShapes));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_Net_getLayerTypes(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::Net self1;
    const ArgInfo selfArg("self", false);
    if (!evision_to_safe(env, self, self1, selfArg)) {
        return failmsgp(env, "cannot get `cv::dnn::Net` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::Net* _self_ = &self1;
    vector_String layersTypes;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->getLayerTypes(layersTypes), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, layersTypes);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_Net_getLayersCount(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::Net self1;
    const ArgInfo selfArg("self", false);
    if (!evision_to_safe(env, self, self1, selfArg)) {
        return failmsgp(env, "cannot get `cv::dnn::Net` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::Net* _self_ = &self1;
    String layerType;
    int retval;

    // const char* keywords[] = { "layerType", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "layerType"), layerType, ArgInfo("layerType", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getLayersCount(layerType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_Net_getLayersShapes(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::Net self1;
    const ArgInfo selfArg("self", false);
    if (!evision_to_safe(env, self, self1, selfArg)) {
        return failmsgp(env, "cannot get `cv::dnn::Net` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::Net* _self_ = &self1;

    {
    vector_MatShape netInputShapes;
    vector_int layersIds;
    vector_vector_MatShape inLayersShapes;
    vector_vector_MatShape outLayersShapes;

    // const char* keywords[] = { "netInputShapes", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "netInputShapes"), netInputShapes, ArgInfo("netInputShapes", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->getLayersShapes(netInputShapes, layersIds, inLayersShapes, outLayersShapes), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, layersIds), evision_from(env, inLayersShapes), evision_from(env, outLayersShapes));
        }
    }

    }
    

    {
    MatShape netInputShape;
    vector_int layersIds;
    vector_vector_MatShape inLayersShapes;
    vector_vector_MatShape outLayersShapes;

    // const char* keywords[] = { "netInputShape", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "netInputShape"), netInputShape, ArgInfo("netInputShape", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->getLayersShapes(netInputShape, layersIds, inLayersShapes, outLayersShapes), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, layersIds), evision_from(env, inLayersShapes), evision_from(env, outLayersShapes));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_Net_getMemoryConsumption(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::Net self1;
    const ArgInfo selfArg("self", false);
    if (!evision_to_safe(env, self, self1, selfArg)) {
        return failmsgp(env, "cannot get `cv::dnn::Net` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::Net* _self_ = &self1;

    {
    MatShape netInputShape;
    size_t weights;
    size_t blobs;

    // const char* keywords[] = { "netInputShape", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "netInputShape"), netInputShape, ArgInfo("netInputShape", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->getMemoryConsumption(netInputShape, weights, blobs), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, weights), evision_from(env, blobs));
        }
    }

    }
    

    {
    int layerId=0;
    vector_MatShape netInputShapes;
    size_t weights;
    size_t blobs;

    // const char* keywords[] = { "layerId", "netInputShapes", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "layerId"), layerId, ArgInfo("layerId", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "netInputShapes"), netInputShapes, ArgInfo("netInputShapes", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->getMemoryConsumption(layerId, netInputShapes, weights, blobs), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, weights), evision_from(env, blobs));
        }
    }

    }
    

    {
    int layerId=0;
    MatShape netInputShape;
    size_t weights;
    size_t blobs;

    // const char* keywords[] = { "layerId", "netInputShape", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "layerId"), layerId, ArgInfo("layerId", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "netInputShape"), netInputShape, ArgInfo("netInputShape", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->getMemoryConsumption(layerId, netInputShape, weights, blobs), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, weights), evision_from(env, blobs));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_Net_getOutputDetails(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::Net self1;
    const ArgInfo selfArg("self", false);
    if (!evision_to_safe(env, self, self1, selfArg)) {
        return failmsgp(env, "cannot get `cv::dnn::Net` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::Net* _self_ = &self1;
    vector_float scales;
    vector_int zeropoints;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->getOutputDetails(scales, zeropoints), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, scales), evision_from(env, zeropoints));
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_Net_getParam(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::Net self1;
    const ArgInfo selfArg("self", false);
    if (!evision_to_safe(env, self, self1, selfArg)) {
        return failmsgp(env, "cannot get `cv::dnn::Net` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::Net* _self_ = &self1;

    {
    int layer=0;
    int numParam=0;
    Mat retval;

    // const char* keywords[] = { "layer", "numParam", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "layer"), layer, ArgInfo("layer", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "numParam"), numParam, ArgInfo("numParam", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getParam(layer, numParam), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    String layerName;
    int numParam=0;
    Mat retval;

    // const char* keywords[] = { "layerName", "numParam", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "layerName"), layerName, ArgInfo("layerName", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "numParam"), numParam, ArgInfo("numParam", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getParam(layerName, numParam), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_Net_getPerfProfile(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::Net self1;
    const ArgInfo selfArg("self", false);
    if (!evision_to_safe(env, self, self1, selfArg)) {
        return failmsgp(env, "cannot get `cv::dnn::Net` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::Net* _self_ = &self1;
    vector_double timings;
    int64 retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getPerfProfile(timings), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, timings));
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_Net_getUnconnectedOutLayers(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::Net self1;
    const ArgInfo selfArg("self", false);
    if (!evision_to_safe(env, self, self1, selfArg)) {
        return failmsgp(env, "cannot get `cv::dnn::Net` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::Net* _self_ = &self1;
    std::vector<int> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getUnconnectedOutLayers(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_Net_getUnconnectedOutLayersNames(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::Net self1;
    const ArgInfo selfArg("self", false);
    if (!evision_to_safe(env, self, self1, selfArg)) {
        return failmsgp(env, "cannot get `cv::dnn::Net` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::Net* _self_ = &self1;
    std::vector<String> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getUnconnectedOutLayersNames(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_Net_quantize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::Net self1;
    const ArgInfo selfArg("self", false);
    if (!evision_to_safe(env, self, self1, selfArg)) {
        return failmsgp(env, "cannot get `cv::dnn::Net` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::Net* _self_ = &self1;

    {
    vector_Mat calibData;
    int inputsDtype=0;
    int outputsDtype=0;
    Net retval;

    // const char* keywords[] = { "calibData", "inputsDtype", "outputsDtype", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "calibData"), calibData, ArgInfo("calibData", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "inputsDtype"), inputsDtype, ArgInfo("inputsDtype", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "outputsDtype"), outputsDtype, ArgInfo("outputsDtype", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->quantize(calibData, inputsDtype, outputsDtype), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    vector_UMat calibData;
    int inputsDtype=0;
    int outputsDtype=0;
    Net retval;

    // const char* keywords[] = { "calibData", "inputsDtype", "outputsDtype", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "calibData"), calibData, ArgInfo("calibData", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "inputsDtype"), inputsDtype, ArgInfo("inputsDtype", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "outputsDtype"), outputsDtype, ArgInfo("outputsDtype", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->quantize(calibData, inputsDtype, outputsDtype), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_Net_readFromModelOptimizer_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    {
    String xml;
    String bin;
    Net retval;

    // const char* keywords[] = { "xml", "bin", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "xml"), xml, ArgInfo("xml", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "bin"), bin, ArgInfo("bin", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::dnn::Net::readFromModelOptimizer(xml, bin), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    vector_uchar bufferModelConfig;
    vector_uchar bufferWeights;
    Net retval;

    // const char* keywords[] = { "bufferModelConfig", "bufferWeights", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "bufferModelConfig"), bufferModelConfig, ArgInfo("bufferModelConfig", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "bufferWeights"), bufferWeights, ArgInfo("bufferWeights", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::dnn::Net::readFromModelOptimizer(bufferModelConfig, bufferWeights), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_Net_setHalideScheduler(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::Net self1;
    const ArgInfo selfArg("self", false);
    if (!evision_to_safe(env, self, self1, selfArg)) {
        return failmsgp(env, "cannot get `cv::dnn::Net` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::Net* _self_ = &self1;
    String scheduler;

    // const char* keywords[] = { "scheduler", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "scheduler"), scheduler, ArgInfo("scheduler", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setHalideScheduler(scheduler), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "DNN.Net", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_Net_setInput(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::Net self1;
    const ArgInfo selfArg("self", false);
    if (!evision_to_safe(env, self, self1, selfArg)) {
        return failmsgp(env, "cannot get `cv::dnn::Net` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::Net* _self_ = &self1;

    {
    Mat blob;
    String name="";
    double scalefactor=1.0;
    Scalar mean;

    // const char* keywords[] = { "blob", "name", "scalefactor", "mean", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "blob"), blob, ArgInfo("blob", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "name"), name, ArgInfo("name", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scalefactor"), scalefactor, ArgInfo("scalefactor", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mean"), mean, ArgInfo("mean", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setInput(blob, name, scalefactor, mean), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "DNN.Net", success);
        }
    }

    }
    

    {
    UMat blob;
    String name="";
    double scalefactor=1.0;
    Scalar mean;

    // const char* keywords[] = { "blob", "name", "scalefactor", "mean", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "blob"), blob, ArgInfo("blob", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "name"), name, ArgInfo("name", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scalefactor"), scalefactor, ArgInfo("scalefactor", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mean"), mean, ArgInfo("mean", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setInput(blob, name, scalefactor, mean), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "DNN.Net", success);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_Net_setInputShape(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::Net self1;
    const ArgInfo selfArg("self", false);
    if (!evision_to_safe(env, self, self1, selfArg)) {
        return failmsgp(env, "cannot get `cv::dnn::Net` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::Net* _self_ = &self1;
    String inputName;
    MatShape shape;

    // const char* keywords[] = { "inputName", "shape", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "inputName"), inputName, ArgInfo("inputName", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "shape"), shape, ArgInfo("shape", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setInputShape(inputName, shape), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "DNN.Net", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_Net_setInputsNames(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::Net self1;
    const ArgInfo selfArg("self", false);
    if (!evision_to_safe(env, self, self1, selfArg)) {
        return failmsgp(env, "cannot get `cv::dnn::Net` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::Net* _self_ = &self1;
    vector_String inputBlobNames;

    // const char* keywords[] = { "inputBlobNames", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "inputBlobNames"), inputBlobNames, ArgInfo("inputBlobNames", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setInputsNames(inputBlobNames), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "DNN.Net", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_Net_setParam(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::Net self1;
    const ArgInfo selfArg("self", false);
    if (!evision_to_safe(env, self, self1, selfArg)) {
        return failmsgp(env, "cannot get `cv::dnn::Net` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::Net* _self_ = &self1;

    {
    int layer=0;
    int numParam=0;
    Mat blob;

    // const char* keywords[] = { "layer", "numParam", "blob", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "layer"), layer, ArgInfo("layer", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "numParam"), numParam, ArgInfo("numParam", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "blob"), blob, ArgInfo("blob", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setParam(layer, numParam, blob), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "DNN.Net", success);
        }
    }

    }
    

    {
    String layerName;
    int numParam=0;
    Mat blob;

    // const char* keywords[] = { "layerName", "numParam", "blob", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "layerName"), layerName, ArgInfo("layerName", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "numParam"), numParam, ArgInfo("numParam", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "blob"), blob, ArgInfo("blob", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setParam(layerName, numParam, blob), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "DNN.Net", success);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_Net_setPreferableBackend(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::Net self1;
    const ArgInfo selfArg("self", false);
    if (!evision_to_safe(env, self, self1, selfArg)) {
        return failmsgp(env, "cannot get `cv::dnn::Net` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::Net* _self_ = &self1;
    int backendId=0;

    // const char* keywords[] = { "backendId", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "backendId"), backendId, ArgInfo("backendId", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setPreferableBackend(backendId), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "DNN.Net", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_Net_setPreferableTarget(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::Net self1;
    const ArgInfo selfArg("self", false);
    if (!evision_to_safe(env, self, self1, selfArg)) {
        return failmsgp(env, "cannot get `cv::dnn::Net` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::Net* _self_ = &self1;
    int targetId=0;

    // const char* keywords[] = { "targetId", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "targetId"), targetId, ArgInfo("targetId", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setPreferableTarget(targetId), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "DNN.Net", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (dnn_Net)

template<>
struct Evision_Converter< cv::dnn::Net >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const cv::dnn::Net& r)
    {
        return evision_dnn_Net_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, cv::dnn::Net& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        cv::dnn::Net * dst_ = nullptr;
        if (evision_dnn_Net_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected cv::dnn::Net for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// dnn_SegmentationModel (Generic)
//================================================================================

// GetSet (dnn_SegmentationModel)



// Methods (dnn_SegmentationModel)

static ERL_NIF_TERM evision_cv_dnn_dnn_SegmentationModel_SegmentationModel(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    {
    String model;
    String config="";

    // const char* keywords[] = { "model", "config", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "model"), model, ArgInfo("model", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "config"), config, ArgInfo("config", 0)) )
    {
        int error_flag = false;
        evision_res<cv::dnn::SegmentationModel> * self = nullptr;
        alloc_resource(&self);
        if(self) ERRWRAP2(new (&(self->val)) cv::dnn::SegmentationModel(model, config), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<cv::dnn::SegmentationModel>(env, self->val, ret, "DNN.SegmentationModel", success);;
        }
    }

    }
    

    {
    Net network;

    // const char* keywords[] = { "network", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "network"), network, ArgInfo("network", 0)) )
    {
        int error_flag = false;
        evision_res<cv::dnn::SegmentationModel> * self = nullptr;
        alloc_resource(&self);
        if(self) ERRWRAP2(new (&(self->val)) cv::dnn::SegmentationModel(network), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<cv::dnn::SegmentationModel>(env, self->val, ret, "DNN.SegmentationModel", success);;
        }
    }

    }

    return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_SegmentationModel_segment(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::SegmentationModel * self1 = 0;
    if (!evision_dnn_SegmentationModel_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::dnn::SegmentationModel` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::SegmentationModel* _self_ = (self1);

    {
    Mat frame;
    Mat mask;

    // const char* keywords[] = { "frame", "mask", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "frame"), frame, ArgInfo("frame", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->segment(frame, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, mask);
        }
    }

    }
    

    {
    UMat frame;
    UMat mask;

    // const char* keywords[] = { "frame", "mask", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "frame"), frame, ArgInfo("frame", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->segment(frame, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, mask);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (dnn_SegmentationModel)

template<>
struct Evision_Converter< cv::dnn::SegmentationModel >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const cv::dnn::SegmentationModel& r)
    {
        return evision_dnn_SegmentationModel_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, cv::dnn::SegmentationModel& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        cv::dnn::SegmentationModel * dst_ = nullptr;
        if (evision_dnn_SegmentationModel_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected cv::dnn::SegmentationModel for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// dnn_TextDetectionModel (Generic)
//================================================================================

// GetSet (dnn_TextDetectionModel)



// Methods (dnn_TextDetectionModel)

static ERL_NIF_TERM evision_cv_dnn_dnn_TextDetectionModel_detect(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::TextDetectionModel * self1 = 0;
    if (!evision_dnn_TextDetectionModel_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::dnn::TextDetectionModel` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::TextDetectionModel* _self_ = (self1);

    {
    Mat frame;
    vector_vector_Point detections;
    vector_float confidences;

    // const char* keywords[] = { "frame", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "frame"), frame, ArgInfo("frame", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(frame, detections, confidences), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, detections), evision_from(env, confidences));
        }
    }

    }
    

    {
    UMat frame;
    vector_vector_Point detections;
    vector_float confidences;

    // const char* keywords[] = { "frame", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "frame"), frame, ArgInfo("frame", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(frame, detections, confidences), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, detections), evision_from(env, confidences));
        }
    }

    }
    

    {
    Mat frame;
    vector_vector_Point detections;

    // const char* keywords[] = { "frame", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "frame"), frame, ArgInfo("frame", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(frame, detections), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, detections);
        }
    }

    }
    

    {
    UMat frame;
    vector_vector_Point detections;

    // const char* keywords[] = { "frame", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "frame"), frame, ArgInfo("frame", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detect(frame, detections), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, detections);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_TextDetectionModel_detectTextRectangles(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::TextDetectionModel * self1 = 0;
    if (!evision_dnn_TextDetectionModel_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::dnn::TextDetectionModel` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::TextDetectionModel* _self_ = (self1);

    {
    Mat frame;
    vector_RotatedRect detections;
    vector_float confidences;

    // const char* keywords[] = { "frame", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "frame"), frame, ArgInfo("frame", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detectTextRectangles(frame, detections, confidences), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, detections), evision_from(env, confidences));
        }
    }

    }
    

    {
    UMat frame;
    vector_RotatedRect detections;
    vector_float confidences;

    // const char* keywords[] = { "frame", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "frame"), frame, ArgInfo("frame", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detectTextRectangles(frame, detections, confidences), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, detections), evision_from(env, confidences));
        }
    }

    }
    

    {
    Mat frame;
    vector_RotatedRect detections;

    // const char* keywords[] = { "frame", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "frame"), frame, ArgInfo("frame", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detectTextRectangles(frame, detections), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, detections);
        }
    }

    }
    

    {
    UMat frame;
    vector_RotatedRect detections;

    // const char* keywords[] = { "frame", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "frame"), frame, ArgInfo("frame", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->detectTextRectangles(frame, detections), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, detections);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (dnn_TextDetectionModel)

template<>
struct Evision_Converter< cv::dnn::TextDetectionModel >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const cv::dnn::TextDetectionModel& r)
    {
        return evision_dnn_TextDetectionModel_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, cv::dnn::TextDetectionModel& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        cv::dnn::TextDetectionModel * dst_ = nullptr;
        if (evision_dnn_TextDetectionModel_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected cv::dnn::TextDetectionModel for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// dnn_TextDetectionModel_DB (Generic)
//================================================================================

// GetSet (dnn_TextDetectionModel_DB)



// Methods (dnn_TextDetectionModel_DB)

static ERL_NIF_TERM evision_cv_dnn_dnn_TextDetectionModel_DB_TextDetectionModel_DB(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    {
    Net network;

    // const char* keywords[] = { "network", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "network"), network, ArgInfo("network", 0)) )
    {
        int error_flag = false;
        evision_res<cv::dnn::TextDetectionModel_DB> * self = nullptr;
        alloc_resource(&self);
        if(self) ERRWRAP2(new (&(self->val)) cv::dnn::TextDetectionModel_DB(network), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<cv::dnn::TextDetectionModel_DB>(env, self->val, ret, "DNN.TextDetectionModelDB", success);;
        }
    }

    }
    

    {
    std::string model;
    std::string config="";

    // const char* keywords[] = { "model", "config", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "model"), model, ArgInfo("model", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "config"), config, ArgInfo("config", 0)) )
    {
        int error_flag = false;
        evision_res<cv::dnn::TextDetectionModel_DB> * self = nullptr;
        alloc_resource(&self);
        if(self) ERRWRAP2(new (&(self->val)) cv::dnn::TextDetectionModel_DB(model, config), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<cv::dnn::TextDetectionModel_DB>(env, self->val, ret, "DNN.TextDetectionModelDB", success);;
        }
    }

    }

    return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_TextDetectionModel_DB_getBinaryThreshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::TextDetectionModel_DB * self1 = 0;
    if (!evision_dnn_TextDetectionModel_DB_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::dnn::TextDetectionModel_DB` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::TextDetectionModel_DB* _self_ = (self1);
    float retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getBinaryThreshold(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_TextDetectionModel_DB_getMaxCandidates(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::TextDetectionModel_DB * self1 = 0;
    if (!evision_dnn_TextDetectionModel_DB_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::dnn::TextDetectionModel_DB` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::TextDetectionModel_DB* _self_ = (self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getMaxCandidates(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_TextDetectionModel_DB_getPolygonThreshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::TextDetectionModel_DB * self1 = 0;
    if (!evision_dnn_TextDetectionModel_DB_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::dnn::TextDetectionModel_DB` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::TextDetectionModel_DB* _self_ = (self1);
    float retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getPolygonThreshold(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_TextDetectionModel_DB_getUnclipRatio(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::TextDetectionModel_DB * self1 = 0;
    if (!evision_dnn_TextDetectionModel_DB_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::dnn::TextDetectionModel_DB` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::TextDetectionModel_DB* _self_ = (self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getUnclipRatio(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_TextDetectionModel_DB_setBinaryThreshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::TextDetectionModel_DB * self1 = 0;
    if (!evision_dnn_TextDetectionModel_DB_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::dnn::TextDetectionModel_DB` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::TextDetectionModel_DB* _self_ = (self1);
    float binaryThreshold=0.f;
    TextDetectionModel_DB retval;

    // const char* keywords[] = { "binaryThreshold", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "binaryThreshold"), binaryThreshold, ArgInfo("binaryThreshold", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->setBinaryThreshold(binaryThreshold), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_TextDetectionModel_DB_setMaxCandidates(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::TextDetectionModel_DB * self1 = 0;
    if (!evision_dnn_TextDetectionModel_DB_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::dnn::TextDetectionModel_DB` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::TextDetectionModel_DB* _self_ = (self1);
    int maxCandidates=0;
    TextDetectionModel_DB retval;

    // const char* keywords[] = { "maxCandidates", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "maxCandidates"), maxCandidates, ArgInfo("maxCandidates", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->setMaxCandidates(maxCandidates), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_TextDetectionModel_DB_setPolygonThreshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::TextDetectionModel_DB * self1 = 0;
    if (!evision_dnn_TextDetectionModel_DB_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::dnn::TextDetectionModel_DB` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::TextDetectionModel_DB* _self_ = (self1);
    float polygonThreshold=0.f;
    TextDetectionModel_DB retval;

    // const char* keywords[] = { "polygonThreshold", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "polygonThreshold"), polygonThreshold, ArgInfo("polygonThreshold", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->setPolygonThreshold(polygonThreshold), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_TextDetectionModel_DB_setUnclipRatio(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::TextDetectionModel_DB * self1 = 0;
    if (!evision_dnn_TextDetectionModel_DB_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::dnn::TextDetectionModel_DB` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::TextDetectionModel_DB* _self_ = (self1);
    double unclipRatio=0;
    TextDetectionModel_DB retval;

    // const char* keywords[] = { "unclipRatio", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "unclipRatio"), unclipRatio, ArgInfo("unclipRatio", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->setUnclipRatio(unclipRatio), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (dnn_TextDetectionModel_DB)

template<>
struct Evision_Converter< cv::dnn::TextDetectionModel_DB >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const cv::dnn::TextDetectionModel_DB& r)
    {
        return evision_dnn_TextDetectionModel_DB_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, cv::dnn::TextDetectionModel_DB& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        cv::dnn::TextDetectionModel_DB * dst_ = nullptr;
        if (evision_dnn_TextDetectionModel_DB_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected cv::dnn::TextDetectionModel_DB for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// dnn_TextDetectionModel_EAST (Generic)
//================================================================================

// GetSet (dnn_TextDetectionModel_EAST)



// Methods (dnn_TextDetectionModel_EAST)

static ERL_NIF_TERM evision_cv_dnn_dnn_TextDetectionModel_EAST_TextDetectionModel_EAST(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    {
    Net network;

    // const char* keywords[] = { "network", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "network"), network, ArgInfo("network", 0)) )
    {
        int error_flag = false;
        evision_res<cv::dnn::TextDetectionModel_EAST> * self = nullptr;
        alloc_resource(&self);
        if(self) ERRWRAP2(new (&(self->val)) cv::dnn::TextDetectionModel_EAST(network), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<cv::dnn::TextDetectionModel_EAST>(env, self->val, ret, "DNN.TextDetectionModelEAST", success);;
        }
    }

    }
    

    {
    std::string model;
    std::string config="";

    // const char* keywords[] = { "model", "config", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "model"), model, ArgInfo("model", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "config"), config, ArgInfo("config", 0)) )
    {
        int error_flag = false;
        evision_res<cv::dnn::TextDetectionModel_EAST> * self = nullptr;
        alloc_resource(&self);
        if(self) ERRWRAP2(new (&(self->val)) cv::dnn::TextDetectionModel_EAST(model, config), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<cv::dnn::TextDetectionModel_EAST>(env, self->val, ret, "DNN.TextDetectionModelEAST", success);;
        }
    }

    }

    return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_TextDetectionModel_EAST_getConfidenceThreshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::TextDetectionModel_EAST * self1 = 0;
    if (!evision_dnn_TextDetectionModel_EAST_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::dnn::TextDetectionModel_EAST` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::TextDetectionModel_EAST* _self_ = (self1);
    float retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getConfidenceThreshold(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_TextDetectionModel_EAST_getNMSThreshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::TextDetectionModel_EAST * self1 = 0;
    if (!evision_dnn_TextDetectionModel_EAST_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::dnn::TextDetectionModel_EAST` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::TextDetectionModel_EAST* _self_ = (self1);
    float retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getNMSThreshold(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_TextDetectionModel_EAST_setConfidenceThreshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::TextDetectionModel_EAST * self1 = 0;
    if (!evision_dnn_TextDetectionModel_EAST_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::dnn::TextDetectionModel_EAST` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::TextDetectionModel_EAST* _self_ = (self1);
    float confThreshold=0.f;
    TextDetectionModel_EAST retval;

    // const char* keywords[] = { "confThreshold", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "confThreshold"), confThreshold, ArgInfo("confThreshold", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->setConfidenceThreshold(confThreshold), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_TextDetectionModel_EAST_setNMSThreshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::TextDetectionModel_EAST * self1 = 0;
    if (!evision_dnn_TextDetectionModel_EAST_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::dnn::TextDetectionModel_EAST` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::TextDetectionModel_EAST* _self_ = (self1);
    float nmsThreshold=0.f;
    TextDetectionModel_EAST retval;

    // const char* keywords[] = { "nmsThreshold", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "nmsThreshold"), nmsThreshold, ArgInfo("nmsThreshold", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->setNMSThreshold(nmsThreshold), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (dnn_TextDetectionModel_EAST)

template<>
struct Evision_Converter< cv::dnn::TextDetectionModel_EAST >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const cv::dnn::TextDetectionModel_EAST& r)
    {
        return evision_dnn_TextDetectionModel_EAST_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, cv::dnn::TextDetectionModel_EAST& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        cv::dnn::TextDetectionModel_EAST * dst_ = nullptr;
        if (evision_dnn_TextDetectionModel_EAST_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected cv::dnn::TextDetectionModel_EAST for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// dnn_TextRecognitionModel (Generic)
//================================================================================

// GetSet (dnn_TextRecognitionModel)



// Methods (dnn_TextRecognitionModel)

static ERL_NIF_TERM evision_cv_dnn_dnn_TextRecognitionModel_TextRecognitionModel(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    {
    Net network;

    // const char* keywords[] = { "network", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "network"), network, ArgInfo("network", 0)) )
    {
        int error_flag = false;
        evision_res<cv::dnn::TextRecognitionModel> * self = nullptr;
        alloc_resource(&self);
        if(self) ERRWRAP2(new (&(self->val)) cv::dnn::TextRecognitionModel(network), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<cv::dnn::TextRecognitionModel>(env, self->val, ret, "DNN.TextRecognitionModel", success);;
        }
    }

    }
    

    {
    std::string model;
    std::string config="";

    // const char* keywords[] = { "model", "config", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "model"), model, ArgInfo("model", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "config"), config, ArgInfo("config", 0)) )
    {
        int error_flag = false;
        evision_res<cv::dnn::TextRecognitionModel> * self = nullptr;
        alloc_resource(&self);
        if(self) ERRWRAP2(new (&(self->val)) cv::dnn::TextRecognitionModel(model, config), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<cv::dnn::TextRecognitionModel>(env, self->val, ret, "DNN.TextRecognitionModel", success);;
        }
    }

    }

    return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_TextRecognitionModel_getDecodeType(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::TextRecognitionModel * self1 = 0;
    if (!evision_dnn_TextRecognitionModel_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::dnn::TextRecognitionModel` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::TextRecognitionModel* _self_ = (self1);
    std::string retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getDecodeType(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_TextRecognitionModel_getVocabulary(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::TextRecognitionModel * self1 = 0;
    if (!evision_dnn_TextRecognitionModel_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::dnn::TextRecognitionModel` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::TextRecognitionModel* _self_ = (self1);
    std::vector<std::string> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getVocabulary(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_TextRecognitionModel_recognize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::TextRecognitionModel * self1 = 0;
    if (!evision_dnn_TextRecognitionModel_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::dnn::TextRecognitionModel` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::TextRecognitionModel* _self_ = (self1);

    {
    Mat frame;
    std::string retval;

    // const char* keywords[] = { "frame", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "frame"), frame, ArgInfo("frame", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->recognize(frame), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    UMat frame;
    std::string retval;

    // const char* keywords[] = { "frame", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "frame"), frame, ArgInfo("frame", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->recognize(frame), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Mat frame;
    vector_Mat roiRects;
    vector_string results;

    // const char* keywords[] = { "frame", "roiRects", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "frame"), frame, ArgInfo("frame", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "roiRects"), roiRects, ArgInfo("roiRects", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->recognize(frame, roiRects, results), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, results);
        }
    }

    }
    

    {
    UMat frame;
    vector_UMat roiRects;
    vector_string results;

    // const char* keywords[] = { "frame", "roiRects", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "frame"), frame, ArgInfo("frame", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "roiRects"), roiRects, ArgInfo("roiRects", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->recognize(frame, roiRects, results), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, results);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_TextRecognitionModel_setDecodeOptsCTCPrefixBeamSearch(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::TextRecognitionModel * self1 = 0;
    if (!evision_dnn_TextRecognitionModel_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::dnn::TextRecognitionModel` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::TextRecognitionModel* _self_ = (self1);
    int beamSize=0;
    int vocPruneSize=0;
    TextRecognitionModel retval;

    // const char* keywords[] = { "beamSize", "vocPruneSize", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "beamSize"), beamSize, ArgInfo("beamSize", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "vocPruneSize"), vocPruneSize, ArgInfo("vocPruneSize", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->setDecodeOptsCTCPrefixBeamSearch(beamSize, vocPruneSize), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_TextRecognitionModel_setDecodeType(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::TextRecognitionModel * self1 = 0;
    if (!evision_dnn_TextRecognitionModel_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::dnn::TextRecognitionModel` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::TextRecognitionModel* _self_ = (self1);
    std::string decodeType;
    TextRecognitionModel retval;

    // const char* keywords[] = { "decodeType", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "decodeType"), decodeType, ArgInfo("decodeType", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->setDecodeType(decodeType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_dnn_TextRecognitionModel_setVocabulary(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::dnn::TextRecognitionModel * self1 = 0;
    if (!evision_dnn_TextRecognitionModel_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::dnn::TextRecognitionModel` from `self`: mismatched type or invalid resource?");
    }
    cv::dnn::TextRecognitionModel* _self_ = (self1);
    vector_string vocabulary;
    TextRecognitionModel retval;

    // const char* keywords[] = { "vocabulary", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "vocabulary"), vocabulary, ArgInfo("vocabulary", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->setVocabulary(vocabulary), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (dnn_TextRecognitionModel)

template<>
struct Evision_Converter< cv::dnn::TextRecognitionModel >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const cv::dnn::TextRecognitionModel& r)
    {
        return evision_dnn_TextRecognitionModel_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, cv::dnn::TextRecognitionModel& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        cv::dnn::TextRecognitionModel * dst_ = nullptr;
        if (evision_dnn_TextRecognitionModel_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected cv::dnn::TextRecognitionModel for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// flann_Index (Generic)
//================================================================================

// GetSet (flann_Index)



// Methods (flann_Index)

static ERL_NIF_TERM evision_cv_flann_flann_Index_Index(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::flann;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    {

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        evision_res<Ptr<cv::flann::Index>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::flann::Index>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::flann::Index()), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::flann::Index>>(env, self->val, ret, "Flann.Index", success);;
        }
    }

    }
    

    {
    Mat features;
    IndexParams params;
    cvflann_flann_distance_t distType=cvflann::FLANN_DIST_L2;

    // const char* keywords[] = { "features", "params", "distType", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "features"), features, ArgInfo("features", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "params"), params, ArgInfo("params", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distType"), distType, ArgInfo("distType", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::flann::Index>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::flann::Index>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::flann::Index(features, params, distType)), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::flann::Index>>(env, self->val, ret, "Flann.Index", success);;
        }
    }

    }
    

    {
    UMat features;
    IndexParams params;
    cvflann_flann_distance_t distType=cvflann::FLANN_DIST_L2;

    // const char* keywords[] = { "features", "params", "distType", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "features"), features, ArgInfo("features", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "params"), params, ArgInfo("params", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distType"), distType, ArgInfo("distType", 0)) )
    {
        int error_flag = false;
        evision_res<Ptr<cv::flann::Index>> * self = nullptr;
        if (alloc_resource(&self)) {
            new (&(self->val)) Ptr<cv::flann::Index>(); // init Ptr with placement new
        }
        if(self) ERRWRAP2(self->val.reset(new cv::flann::Index(features, params, distType)), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<Ptr<cv::flann::Index>>(env, self->val, ret, "Flann.Index", success);;
        }
    }

    }

    return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_flann_flann_Index_build(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::flann;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::flann::Index> * self1 = 0;
    if (!evision_flann_Index_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::flann::Index>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::flann::Index> _self_ = *(self1);

    {
    Mat features;
    IndexParams params;
    cvflann_flann_distance_t distType=cvflann::FLANN_DIST_L2;

    // const char* keywords[] = { "features", "params", "distType", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "features"), features, ArgInfo("features", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "params"), params, ArgInfo("params", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distType"), distType, ArgInfo("distType", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->build(features, params, distType), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Flann.Index", success);
        }
    }

    }
    

    {
    UMat features;
    IndexParams params;
    cvflann_flann_distance_t distType=cvflann::FLANN_DIST_L2;

    // const char* keywords[] = { "features", "params", "distType", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "features"), features, ArgInfo("features", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "params"), params, ArgInfo("params", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distType"), distType, ArgInfo("distType", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->build(features, params, distType), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Flann.Index", success);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_flann_flann_Index_getAlgorithm(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::flann;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::flann::Index> * self1 = 0;
    if (!evision_flann_Index_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::flann::Index>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::flann::Index> _self_ = *(self1);
    cvflann::flann_algorithm_t retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getAlgorithm(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_flann_flann_Index_getDistance(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::flann;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::flann::Index> * self1 = 0;
    if (!evision_flann_Index_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::flann::Index>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::flann::Index> _self_ = *(self1);
    cvflann::flann_distance_t retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getDistance(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_flann_flann_Index_knnSearch(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::flann;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::flann::Index> * self1 = 0;
    if (!evision_flann_Index_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::flann::Index>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::flann::Index> _self_ = *(self1);

    {
    Mat query;
    Mat indices;
    Mat dists;
    int knn=0;
    SearchParams params;

    // const char* keywords[] = { "query", "knn", "indices", "dists", "params", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "query"), query, ArgInfo("query", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "indices"), indices, ArgInfo("indices", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dists"), dists, ArgInfo("dists", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "knn"), knn, ArgInfo("knn", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "params"), params, ArgInfo("params", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->knnSearch(query, indices, dists, knn, params), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, indices), evision_from(env, dists));
        }
    }

    }
    

    {
    UMat query;
    UMat indices;
    UMat dists;
    int knn=0;
    SearchParams params;

    // const char* keywords[] = { "query", "knn", "indices", "dists", "params", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "query"), query, ArgInfo("query", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "indices"), indices, ArgInfo("indices", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dists"), dists, ArgInfo("dists", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "knn"), knn, ArgInfo("knn", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "params"), params, ArgInfo("params", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->knnSearch(query, indices, dists, knn, params), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, indices), evision_from(env, dists));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_flann_flann_Index_load(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::flann;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::flann::Index> * self1 = 0;
    if (!evision_flann_Index_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::flann::Index>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::flann::Index> _self_ = *(self1);

    {
    Mat features;
    String filename;
    bool retval;

    // const char* keywords[] = { "features", "filename", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "features"), features, ArgInfo("features", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->load(features, filename), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    UMat features;
    String filename;
    bool retval;

    // const char* keywords[] = { "features", "filename", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "features"), features, ArgInfo("features", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->load(features, filename), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_flann_flann_Index_radiusSearch(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::flann;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::flann::Index> * self1 = 0;
    if (!evision_flann_Index_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::flann::Index>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::flann::Index> _self_ = *(self1);

    {
    Mat query;
    Mat indices;
    Mat dists;
    double radius=0;
    int maxResults=0;
    SearchParams params;
    int retval;

    // const char* keywords[] = { "query", "radius", "maxResults", "indices", "dists", "params", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "query"), query, ArgInfo("query", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "indices"), indices, ArgInfo("indices", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dists"), dists, ArgInfo("dists", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "radius"), radius, ArgInfo("radius", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxResults"), maxResults, ArgInfo("maxResults", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "params"), params, ArgInfo("params", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->radiusSearch(query, indices, dists, radius, maxResults, params), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, retval), evision_from(env, indices), evision_from(env, dists));
        }
    }

    }
    

    {
    UMat query;
    UMat indices;
    UMat dists;
    double radius=0;
    int maxResults=0;
    SearchParams params;
    int retval;

    // const char* keywords[] = { "query", "radius", "maxResults", "indices", "dists", "params", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "query"), query, ArgInfo("query", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "indices"), indices, ArgInfo("indices", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dists"), dists, ArgInfo("dists", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "radius"), radius, ArgInfo("radius", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxResults"), maxResults, ArgInfo("maxResults", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "params"), params, ArgInfo("params", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->radiusSearch(query, indices, dists, radius, maxResults, params), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, retval), evision_from(env, indices), evision_from(env, dists));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_flann_flann_Index_release(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::flann;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::flann::Index> * self1 = 0;
    if (!evision_flann_Index_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::flann::Index>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::flann::Index> _self_ = *(self1);

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->release(), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Flann.Index", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_flann_flann_Index_save(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::flann;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::flann::Index> * self1 = 0;
    if (!evision_flann_Index_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::flann::Index>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::flann::Index> _self_ = *(self1);
    String filename;

    // const char* keywords[] = { "filename", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->save(filename), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Flann.Index", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (flann_Index)

template<>
struct Evision_Converter< Ptr<cv::flann::Index> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::flann::Index>& r)
    {
        return evision_flann_Index_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::flann::Index>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::flann::Index> * dst_ = nullptr;
        if (evision_flann_Index_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::flann::Index> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// ml_ANN_MLP (Generic)
//================================================================================

// GetSet (ml_ANN_MLP)



// Methods (ml_ANN_MLP)

static ERL_NIF_TERM evision_cv_ml_ml_ANN_MLP_calcError(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!evision_ml_ANN_MLP_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::ANN_MLP>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);

    {
    Ptr<TrainData> data;
    bool test=0;
    Mat resp;
    float retval;

    // const char* keywords[] = { "data", "test", "resp", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "data"), data, ArgInfo("data", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "test"), test, ArgInfo("test", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "resp"), resp, ArgInfo("resp", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->calcError(data, test, resp), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, resp));
        }
    }

    }
    

    {
    Ptr<TrainData> data;
    bool test=0;
    UMat resp;
    float retval;

    // const char* keywords[] = { "data", "test", "resp", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "data"), data, ArgInfo("data", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "test"), test, ArgInfo("test", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "resp"), resp, ArgInfo("resp", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->calcError(data, test, resp), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, resp));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ANN_MLP_clear(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!evision_ml_ANN_MLP_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::ANN_MLP>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::clear(), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.ANNMLP", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_ANN_MLP_create_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    Ptr<ANN_MLP> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::ml::ANN_MLP::create(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_ANN_MLP_empty(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!evision_ml_ANN_MLP_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::ANN_MLP>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->empty(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_ANN_MLP_getAnnealCoolingRatio(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!evision_ml_ANN_MLP_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::ANN_MLP>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getAnnealCoolingRatio(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_ANN_MLP_getAnnealFinalT(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!evision_ml_ANN_MLP_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::ANN_MLP>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getAnnealFinalT(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_ANN_MLP_getAnnealInitialT(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!evision_ml_ANN_MLP_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::ANN_MLP>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getAnnealInitialT(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_ANN_MLP_getAnnealItePerStep(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!evision_ml_ANN_MLP_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::ANN_MLP>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getAnnealItePerStep(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_ANN_MLP_getBackpropMomentumScale(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!evision_ml_ANN_MLP_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::ANN_MLP>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getBackpropMomentumScale(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_ANN_MLP_getBackpropWeightScale(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!evision_ml_ANN_MLP_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::ANN_MLP>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getBackpropWeightScale(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ANN_MLP_getDefaultName(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!evision_ml_ANN_MLP_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::ANN_MLP>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->Algorithm::getDefaultName(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_ANN_MLP_getLayerSizes(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!evision_ml_ANN_MLP_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::ANN_MLP>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    cv::Mat retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getLayerSizes(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_ANN_MLP_getRpropDW0(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!evision_ml_ANN_MLP_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::ANN_MLP>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getRpropDW0(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_ANN_MLP_getRpropDWMax(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!evision_ml_ANN_MLP_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::ANN_MLP>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getRpropDWMax(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_ANN_MLP_getRpropDWMin(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!evision_ml_ANN_MLP_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::ANN_MLP>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getRpropDWMin(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_ANN_MLP_getRpropDWMinus(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!evision_ml_ANN_MLP_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::ANN_MLP>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getRpropDWMinus(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_ANN_MLP_getRpropDWPlus(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!evision_ml_ANN_MLP_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::ANN_MLP>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getRpropDWPlus(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_ANN_MLP_getTermCriteria(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!evision_ml_ANN_MLP_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::ANN_MLP>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    TermCriteria retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getTermCriteria(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_ANN_MLP_getTrainMethod(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!evision_ml_ANN_MLP_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::ANN_MLP>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getTrainMethod(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_ANN_MLP_getVarCount(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!evision_ml_ANN_MLP_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::ANN_MLP>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getVarCount(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_ANN_MLP_getWeights(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!evision_ml_ANN_MLP_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::ANN_MLP>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    int layerIdx=0;
    Mat retval;

    // const char* keywords[] = { "layerIdx", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "layerIdx"), layerIdx, ArgInfo("layerIdx", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getWeights(layerIdx), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_ANN_MLP_isClassifier(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!evision_ml_ANN_MLP_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::ANN_MLP>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->isClassifier(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_ANN_MLP_isTrained(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!evision_ml_ANN_MLP_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::ANN_MLP>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->isTrained(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_ANN_MLP_load_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    String filepath;
    Ptr<ANN_MLP> retval;

    // const char* keywords[] = { "filepath", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filepath"), filepath, ArgInfo("filepath", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::ml::ANN_MLP::load(filepath), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_ANN_MLP_predict(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!evision_ml_ANN_MLP_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::ANN_MLP>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);

    {
    Mat samples;
    Mat results;
    int flags=0;
    float retval;

    // const char* keywords[] = { "samples", "results", "flags", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "results"), results, ArgInfo("results", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->predict(samples, results, flags), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, results));
        }
    }

    }
    

    {
    UMat samples;
    UMat results;
    int flags=0;
    float retval;

    // const char* keywords[] = { "samples", "results", "flags", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "results"), results, ArgInfo("results", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->predict(samples, results, flags), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, results));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ANN_MLP_read(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!evision_ml_ANN_MLP_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::ANN_MLP>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    FileNode fn_;

    // const char* keywords[] = { "fn_", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fn_"), fn_, ArgInfo("fn_", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::read(fn_), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.ANNMLP", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ANN_MLP_save(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!evision_ml_ANN_MLP_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::ANN_MLP>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    String filename;

    // const char* keywords[] = { "filename", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::save(filename), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.ANNMLP", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_ANN_MLP_setActivationFunction(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!evision_ml_ANN_MLP_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::ANN_MLP>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    int type=0;
    double param1=0;
    double param2=0;

    // const char* keywords[] = { "type", "param1", "param2", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "type"), type, ArgInfo("type", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "param1"), param1, ArgInfo("param1", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "param2"), param2, ArgInfo("param2", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setActivationFunction(type, param1, param2), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.ANNMLP", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_ANN_MLP_setAnnealCoolingRatio(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!evision_ml_ANN_MLP_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::ANN_MLP>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    double val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setAnnealCoolingRatio(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.ANNMLP", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_ANN_MLP_setAnnealFinalT(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!evision_ml_ANN_MLP_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::ANN_MLP>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    double val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setAnnealFinalT(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.ANNMLP", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_ANN_MLP_setAnnealInitialT(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!evision_ml_ANN_MLP_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::ANN_MLP>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    double val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setAnnealInitialT(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.ANNMLP", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_ANN_MLP_setAnnealItePerStep(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!evision_ml_ANN_MLP_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::ANN_MLP>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    int val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setAnnealItePerStep(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.ANNMLP", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_ANN_MLP_setBackpropMomentumScale(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!evision_ml_ANN_MLP_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::ANN_MLP>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    double val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setBackpropMomentumScale(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.ANNMLP", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_ANN_MLP_setBackpropWeightScale(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!evision_ml_ANN_MLP_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::ANN_MLP>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    double val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setBackpropWeightScale(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.ANNMLP", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_ANN_MLP_setLayerSizes(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!evision_ml_ANN_MLP_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::ANN_MLP>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);

    {
    Mat _layer_sizes;

    // const char* keywords[] = { "_layer_sizes", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "layer_sizes"), _layer_sizes, ArgInfo("_layer_sizes", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setLayerSizes(_layer_sizes), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.ANNMLP", success);
        }
    }

    }
    

    {
    UMat _layer_sizes;

    // const char* keywords[] = { "_layer_sizes", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "layer_sizes"), _layer_sizes, ArgInfo("_layer_sizes", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setLayerSizes(_layer_sizes), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.ANNMLP", success);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_ANN_MLP_setRpropDW0(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!evision_ml_ANN_MLP_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::ANN_MLP>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    double val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setRpropDW0(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.ANNMLP", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_ANN_MLP_setRpropDWMax(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!evision_ml_ANN_MLP_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::ANN_MLP>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    double val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setRpropDWMax(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.ANNMLP", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_ANN_MLP_setRpropDWMin(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!evision_ml_ANN_MLP_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::ANN_MLP>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    double val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setRpropDWMin(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.ANNMLP", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_ANN_MLP_setRpropDWMinus(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!evision_ml_ANN_MLP_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::ANN_MLP>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    double val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setRpropDWMinus(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.ANNMLP", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_ANN_MLP_setRpropDWPlus(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!evision_ml_ANN_MLP_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::ANN_MLP>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    double val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setRpropDWPlus(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.ANNMLP", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_ANN_MLP_setTermCriteria(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!evision_ml_ANN_MLP_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::ANN_MLP>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    TermCriteria val;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setTermCriteria(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.ANNMLP", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_ANN_MLP_setTrainMethod(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!evision_ml_ANN_MLP_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::ANN_MLP>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    int method=0;
    double param1=0;
    double param2=0;

    // const char* keywords[] = { "method", "param1", "param2", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "method"), method, ArgInfo("method", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "param1"), param1, ArgInfo("param1", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "param2"), param2, ArgInfo("param2", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setTrainMethod(method, param1, param2), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.ANNMLP", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_ANN_MLP_train(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!evision_ml_ANN_MLP_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::ANN_MLP>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);

    {
    Ptr<TrainData> trainData;
    int flags=0;
    bool retval;

    // const char* keywords[] = { "trainData", "flags", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "trainData"), trainData, ArgInfo("trainData", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->train(trainData, flags), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    Mat samples;
    int layout=0;
    Mat responses;
    bool retval;

    // const char* keywords[] = { "samples", "layout", "responses", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "layout"), layout, ArgInfo("layout", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "responses"), responses, ArgInfo("responses", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->train(samples, layout, responses), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    UMat samples;
    int layout=0;
    UMat responses;
    bool retval;

    // const char* keywords[] = { "samples", "layout", "responses", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "layout"), layout, ArgInfo("layout", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "responses"), responses, ArgInfo("responses", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->train(samples, layout, responses), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ANN_MLP_write(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!evision_ml_ANN_MLP_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::ANN_MLP>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    Ptr<FileStorage> fs;
    String name;

    // const char* keywords[] = { "fs", "name", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fs"), fs, ArgInfo("fs", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "name"), name, ArgInfo("name", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::write(fs, name), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.ANNMLP", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (ml_ANN_MLP)

template<>
struct Evision_Converter< Ptr<cv::ml::ANN_MLP> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::ml::ANN_MLP>& r)
    {
        return evision_ml_ANN_MLP_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::ml::ANN_MLP>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::ml::ANN_MLP> * dst_ = nullptr;
        if (evision_ml_ANN_MLP_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::ml::ANN_MLP> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// ml_Boost (Generic)
//================================================================================

// GetSet (ml_Boost)



// Methods (ml_Boost)

static ERL_NIF_TERM evision_cv_ml_ml_Boost_calcError(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::Boost> * self1 = 0;
    if (!evision_ml_Boost_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::Boost>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::Boost> _self_ = *(self1);

    {
    Ptr<TrainData> data;
    bool test=0;
    Mat resp;
    float retval;

    // const char* keywords[] = { "data", "test", "resp", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "data"), data, ArgInfo("data", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "test"), test, ArgInfo("test", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "resp"), resp, ArgInfo("resp", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->calcError(data, test, resp), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, resp));
        }
    }

    }
    

    {
    Ptr<TrainData> data;
    bool test=0;
    UMat resp;
    float retval;

    // const char* keywords[] = { "data", "test", "resp", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "data"), data, ArgInfo("data", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "test"), test, ArgInfo("test", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "resp"), resp, ArgInfo("resp", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->calcError(data, test, resp), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, resp));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_Boost_clear(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::Boost> * self1 = 0;
    if (!evision_ml_Boost_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::Boost>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::Boost> _self_ = *(self1);

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::clear(), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.Boost", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_Boost_create_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    Ptr<Boost> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::ml::Boost::create(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_Boost_empty(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::Boost> * self1 = 0;
    if (!evision_ml_Boost_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::Boost>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::Boost> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->empty(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_Boost_getBoostType(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::Boost> * self1 = 0;
    if (!evision_ml_Boost_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::Boost>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::Boost> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getBoostType(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_Boost_getCVFolds(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::Boost> * self1 = 0;
    if (!evision_ml_Boost_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::Boost>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::Boost> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getCVFolds(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_Boost_getDefaultName(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::Boost> * self1 = 0;
    if (!evision_ml_Boost_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::Boost>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::Boost> _self_ = *(self1);
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->Algorithm::getDefaultName(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_Boost_getMaxCategories(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::Boost> * self1 = 0;
    if (!evision_ml_Boost_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::Boost>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::Boost> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getMaxCategories(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_Boost_getMaxDepth(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::Boost> * self1 = 0;
    if (!evision_ml_Boost_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::Boost>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::Boost> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getMaxDepth(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_Boost_getMinSampleCount(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::Boost> * self1 = 0;
    if (!evision_ml_Boost_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::Boost>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::Boost> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getMinSampleCount(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_Boost_getPriors(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::Boost> * self1 = 0;
    if (!evision_ml_Boost_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::Boost>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::Boost> _self_ = *(self1);
    cv::Mat retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getPriors(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_Boost_getRegressionAccuracy(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::Boost> * self1 = 0;
    if (!evision_ml_Boost_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::Boost>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::Boost> _self_ = *(self1);
    float retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getRegressionAccuracy(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_Boost_getTruncatePrunedTree(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::Boost> * self1 = 0;
    if (!evision_ml_Boost_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::Boost>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::Boost> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getTruncatePrunedTree(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_Boost_getUse1SERule(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::Boost> * self1 = 0;
    if (!evision_ml_Boost_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::Boost>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::Boost> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getUse1SERule(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_Boost_getUseSurrogates(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::Boost> * self1 = 0;
    if (!evision_ml_Boost_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::Boost>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::Boost> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getUseSurrogates(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_Boost_getVarCount(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::Boost> * self1 = 0;
    if (!evision_ml_Boost_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::Boost>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::Boost> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getVarCount(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_Boost_getWeakCount(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::Boost> * self1 = 0;
    if (!evision_ml_Boost_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::Boost>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::Boost> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getWeakCount(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_Boost_getWeightTrimRate(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::Boost> * self1 = 0;
    if (!evision_ml_Boost_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::Boost>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::Boost> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getWeightTrimRate(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_Boost_isClassifier(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::Boost> * self1 = 0;
    if (!evision_ml_Boost_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::Boost>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::Boost> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->isClassifier(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_Boost_isTrained(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::Boost> * self1 = 0;
    if (!evision_ml_Boost_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::Boost>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::Boost> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->isTrained(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_Boost_load_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    String filepath;
    String nodeName = String();
    Ptr<Boost> retval;

    // const char* keywords[] = { "filepath", "nodeName", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filepath"), filepath, ArgInfo("filepath", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nodeName"), nodeName, ArgInfo("nodeName", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::ml::Boost::load(filepath, nodeName), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_Boost_predict(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::Boost> * self1 = 0;
    if (!evision_ml_Boost_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::Boost>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::Boost> _self_ = *(self1);

    {
    Mat samples;
    Mat results;
    int flags=0;
    float retval;

    // const char* keywords[] = { "samples", "results", "flags", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "results"), results, ArgInfo("results", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->predict(samples, results, flags), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, results));
        }
    }

    }
    

    {
    UMat samples;
    UMat results;
    int flags=0;
    float retval;

    // const char* keywords[] = { "samples", "results", "flags", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "results"), results, ArgInfo("results", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->predict(samples, results, flags), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, results));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_Boost_read(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::Boost> * self1 = 0;
    if (!evision_ml_Boost_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::Boost>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::Boost> _self_ = *(self1);
    FileNode fn_;

    // const char* keywords[] = { "fn_", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fn_"), fn_, ArgInfo("fn_", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::read(fn_), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.Boost", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_Boost_save(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::Boost> * self1 = 0;
    if (!evision_ml_Boost_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::Boost>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::Boost> _self_ = *(self1);
    String filename;

    // const char* keywords[] = { "filename", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::save(filename), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.Boost", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_Boost_setBoostType(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::Boost> * self1 = 0;
    if (!evision_ml_Boost_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::Boost>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::Boost> _self_ = *(self1);
    int val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setBoostType(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.Boost", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_Boost_setCVFolds(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::Boost> * self1 = 0;
    if (!evision_ml_Boost_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::Boost>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::Boost> _self_ = *(self1);
    int val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setCVFolds(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.Boost", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_Boost_setMaxCategories(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::Boost> * self1 = 0;
    if (!evision_ml_Boost_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::Boost>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::Boost> _self_ = *(self1);
    int val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setMaxCategories(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.Boost", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_Boost_setMaxDepth(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::Boost> * self1 = 0;
    if (!evision_ml_Boost_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::Boost>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::Boost> _self_ = *(self1);
    int val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setMaxDepth(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.Boost", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_Boost_setMinSampleCount(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::Boost> * self1 = 0;
    if (!evision_ml_Boost_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::Boost>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::Boost> _self_ = *(self1);
    int val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setMinSampleCount(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.Boost", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_Boost_setPriors(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::Boost> * self1 = 0;
    if (!evision_ml_Boost_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::Boost>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::Boost> _self_ = *(self1);
    Mat val;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setPriors(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.Boost", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_Boost_setRegressionAccuracy(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::Boost> * self1 = 0;
    if (!evision_ml_Boost_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::Boost>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::Boost> _self_ = *(self1);
    float val=0.f;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setRegressionAccuracy(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.Boost", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_Boost_setTruncatePrunedTree(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::Boost> * self1 = 0;
    if (!evision_ml_Boost_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::Boost>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::Boost> _self_ = *(self1);
    bool val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setTruncatePrunedTree(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.Boost", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_Boost_setUse1SERule(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::Boost> * self1 = 0;
    if (!evision_ml_Boost_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::Boost>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::Boost> _self_ = *(self1);
    bool val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setUse1SERule(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.Boost", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_Boost_setUseSurrogates(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::Boost> * self1 = 0;
    if (!evision_ml_Boost_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::Boost>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::Boost> _self_ = *(self1);
    bool val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setUseSurrogates(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.Boost", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_Boost_setWeakCount(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::Boost> * self1 = 0;
    if (!evision_ml_Boost_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::Boost>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::Boost> _self_ = *(self1);
    int val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setWeakCount(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.Boost", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_Boost_setWeightTrimRate(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::Boost> * self1 = 0;
    if (!evision_ml_Boost_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::Boost>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::Boost> _self_ = *(self1);
    double val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setWeightTrimRate(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.Boost", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_Boost_train(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::Boost> * self1 = 0;
    if (!evision_ml_Boost_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::Boost>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::Boost> _self_ = *(self1);

    {
    Ptr<TrainData> trainData;
    int flags=0;
    bool retval;

    // const char* keywords[] = { "trainData", "flags", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "trainData"), trainData, ArgInfo("trainData", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->train(trainData, flags), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    Mat samples;
    int layout=0;
    Mat responses;
    bool retval;

    // const char* keywords[] = { "samples", "layout", "responses", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "layout"), layout, ArgInfo("layout", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "responses"), responses, ArgInfo("responses", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->train(samples, layout, responses), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    UMat samples;
    int layout=0;
    UMat responses;
    bool retval;

    // const char* keywords[] = { "samples", "layout", "responses", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "layout"), layout, ArgInfo("layout", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "responses"), responses, ArgInfo("responses", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->train(samples, layout, responses), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_Boost_write(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::Boost> * self1 = 0;
    if (!evision_ml_Boost_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::Boost>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::Boost> _self_ = *(self1);
    Ptr<FileStorage> fs;
    String name;

    // const char* keywords[] = { "fs", "name", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fs"), fs, ArgInfo("fs", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "name"), name, ArgInfo("name", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::write(fs, name), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.Boost", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (ml_Boost)

template<>
struct Evision_Converter< Ptr<cv::ml::Boost> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::ml::Boost>& r)
    {
        return evision_ml_Boost_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::ml::Boost>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::ml::Boost> * dst_ = nullptr;
        if (evision_ml_Boost_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::ml::Boost> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// ml_DTrees (Generic)
//================================================================================

// GetSet (ml_DTrees)



// Methods (ml_DTrees)

static ERL_NIF_TERM evision_cv_ml_ml_DTrees_calcError(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::DTrees> * self1 = 0;
    if (!evision_ml_DTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::DTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::DTrees> _self_ = *(self1);

    {
    Ptr<TrainData> data;
    bool test=0;
    Mat resp;
    float retval;

    // const char* keywords[] = { "data", "test", "resp", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "data"), data, ArgInfo("data", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "test"), test, ArgInfo("test", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "resp"), resp, ArgInfo("resp", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->calcError(data, test, resp), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, resp));
        }
    }

    }
    

    {
    Ptr<TrainData> data;
    bool test=0;
    UMat resp;
    float retval;

    // const char* keywords[] = { "data", "test", "resp", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "data"), data, ArgInfo("data", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "test"), test, ArgInfo("test", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "resp"), resp, ArgInfo("resp", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->calcError(data, test, resp), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, resp));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_DTrees_clear(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::DTrees> * self1 = 0;
    if (!evision_ml_DTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::DTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::DTrees> _self_ = *(self1);

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::clear(), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.DTrees", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_DTrees_create_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    Ptr<DTrees> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::ml::DTrees::create(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_DTrees_empty(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::DTrees> * self1 = 0;
    if (!evision_ml_DTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::DTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::DTrees> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->empty(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_DTrees_getCVFolds(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::DTrees> * self1 = 0;
    if (!evision_ml_DTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::DTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::DTrees> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getCVFolds(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_DTrees_getDefaultName(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::DTrees> * self1 = 0;
    if (!evision_ml_DTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::DTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::DTrees> _self_ = *(self1);
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->Algorithm::getDefaultName(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_DTrees_getMaxCategories(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::DTrees> * self1 = 0;
    if (!evision_ml_DTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::DTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::DTrees> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getMaxCategories(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_DTrees_getMaxDepth(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::DTrees> * self1 = 0;
    if (!evision_ml_DTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::DTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::DTrees> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getMaxDepth(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_DTrees_getMinSampleCount(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::DTrees> * self1 = 0;
    if (!evision_ml_DTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::DTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::DTrees> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getMinSampleCount(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_DTrees_getPriors(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::DTrees> * self1 = 0;
    if (!evision_ml_DTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::DTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::DTrees> _self_ = *(self1);
    cv::Mat retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getPriors(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_DTrees_getRegressionAccuracy(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::DTrees> * self1 = 0;
    if (!evision_ml_DTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::DTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::DTrees> _self_ = *(self1);
    float retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getRegressionAccuracy(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_DTrees_getTruncatePrunedTree(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::DTrees> * self1 = 0;
    if (!evision_ml_DTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::DTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::DTrees> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getTruncatePrunedTree(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_DTrees_getUse1SERule(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::DTrees> * self1 = 0;
    if (!evision_ml_DTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::DTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::DTrees> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getUse1SERule(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_DTrees_getUseSurrogates(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::DTrees> * self1 = 0;
    if (!evision_ml_DTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::DTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::DTrees> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getUseSurrogates(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_DTrees_getVarCount(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::DTrees> * self1 = 0;
    if (!evision_ml_DTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::DTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::DTrees> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getVarCount(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_DTrees_isClassifier(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::DTrees> * self1 = 0;
    if (!evision_ml_DTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::DTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::DTrees> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->isClassifier(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_DTrees_isTrained(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::DTrees> * self1 = 0;
    if (!evision_ml_DTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::DTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::DTrees> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->isTrained(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_DTrees_load_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    String filepath;
    String nodeName = String();
    Ptr<DTrees> retval;

    // const char* keywords[] = { "filepath", "nodeName", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filepath"), filepath, ArgInfo("filepath", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nodeName"), nodeName, ArgInfo("nodeName", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::ml::DTrees::load(filepath, nodeName), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_DTrees_predict(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::DTrees> * self1 = 0;
    if (!evision_ml_DTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::DTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::DTrees> _self_ = *(self1);

    {
    Mat samples;
    Mat results;
    int flags=0;
    float retval;

    // const char* keywords[] = { "samples", "results", "flags", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "results"), results, ArgInfo("results", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->predict(samples, results, flags), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, results));
        }
    }

    }
    

    {
    UMat samples;
    UMat results;
    int flags=0;
    float retval;

    // const char* keywords[] = { "samples", "results", "flags", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "results"), results, ArgInfo("results", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->predict(samples, results, flags), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, results));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_DTrees_read(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::DTrees> * self1 = 0;
    if (!evision_ml_DTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::DTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::DTrees> _self_ = *(self1);
    FileNode fn_;

    // const char* keywords[] = { "fn_", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fn_"), fn_, ArgInfo("fn_", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::read(fn_), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.DTrees", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_DTrees_save(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::DTrees> * self1 = 0;
    if (!evision_ml_DTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::DTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::DTrees> _self_ = *(self1);
    String filename;

    // const char* keywords[] = { "filename", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::save(filename), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.DTrees", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_DTrees_setCVFolds(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::DTrees> * self1 = 0;
    if (!evision_ml_DTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::DTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::DTrees> _self_ = *(self1);
    int val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setCVFolds(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.DTrees", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_DTrees_setMaxCategories(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::DTrees> * self1 = 0;
    if (!evision_ml_DTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::DTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::DTrees> _self_ = *(self1);
    int val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setMaxCategories(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.DTrees", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_DTrees_setMaxDepth(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::DTrees> * self1 = 0;
    if (!evision_ml_DTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::DTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::DTrees> _self_ = *(self1);
    int val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setMaxDepth(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.DTrees", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_DTrees_setMinSampleCount(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::DTrees> * self1 = 0;
    if (!evision_ml_DTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::DTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::DTrees> _self_ = *(self1);
    int val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setMinSampleCount(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.DTrees", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_DTrees_setPriors(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::DTrees> * self1 = 0;
    if (!evision_ml_DTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::DTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::DTrees> _self_ = *(self1);
    Mat val;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setPriors(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.DTrees", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_DTrees_setRegressionAccuracy(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::DTrees> * self1 = 0;
    if (!evision_ml_DTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::DTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::DTrees> _self_ = *(self1);
    float val=0.f;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setRegressionAccuracy(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.DTrees", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_DTrees_setTruncatePrunedTree(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::DTrees> * self1 = 0;
    if (!evision_ml_DTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::DTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::DTrees> _self_ = *(self1);
    bool val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setTruncatePrunedTree(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.DTrees", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_DTrees_setUse1SERule(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::DTrees> * self1 = 0;
    if (!evision_ml_DTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::DTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::DTrees> _self_ = *(self1);
    bool val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setUse1SERule(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.DTrees", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_DTrees_setUseSurrogates(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::DTrees> * self1 = 0;
    if (!evision_ml_DTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::DTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::DTrees> _self_ = *(self1);
    bool val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setUseSurrogates(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.DTrees", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_DTrees_train(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::DTrees> * self1 = 0;
    if (!evision_ml_DTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::DTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::DTrees> _self_ = *(self1);

    {
    Ptr<TrainData> trainData;
    int flags=0;
    bool retval;

    // const char* keywords[] = { "trainData", "flags", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "trainData"), trainData, ArgInfo("trainData", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->train(trainData, flags), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    Mat samples;
    int layout=0;
    Mat responses;
    bool retval;

    // const char* keywords[] = { "samples", "layout", "responses", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "layout"), layout, ArgInfo("layout", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "responses"), responses, ArgInfo("responses", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->train(samples, layout, responses), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    UMat samples;
    int layout=0;
    UMat responses;
    bool retval;

    // const char* keywords[] = { "samples", "layout", "responses", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "layout"), layout, ArgInfo("layout", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "responses"), responses, ArgInfo("responses", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->train(samples, layout, responses), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_DTrees_write(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::DTrees> * self1 = 0;
    if (!evision_ml_DTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::DTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::DTrees> _self_ = *(self1);
    Ptr<FileStorage> fs;
    String name;

    // const char* keywords[] = { "fs", "name", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fs"), fs, ArgInfo("fs", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "name"), name, ArgInfo("name", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::write(fs, name), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.DTrees", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (ml_DTrees)

template<>
struct Evision_Converter< Ptr<cv::ml::DTrees> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::ml::DTrees>& r)
    {
        return evision_ml_DTrees_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::ml::DTrees>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::ml::DTrees> * dst_ = nullptr;
        if (evision_ml_DTrees_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::ml::DTrees> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// ml_EM (Generic)
//================================================================================

// GetSet (ml_EM)



// Methods (ml_EM)

static ERL_NIF_TERM evision_cv_ml_ml_EM_calcError(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::EM> * self1 = 0;
    if (!evision_ml_EM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::EM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::EM> _self_ = *(self1);

    {
    Ptr<TrainData> data;
    bool test=0;
    Mat resp;
    float retval;

    // const char* keywords[] = { "data", "test", "resp", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "data"), data, ArgInfo("data", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "test"), test, ArgInfo("test", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "resp"), resp, ArgInfo("resp", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->calcError(data, test, resp), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, resp));
        }
    }

    }
    

    {
    Ptr<TrainData> data;
    bool test=0;
    UMat resp;
    float retval;

    // const char* keywords[] = { "data", "test", "resp", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "data"), data, ArgInfo("data", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "test"), test, ArgInfo("test", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "resp"), resp, ArgInfo("resp", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->calcError(data, test, resp), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, resp));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_EM_clear(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::EM> * self1 = 0;
    if (!evision_ml_EM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::EM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::EM> _self_ = *(self1);

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::clear(), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.EM", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_EM_create_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    Ptr<EM> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::ml::EM::create(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_EM_empty(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::EM> * self1 = 0;
    if (!evision_ml_EM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::EM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::EM> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->empty(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_EM_getClustersNumber(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::EM> * self1 = 0;
    if (!evision_ml_EM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::EM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::EM> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getClustersNumber(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_EM_getCovarianceMatrixType(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::EM> * self1 = 0;
    if (!evision_ml_EM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::EM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::EM> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getCovarianceMatrixType(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_EM_getCovs(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::EM> * self1 = 0;
    if (!evision_ml_EM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::EM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::EM> _self_ = *(self1);
    vector_Mat covs;

    // const char* keywords[] = { "covs", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "covs"), covs, ArgInfo("covs", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->getCovs(covs), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, covs);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_EM_getDefaultName(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::EM> * self1 = 0;
    if (!evision_ml_EM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::EM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::EM> _self_ = *(self1);
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->Algorithm::getDefaultName(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_EM_getMeans(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::EM> * self1 = 0;
    if (!evision_ml_EM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::EM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::EM> _self_ = *(self1);
    Mat retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getMeans(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_EM_getTermCriteria(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::EM> * self1 = 0;
    if (!evision_ml_EM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::EM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::EM> _self_ = *(self1);
    TermCriteria retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getTermCriteria(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_EM_getVarCount(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::EM> * self1 = 0;
    if (!evision_ml_EM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::EM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::EM> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getVarCount(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_EM_getWeights(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::EM> * self1 = 0;
    if (!evision_ml_EM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::EM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::EM> _self_ = *(self1);
    Mat retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getWeights(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_EM_isClassifier(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::EM> * self1 = 0;
    if (!evision_ml_EM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::EM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::EM> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->isClassifier(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_EM_isTrained(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::EM> * self1 = 0;
    if (!evision_ml_EM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::EM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::EM> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->isTrained(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_EM_load_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    String filepath;
    String nodeName = String();
    Ptr<EM> retval;

    // const char* keywords[] = { "filepath", "nodeName", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filepath"), filepath, ArgInfo("filepath", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nodeName"), nodeName, ArgInfo("nodeName", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::ml::EM::load(filepath, nodeName), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_EM_predict(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::EM> * self1 = 0;
    if (!evision_ml_EM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::EM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::EM> _self_ = *(self1);

    {
    Mat samples;
    Mat results;
    int flags=0;
    float retval;

    // const char* keywords[] = { "samples", "results", "flags", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "results"), results, ArgInfo("results", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->predict(samples, results, flags), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, results));
        }
    }

    }
    

    {
    UMat samples;
    UMat results;
    int flags=0;
    float retval;

    // const char* keywords[] = { "samples", "results", "flags", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "results"), results, ArgInfo("results", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->predict(samples, results, flags), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, results));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_EM_predict2(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::EM> * self1 = 0;
    if (!evision_ml_EM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::EM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::EM> _self_ = *(self1);

    {
    Mat sample;
    Mat probs;
    Vec2d retval;

    // const char* keywords[] = { "sample", "probs", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "sample"), sample, ArgInfo("sample", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "probs"), probs, ArgInfo("probs", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->predict2(sample, probs), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, probs));
        }
    }

    }
    

    {
    UMat sample;
    UMat probs;
    Vec2d retval;

    // const char* keywords[] = { "sample", "probs", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "sample"), sample, ArgInfo("sample", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "probs"), probs, ArgInfo("probs", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->predict2(sample, probs), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, probs));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_EM_read(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::EM> * self1 = 0;
    if (!evision_ml_EM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::EM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::EM> _self_ = *(self1);
    FileNode fn_;

    // const char* keywords[] = { "fn_", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fn_"), fn_, ArgInfo("fn_", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::read(fn_), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.EM", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_EM_save(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::EM> * self1 = 0;
    if (!evision_ml_EM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::EM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::EM> _self_ = *(self1);
    String filename;

    // const char* keywords[] = { "filename", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::save(filename), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.EM", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_EM_setClustersNumber(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::EM> * self1 = 0;
    if (!evision_ml_EM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::EM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::EM> _self_ = *(self1);
    int val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setClustersNumber(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.EM", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_EM_setCovarianceMatrixType(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::EM> * self1 = 0;
    if (!evision_ml_EM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::EM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::EM> _self_ = *(self1);
    int val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setCovarianceMatrixType(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.EM", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_EM_setTermCriteria(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::EM> * self1 = 0;
    if (!evision_ml_EM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::EM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::EM> _self_ = *(self1);
    TermCriteria val;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setTermCriteria(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.EM", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_EM_train(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::EM> * self1 = 0;
    if (!evision_ml_EM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::EM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::EM> _self_ = *(self1);

    {
    Ptr<TrainData> trainData;
    int flags=0;
    bool retval;

    // const char* keywords[] = { "trainData", "flags", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "trainData"), trainData, ArgInfo("trainData", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->train(trainData, flags), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    Mat samples;
    int layout=0;
    Mat responses;
    bool retval;

    // const char* keywords[] = { "samples", "layout", "responses", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "layout"), layout, ArgInfo("layout", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "responses"), responses, ArgInfo("responses", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->train(samples, layout, responses), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    UMat samples;
    int layout=0;
    UMat responses;
    bool retval;

    // const char* keywords[] = { "samples", "layout", "responses", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "layout"), layout, ArgInfo("layout", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "responses"), responses, ArgInfo("responses", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->train(samples, layout, responses), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_EM_trainE(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::EM> * self1 = 0;
    if (!evision_ml_EM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::EM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::EM> _self_ = *(self1);

    {
    Mat samples;
    Mat means0;
    Mat covs0;
    Mat weights0;
    Mat logLikelihoods;
    Mat labels;
    Mat probs;
    bool retval;

    // const char* keywords[] = { "samples", "means0", "covs0", "weights0", "logLikelihoods", "labels", "probs", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "means0"), means0, ArgInfo("means0", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "covs0"), covs0, ArgInfo("covs0", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "weights0"), weights0, ArgInfo("weights0", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "logLikelihoods"), logLikelihoods, ArgInfo("logLikelihoods", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "labels"), labels, ArgInfo("labels", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "probs"), probs, ArgInfo("probs", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->trainE(samples, means0, covs0, weights0, logLikelihoods, labels, probs), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_2_to_10_tuple_except_bool
                return enif_make_tuple3(env, evision_from(env, logLikelihoods), evision_from(env, labels), evision_from(env, probs));
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    UMat samples;
    UMat means0;
    UMat covs0;
    UMat weights0;
    UMat logLikelihoods;
    UMat labels;
    UMat probs;
    bool retval;

    // const char* keywords[] = { "samples", "means0", "covs0", "weights0", "logLikelihoods", "labels", "probs", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "means0"), means0, ArgInfo("means0", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "covs0"), covs0, ArgInfo("covs0", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "weights0"), weights0, ArgInfo("weights0", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "logLikelihoods"), logLikelihoods, ArgInfo("logLikelihoods", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "labels"), labels, ArgInfo("labels", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "probs"), probs, ArgInfo("probs", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->trainE(samples, means0, covs0, weights0, logLikelihoods, labels, probs), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_2_to_10_tuple_except_bool
                return enif_make_tuple3(env, evision_from(env, logLikelihoods), evision_from(env, labels), evision_from(env, probs));
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_EM_trainEM(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::EM> * self1 = 0;
    if (!evision_ml_EM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::EM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::EM> _self_ = *(self1);

    {
    Mat samples;
    Mat logLikelihoods;
    Mat labels;
    Mat probs;
    bool retval;

    // const char* keywords[] = { "samples", "logLikelihoods", "labels", "probs", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "logLikelihoods"), logLikelihoods, ArgInfo("logLikelihoods", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "labels"), labels, ArgInfo("labels", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "probs"), probs, ArgInfo("probs", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->trainEM(samples, logLikelihoods, labels, probs), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_2_to_10_tuple_except_bool
                return enif_make_tuple3(env, evision_from(env, logLikelihoods), evision_from(env, labels), evision_from(env, probs));
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    UMat samples;
    UMat logLikelihoods;
    UMat labels;
    UMat probs;
    bool retval;

    // const char* keywords[] = { "samples", "logLikelihoods", "labels", "probs", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "logLikelihoods"), logLikelihoods, ArgInfo("logLikelihoods", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "labels"), labels, ArgInfo("labels", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "probs"), probs, ArgInfo("probs", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->trainEM(samples, logLikelihoods, labels, probs), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_2_to_10_tuple_except_bool
                return enif_make_tuple3(env, evision_from(env, logLikelihoods), evision_from(env, labels), evision_from(env, probs));
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_EM_trainM(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::EM> * self1 = 0;
    if (!evision_ml_EM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::EM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::EM> _self_ = *(self1);

    {
    Mat samples;
    Mat probs0;
    Mat logLikelihoods;
    Mat labels;
    Mat probs;
    bool retval;

    // const char* keywords[] = { "samples", "probs0", "logLikelihoods", "labels", "probs", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "probs0"), probs0, ArgInfo("probs0", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "logLikelihoods"), logLikelihoods, ArgInfo("logLikelihoods", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "labels"), labels, ArgInfo("labels", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "probs"), probs, ArgInfo("probs", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->trainM(samples, probs0, logLikelihoods, labels, probs), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_2_to_10_tuple_except_bool
                return enif_make_tuple3(env, evision_from(env, logLikelihoods), evision_from(env, labels), evision_from(env, probs));
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    UMat samples;
    UMat probs0;
    UMat logLikelihoods;
    UMat labels;
    UMat probs;
    bool retval;

    // const char* keywords[] = { "samples", "probs0", "logLikelihoods", "labels", "probs", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "probs0"), probs0, ArgInfo("probs0", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "logLikelihoods"), logLikelihoods, ArgInfo("logLikelihoods", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "labels"), labels, ArgInfo("labels", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "probs"), probs, ArgInfo("probs", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->trainM(samples, probs0, logLikelihoods, labels, probs), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_2_to_10_tuple_except_bool
                return enif_make_tuple3(env, evision_from(env, logLikelihoods), evision_from(env, labels), evision_from(env, probs));
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_EM_write(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::EM> * self1 = 0;
    if (!evision_ml_EM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::EM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::EM> _self_ = *(self1);
    Ptr<FileStorage> fs;
    String name;

    // const char* keywords[] = { "fs", "name", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fs"), fs, ArgInfo("fs", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "name"), name, ArgInfo("name", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::write(fs, name), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.EM", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (ml_EM)

template<>
struct Evision_Converter< Ptr<cv::ml::EM> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::ml::EM>& r)
    {
        return evision_ml_EM_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::ml::EM>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::ml::EM> * dst_ = nullptr;
        if (evision_ml_EM_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::ml::EM> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// ml_KNearest (Generic)
//================================================================================

// GetSet (ml_KNearest)



// Methods (ml_KNearest)

static ERL_NIF_TERM evision_cv_ml_ml_KNearest_calcError(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::KNearest> * self1 = 0;
    if (!evision_ml_KNearest_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::KNearest>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::KNearest> _self_ = *(self1);

    {
    Ptr<TrainData> data;
    bool test=0;
    Mat resp;
    float retval;

    // const char* keywords[] = { "data", "test", "resp", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "data"), data, ArgInfo("data", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "test"), test, ArgInfo("test", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "resp"), resp, ArgInfo("resp", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->calcError(data, test, resp), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, resp));
        }
    }

    }
    

    {
    Ptr<TrainData> data;
    bool test=0;
    UMat resp;
    float retval;

    // const char* keywords[] = { "data", "test", "resp", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "data"), data, ArgInfo("data", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "test"), test, ArgInfo("test", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "resp"), resp, ArgInfo("resp", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->calcError(data, test, resp), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, resp));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_KNearest_clear(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::KNearest> * self1 = 0;
    if (!evision_ml_KNearest_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::KNearest>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::KNearest> _self_ = *(self1);

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::clear(), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.KNearest", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_KNearest_create_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    Ptr<KNearest> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::ml::KNearest::create(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_KNearest_empty(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::KNearest> * self1 = 0;
    if (!evision_ml_KNearest_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::KNearest>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::KNearest> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->empty(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_KNearest_findNearest(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::KNearest> * self1 = 0;
    if (!evision_ml_KNearest_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::KNearest>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::KNearest> _self_ = *(self1);

    {
    Mat samples;
    int k=0;
    Mat results;
    Mat neighborResponses;
    Mat dist;
    float retval;

    // const char* keywords[] = { "samples", "k", "results", "neighborResponses", "dist", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), k, ArgInfo("k", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "results"), results, ArgInfo("results", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "neighborResponses"), neighborResponses, ArgInfo("neighborResponses", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dist"), dist, ArgInfo("dist", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->findNearest(samples, k, results, neighborResponses, dist), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple4(env, evision_from(env, retval), evision_from(env, results), evision_from(env, neighborResponses), evision_from(env, dist));
        }
    }

    }
    

    {
    UMat samples;
    int k=0;
    UMat results;
    UMat neighborResponses;
    UMat dist;
    float retval;

    // const char* keywords[] = { "samples", "k", "results", "neighborResponses", "dist", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), k, ArgInfo("k", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "results"), results, ArgInfo("results", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "neighborResponses"), neighborResponses, ArgInfo("neighborResponses", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dist"), dist, ArgInfo("dist", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->findNearest(samples, k, results, neighborResponses, dist), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple4(env, evision_from(env, retval), evision_from(env, results), evision_from(env, neighborResponses), evision_from(env, dist));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_KNearest_getAlgorithmType(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::KNearest> * self1 = 0;
    if (!evision_ml_KNearest_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::KNearest>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::KNearest> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getAlgorithmType(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_KNearest_getDefaultK(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::KNearest> * self1 = 0;
    if (!evision_ml_KNearest_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::KNearest>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::KNearest> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getDefaultK(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_KNearest_getDefaultName(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::KNearest> * self1 = 0;
    if (!evision_ml_KNearest_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::KNearest>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::KNearest> _self_ = *(self1);
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->Algorithm::getDefaultName(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_KNearest_getEmax(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::KNearest> * self1 = 0;
    if (!evision_ml_KNearest_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::KNearest>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::KNearest> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getEmax(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_KNearest_getIsClassifier(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::KNearest> * self1 = 0;
    if (!evision_ml_KNearest_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::KNearest>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::KNearest> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getIsClassifier(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_KNearest_getVarCount(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::KNearest> * self1 = 0;
    if (!evision_ml_KNearest_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::KNearest>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::KNearest> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getVarCount(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_KNearest_isClassifier(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::KNearest> * self1 = 0;
    if (!evision_ml_KNearest_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::KNearest>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::KNearest> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->isClassifier(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_KNearest_isTrained(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::KNearest> * self1 = 0;
    if (!evision_ml_KNearest_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::KNearest>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::KNearest> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->isTrained(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_KNearest_load_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    String filepath;
    Ptr<KNearest> retval;

    // const char* keywords[] = { "filepath", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filepath"), filepath, ArgInfo("filepath", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::ml::KNearest::load(filepath), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_KNearest_predict(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::KNearest> * self1 = 0;
    if (!evision_ml_KNearest_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::KNearest>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::KNearest> _self_ = *(self1);

    {
    Mat samples;
    Mat results;
    int flags=0;
    float retval;

    // const char* keywords[] = { "samples", "results", "flags", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "results"), results, ArgInfo("results", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->predict(samples, results, flags), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, results));
        }
    }

    }
    

    {
    UMat samples;
    UMat results;
    int flags=0;
    float retval;

    // const char* keywords[] = { "samples", "results", "flags", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "results"), results, ArgInfo("results", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->predict(samples, results, flags), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, results));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_KNearest_read(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::KNearest> * self1 = 0;
    if (!evision_ml_KNearest_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::KNearest>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::KNearest> _self_ = *(self1);
    FileNode fn_;

    // const char* keywords[] = { "fn_", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fn_"), fn_, ArgInfo("fn_", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::read(fn_), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.KNearest", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_KNearest_save(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::KNearest> * self1 = 0;
    if (!evision_ml_KNearest_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::KNearest>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::KNearest> _self_ = *(self1);
    String filename;

    // const char* keywords[] = { "filename", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::save(filename), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.KNearest", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_KNearest_setAlgorithmType(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::KNearest> * self1 = 0;
    if (!evision_ml_KNearest_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::KNearest>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::KNearest> _self_ = *(self1);
    int val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setAlgorithmType(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.KNearest", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_KNearest_setDefaultK(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::KNearest> * self1 = 0;
    if (!evision_ml_KNearest_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::KNearest>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::KNearest> _self_ = *(self1);
    int val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setDefaultK(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.KNearest", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_KNearest_setEmax(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::KNearest> * self1 = 0;
    if (!evision_ml_KNearest_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::KNearest>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::KNearest> _self_ = *(self1);
    int val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setEmax(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.KNearest", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_KNearest_setIsClassifier(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::KNearest> * self1 = 0;
    if (!evision_ml_KNearest_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::KNearest>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::KNearest> _self_ = *(self1);
    bool val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setIsClassifier(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.KNearest", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_KNearest_train(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::KNearest> * self1 = 0;
    if (!evision_ml_KNearest_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::KNearest>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::KNearest> _self_ = *(self1);

    {
    Ptr<TrainData> trainData;
    int flags=0;
    bool retval;

    // const char* keywords[] = { "trainData", "flags", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "trainData"), trainData, ArgInfo("trainData", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->train(trainData, flags), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    Mat samples;
    int layout=0;
    Mat responses;
    bool retval;

    // const char* keywords[] = { "samples", "layout", "responses", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "layout"), layout, ArgInfo("layout", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "responses"), responses, ArgInfo("responses", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->train(samples, layout, responses), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    UMat samples;
    int layout=0;
    UMat responses;
    bool retval;

    // const char* keywords[] = { "samples", "layout", "responses", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "layout"), layout, ArgInfo("layout", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "responses"), responses, ArgInfo("responses", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->train(samples, layout, responses), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_KNearest_write(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::KNearest> * self1 = 0;
    if (!evision_ml_KNearest_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::KNearest>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::KNearest> _self_ = *(self1);
    Ptr<FileStorage> fs;
    String name;

    // const char* keywords[] = { "fs", "name", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fs"), fs, ArgInfo("fs", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "name"), name, ArgInfo("name", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::write(fs, name), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.KNearest", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (ml_KNearest)

template<>
struct Evision_Converter< Ptr<cv::ml::KNearest> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::ml::KNearest>& r)
    {
        return evision_ml_KNearest_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::ml::KNearest>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::ml::KNearest> * dst_ = nullptr;
        if (evision_ml_KNearest_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::ml::KNearest> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// ml_LogisticRegression (Generic)
//================================================================================

// GetSet (ml_LogisticRegression)



// Methods (ml_LogisticRegression)

static ERL_NIF_TERM evision_cv_ml_ml_LogisticRegression_calcError(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::LogisticRegression> * self1 = 0;
    if (!evision_ml_LogisticRegression_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::LogisticRegression>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::LogisticRegression> _self_ = *(self1);

    {
    Ptr<TrainData> data;
    bool test=0;
    Mat resp;
    float retval;

    // const char* keywords[] = { "data", "test", "resp", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "data"), data, ArgInfo("data", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "test"), test, ArgInfo("test", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "resp"), resp, ArgInfo("resp", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->calcError(data, test, resp), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, resp));
        }
    }

    }
    

    {
    Ptr<TrainData> data;
    bool test=0;
    UMat resp;
    float retval;

    // const char* keywords[] = { "data", "test", "resp", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "data"), data, ArgInfo("data", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "test"), test, ArgInfo("test", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "resp"), resp, ArgInfo("resp", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->calcError(data, test, resp), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, resp));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_LogisticRegression_clear(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::LogisticRegression> * self1 = 0;
    if (!evision_ml_LogisticRegression_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::LogisticRegression>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::LogisticRegression> _self_ = *(self1);

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::clear(), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.LogisticRegression", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_LogisticRegression_create_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    Ptr<LogisticRegression> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::ml::LogisticRegression::create(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_LogisticRegression_empty(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::LogisticRegression> * self1 = 0;
    if (!evision_ml_LogisticRegression_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::LogisticRegression>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::LogisticRegression> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->empty(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_LogisticRegression_getDefaultName(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::LogisticRegression> * self1 = 0;
    if (!evision_ml_LogisticRegression_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::LogisticRegression>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::LogisticRegression> _self_ = *(self1);
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->Algorithm::getDefaultName(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_LogisticRegression_getIterations(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::LogisticRegression> * self1 = 0;
    if (!evision_ml_LogisticRegression_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::LogisticRegression>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::LogisticRegression> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getIterations(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_LogisticRegression_getLearningRate(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::LogisticRegression> * self1 = 0;
    if (!evision_ml_LogisticRegression_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::LogisticRegression>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::LogisticRegression> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getLearningRate(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_LogisticRegression_getMiniBatchSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::LogisticRegression> * self1 = 0;
    if (!evision_ml_LogisticRegression_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::LogisticRegression>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::LogisticRegression> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getMiniBatchSize(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_LogisticRegression_getRegularization(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::LogisticRegression> * self1 = 0;
    if (!evision_ml_LogisticRegression_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::LogisticRegression>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::LogisticRegression> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getRegularization(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_LogisticRegression_getTermCriteria(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::LogisticRegression> * self1 = 0;
    if (!evision_ml_LogisticRegression_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::LogisticRegression>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::LogisticRegression> _self_ = *(self1);
    TermCriteria retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getTermCriteria(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_LogisticRegression_getTrainMethod(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::LogisticRegression> * self1 = 0;
    if (!evision_ml_LogisticRegression_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::LogisticRegression>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::LogisticRegression> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getTrainMethod(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_LogisticRegression_getVarCount(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::LogisticRegression> * self1 = 0;
    if (!evision_ml_LogisticRegression_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::LogisticRegression>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::LogisticRegression> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getVarCount(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_LogisticRegression_get_learnt_thetas(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::LogisticRegression> * self1 = 0;
    if (!evision_ml_LogisticRegression_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::LogisticRegression>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::LogisticRegression> _self_ = *(self1);
    Mat retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->get_learnt_thetas(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_LogisticRegression_isClassifier(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::LogisticRegression> * self1 = 0;
    if (!evision_ml_LogisticRegression_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::LogisticRegression>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::LogisticRegression> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->isClassifier(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_LogisticRegression_isTrained(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::LogisticRegression> * self1 = 0;
    if (!evision_ml_LogisticRegression_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::LogisticRegression>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::LogisticRegression> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->isTrained(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_LogisticRegression_load_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    String filepath;
    String nodeName = String();
    Ptr<LogisticRegression> retval;

    // const char* keywords[] = { "filepath", "nodeName", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filepath"), filepath, ArgInfo("filepath", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nodeName"), nodeName, ArgInfo("nodeName", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::ml::LogisticRegression::load(filepath, nodeName), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_LogisticRegression_predict(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::LogisticRegression> * self1 = 0;
    if (!evision_ml_LogisticRegression_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::LogisticRegression>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::LogisticRegression> _self_ = *(self1);

    {
    Mat samples;
    Mat results;
    int flags=0;
    float retval;

    // const char* keywords[] = { "samples", "results", "flags", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "results"), results, ArgInfo("results", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->predict(samples, results, flags), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, results));
        }
    }

    }
    

    {
    UMat samples;
    UMat results;
    int flags=0;
    float retval;

    // const char* keywords[] = { "samples", "results", "flags", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "results"), results, ArgInfo("results", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->predict(samples, results, flags), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, results));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_LogisticRegression_read(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::LogisticRegression> * self1 = 0;
    if (!evision_ml_LogisticRegression_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::LogisticRegression>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::LogisticRegression> _self_ = *(self1);
    FileNode fn_;

    // const char* keywords[] = { "fn_", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fn_"), fn_, ArgInfo("fn_", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::read(fn_), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.LogisticRegression", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_LogisticRegression_save(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::LogisticRegression> * self1 = 0;
    if (!evision_ml_LogisticRegression_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::LogisticRegression>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::LogisticRegression> _self_ = *(self1);
    String filename;

    // const char* keywords[] = { "filename", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::save(filename), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.LogisticRegression", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_LogisticRegression_setIterations(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::LogisticRegression> * self1 = 0;
    if (!evision_ml_LogisticRegression_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::LogisticRegression>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::LogisticRegression> _self_ = *(self1);
    int val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setIterations(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.LogisticRegression", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_LogisticRegression_setLearningRate(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::LogisticRegression> * self1 = 0;
    if (!evision_ml_LogisticRegression_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::LogisticRegression>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::LogisticRegression> _self_ = *(self1);
    double val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setLearningRate(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.LogisticRegression", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_LogisticRegression_setMiniBatchSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::LogisticRegression> * self1 = 0;
    if (!evision_ml_LogisticRegression_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::LogisticRegression>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::LogisticRegression> _self_ = *(self1);
    int val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setMiniBatchSize(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.LogisticRegression", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_LogisticRegression_setRegularization(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::LogisticRegression> * self1 = 0;
    if (!evision_ml_LogisticRegression_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::LogisticRegression>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::LogisticRegression> _self_ = *(self1);
    int val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setRegularization(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.LogisticRegression", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_LogisticRegression_setTermCriteria(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::LogisticRegression> * self1 = 0;
    if (!evision_ml_LogisticRegression_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::LogisticRegression>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::LogisticRegression> _self_ = *(self1);
    TermCriteria val;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setTermCriteria(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.LogisticRegression", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_LogisticRegression_setTrainMethod(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::LogisticRegression> * self1 = 0;
    if (!evision_ml_LogisticRegression_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::LogisticRegression>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::LogisticRegression> _self_ = *(self1);
    int val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setTrainMethod(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.LogisticRegression", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_LogisticRegression_train(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::LogisticRegression> * self1 = 0;
    if (!evision_ml_LogisticRegression_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::LogisticRegression>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::LogisticRegression> _self_ = *(self1);

    {
    Ptr<TrainData> trainData;
    int flags=0;
    bool retval;

    // const char* keywords[] = { "trainData", "flags", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "trainData"), trainData, ArgInfo("trainData", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->train(trainData, flags), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    Mat samples;
    int layout=0;
    Mat responses;
    bool retval;

    // const char* keywords[] = { "samples", "layout", "responses", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "layout"), layout, ArgInfo("layout", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "responses"), responses, ArgInfo("responses", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->train(samples, layout, responses), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    UMat samples;
    int layout=0;
    UMat responses;
    bool retval;

    // const char* keywords[] = { "samples", "layout", "responses", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "layout"), layout, ArgInfo("layout", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "responses"), responses, ArgInfo("responses", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->train(samples, layout, responses), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_LogisticRegression_write(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::LogisticRegression> * self1 = 0;
    if (!evision_ml_LogisticRegression_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::LogisticRegression>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::LogisticRegression> _self_ = *(self1);
    Ptr<FileStorage> fs;
    String name;

    // const char* keywords[] = { "fs", "name", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fs"), fs, ArgInfo("fs", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "name"), name, ArgInfo("name", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::write(fs, name), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.LogisticRegression", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (ml_LogisticRegression)

template<>
struct Evision_Converter< Ptr<cv::ml::LogisticRegression> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::ml::LogisticRegression>& r)
    {
        return evision_ml_LogisticRegression_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::ml::LogisticRegression>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::ml::LogisticRegression> * dst_ = nullptr;
        if (evision_ml_LogisticRegression_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::ml::LogisticRegression> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// ml_NormalBayesClassifier (Generic)
//================================================================================

// GetSet (ml_NormalBayesClassifier)



// Methods (ml_NormalBayesClassifier)

static ERL_NIF_TERM evision_cv_ml_ml_NormalBayesClassifier_calcError(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::NormalBayesClassifier> * self1 = 0;
    if (!evision_ml_NormalBayesClassifier_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::NormalBayesClassifier>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::NormalBayesClassifier> _self_ = *(self1);

    {
    Ptr<TrainData> data;
    bool test=0;
    Mat resp;
    float retval;

    // const char* keywords[] = { "data", "test", "resp", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "data"), data, ArgInfo("data", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "test"), test, ArgInfo("test", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "resp"), resp, ArgInfo("resp", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->calcError(data, test, resp), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, resp));
        }
    }

    }
    

    {
    Ptr<TrainData> data;
    bool test=0;
    UMat resp;
    float retval;

    // const char* keywords[] = { "data", "test", "resp", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "data"), data, ArgInfo("data", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "test"), test, ArgInfo("test", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "resp"), resp, ArgInfo("resp", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->calcError(data, test, resp), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, resp));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_NormalBayesClassifier_clear(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::NormalBayesClassifier> * self1 = 0;
    if (!evision_ml_NormalBayesClassifier_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::NormalBayesClassifier>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::NormalBayesClassifier> _self_ = *(self1);

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::clear(), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.NormalBayesClassifier", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_NormalBayesClassifier_create_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    Ptr<NormalBayesClassifier> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::ml::NormalBayesClassifier::create(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_NormalBayesClassifier_empty(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::NormalBayesClassifier> * self1 = 0;
    if (!evision_ml_NormalBayesClassifier_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::NormalBayesClassifier>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::NormalBayesClassifier> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->empty(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_NormalBayesClassifier_getDefaultName(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::NormalBayesClassifier> * self1 = 0;
    if (!evision_ml_NormalBayesClassifier_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::NormalBayesClassifier>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::NormalBayesClassifier> _self_ = *(self1);
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->Algorithm::getDefaultName(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_NormalBayesClassifier_getVarCount(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::NormalBayesClassifier> * self1 = 0;
    if (!evision_ml_NormalBayesClassifier_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::NormalBayesClassifier>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::NormalBayesClassifier> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getVarCount(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_NormalBayesClassifier_isClassifier(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::NormalBayesClassifier> * self1 = 0;
    if (!evision_ml_NormalBayesClassifier_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::NormalBayesClassifier>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::NormalBayesClassifier> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->isClassifier(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_NormalBayesClassifier_isTrained(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::NormalBayesClassifier> * self1 = 0;
    if (!evision_ml_NormalBayesClassifier_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::NormalBayesClassifier>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::NormalBayesClassifier> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->isTrained(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_NormalBayesClassifier_load_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    String filepath;
    String nodeName = String();
    Ptr<NormalBayesClassifier> retval;

    // const char* keywords[] = { "filepath", "nodeName", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filepath"), filepath, ArgInfo("filepath", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nodeName"), nodeName, ArgInfo("nodeName", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::ml::NormalBayesClassifier::load(filepath, nodeName), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_NormalBayesClassifier_predict(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::NormalBayesClassifier> * self1 = 0;
    if (!evision_ml_NormalBayesClassifier_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::NormalBayesClassifier>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::NormalBayesClassifier> _self_ = *(self1);

    {
    Mat samples;
    Mat results;
    int flags=0;
    float retval;

    // const char* keywords[] = { "samples", "results", "flags", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "results"), results, ArgInfo("results", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->predict(samples, results, flags), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, results));
        }
    }

    }
    

    {
    UMat samples;
    UMat results;
    int flags=0;
    float retval;

    // const char* keywords[] = { "samples", "results", "flags", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "results"), results, ArgInfo("results", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->predict(samples, results, flags), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, results));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_NormalBayesClassifier_predictProb(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::NormalBayesClassifier> * self1 = 0;
    if (!evision_ml_NormalBayesClassifier_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::NormalBayesClassifier>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::NormalBayesClassifier> _self_ = *(self1);

    {
    Mat inputs;
    Mat outputs;
    Mat outputProbs;
    int flags=0;
    float retval;

    // const char* keywords[] = { "inputs", "outputs", "outputProbs", "flags", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "inputs"), inputs, ArgInfo("inputs", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "outputs"), outputs, ArgInfo("outputs", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "outputProbs"), outputProbs, ArgInfo("outputProbs", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->predictProb(inputs, outputs, outputProbs, flags), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, retval), evision_from(env, outputs), evision_from(env, outputProbs));
        }
    }

    }
    

    {
    UMat inputs;
    UMat outputs;
    UMat outputProbs;
    int flags=0;
    float retval;

    // const char* keywords[] = { "inputs", "outputs", "outputProbs", "flags", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "inputs"), inputs, ArgInfo("inputs", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "outputs"), outputs, ArgInfo("outputs", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "outputProbs"), outputProbs, ArgInfo("outputProbs", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->predictProb(inputs, outputs, outputProbs, flags), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, retval), evision_from(env, outputs), evision_from(env, outputProbs));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_NormalBayesClassifier_read(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::NormalBayesClassifier> * self1 = 0;
    if (!evision_ml_NormalBayesClassifier_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::NormalBayesClassifier>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::NormalBayesClassifier> _self_ = *(self1);
    FileNode fn_;

    // const char* keywords[] = { "fn_", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fn_"), fn_, ArgInfo("fn_", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::read(fn_), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.NormalBayesClassifier", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_NormalBayesClassifier_save(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::NormalBayesClassifier> * self1 = 0;
    if (!evision_ml_NormalBayesClassifier_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::NormalBayesClassifier>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::NormalBayesClassifier> _self_ = *(self1);
    String filename;

    // const char* keywords[] = { "filename", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::save(filename), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.NormalBayesClassifier", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_NormalBayesClassifier_train(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::NormalBayesClassifier> * self1 = 0;
    if (!evision_ml_NormalBayesClassifier_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::NormalBayesClassifier>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::NormalBayesClassifier> _self_ = *(self1);

    {
    Ptr<TrainData> trainData;
    int flags=0;
    bool retval;

    // const char* keywords[] = { "trainData", "flags", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "trainData"), trainData, ArgInfo("trainData", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->train(trainData, flags), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    Mat samples;
    int layout=0;
    Mat responses;
    bool retval;

    // const char* keywords[] = { "samples", "layout", "responses", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "layout"), layout, ArgInfo("layout", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "responses"), responses, ArgInfo("responses", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->train(samples, layout, responses), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    UMat samples;
    int layout=0;
    UMat responses;
    bool retval;

    // const char* keywords[] = { "samples", "layout", "responses", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "layout"), layout, ArgInfo("layout", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "responses"), responses, ArgInfo("responses", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->train(samples, layout, responses), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_NormalBayesClassifier_write(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::NormalBayesClassifier> * self1 = 0;
    if (!evision_ml_NormalBayesClassifier_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::NormalBayesClassifier>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::NormalBayesClassifier> _self_ = *(self1);
    Ptr<FileStorage> fs;
    String name;

    // const char* keywords[] = { "fs", "name", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fs"), fs, ArgInfo("fs", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "name"), name, ArgInfo("name", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::write(fs, name), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.NormalBayesClassifier", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (ml_NormalBayesClassifier)

template<>
struct Evision_Converter< Ptr<cv::ml::NormalBayesClassifier> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::ml::NormalBayesClassifier>& r)
    {
        return evision_ml_NormalBayesClassifier_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::ml::NormalBayesClassifier>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::ml::NormalBayesClassifier> * dst_ = nullptr;
        if (evision_ml_NormalBayesClassifier_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::ml::NormalBayesClassifier> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// ml_ParamGrid (Generic)
//================================================================================

// GetSet (ml_ParamGrid)


static ERL_NIF_TERM evision_ml_ParamGrid_get_logStep(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::ParamGrid>* self_ptr = 0;
    if (!evision_ml_ParamGrid_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::ParamGrid>` from `self`: mismatched type or invalid resource?");
    }

    Ptr<cv::ml::ParamGrid> &self2 = *self_ptr;
    cv::ml::ParamGrid* _self_ = dynamic_cast<cv::ml::ParamGrid*>(self2.get());
    return evision_from(env, _self_->logStep);
}

static ERL_NIF_TERM evision_ml_ParamGrid_set_logStep(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::ParamGrid>* self_ptr = 0;

    if (!evision_ml_ParamGrid_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::ParamGrid>` from `self`: mismatched type or invalid resource?");
    }

    Ptr<cv::ml::ParamGrid> &_self_ = *self_ptr;

    std::map<std::string, ERL_NIF_TERM> erl_terms;
    evision::nif::parse_arg(env, 1, argv, erl_terms);

    if (evision_to_safe(env, evision_get_kw(env, erl_terms, "logStep"), _self_->logStep, ArgInfo("logStep", false))) {
        bool success;
        return evision_from_as_map<Ptr<cv::ml::ParamGrid>>(env, _self_, self, "\"ML.ParamGrid\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_ml_ParamGrid_get_maxVal(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::ParamGrid>* self_ptr = 0;
    if (!evision_ml_ParamGrid_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::ParamGrid>` from `self`: mismatched type or invalid resource?");
    }

    Ptr<cv::ml::ParamGrid> &self2 = *self_ptr;
    cv::ml::ParamGrid* _self_ = dynamic_cast<cv::ml::ParamGrid*>(self2.get());
    return evision_from(env, _self_->maxVal);
}

static ERL_NIF_TERM evision_ml_ParamGrid_set_maxVal(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::ParamGrid>* self_ptr = 0;

    if (!evision_ml_ParamGrid_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::ParamGrid>` from `self`: mismatched type or invalid resource?");
    }

    Ptr<cv::ml::ParamGrid> &_self_ = *self_ptr;

    std::map<std::string, ERL_NIF_TERM> erl_terms;
    evision::nif::parse_arg(env, 1, argv, erl_terms);

    if (evision_to_safe(env, evision_get_kw(env, erl_terms, "maxVal"), _self_->maxVal, ArgInfo("maxVal", false))) {
        bool success;
        return evision_from_as_map<Ptr<cv::ml::ParamGrid>>(env, _self_, self, "\"ML.ParamGrid\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_ml_ParamGrid_get_minVal(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::ParamGrid>* self_ptr = 0;
    if (!evision_ml_ParamGrid_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::ParamGrid>` from `self`: mismatched type or invalid resource?");
    }

    Ptr<cv::ml::ParamGrid> &self2 = *self_ptr;
    cv::ml::ParamGrid* _self_ = dynamic_cast<cv::ml::ParamGrid*>(self2.get());
    return evision_from(env, _self_->minVal);
}

static ERL_NIF_TERM evision_ml_ParamGrid_set_minVal(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::ParamGrid>* self_ptr = 0;

    if (!evision_ml_ParamGrid_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::ParamGrid>` from `self`: mismatched type or invalid resource?");
    }

    Ptr<cv::ml::ParamGrid> &_self_ = *self_ptr;

    std::map<std::string, ERL_NIF_TERM> erl_terms;
    evision::nif::parse_arg(env, 1, argv, erl_terms);

    if (evision_to_safe(env, evision_get_kw(env, erl_terms, "minVal"), _self_->minVal, ArgInfo("minVal", false))) {
        bool success;
        return evision_from_as_map<Ptr<cv::ml::ParamGrid>>(env, _self_, self, "\"ML.ParamGrid\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}


// Methods (ml_ParamGrid)

static ERL_NIF_TERM evision_cv_ml_ml_ParamGrid_create_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    double minVal=0.;
    double maxVal=0.;
    double logstep=1.;
    Ptr<ParamGrid> retval;

    // const char* keywords[] = { "minVal", "maxVal", "logstep", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "minVal"), minVal, ArgInfo("minVal", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxVal"), maxVal, ArgInfo("maxVal", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "logstep"), logstep, ArgInfo("logstep", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::ml::ParamGrid::create(minVal, maxVal, logstep), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (ml_ParamGrid)

template<>
struct Evision_Converter< Ptr<cv::ml::ParamGrid> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::ml::ParamGrid>& r)
    {
        return evision_ml_ParamGrid_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::ml::ParamGrid>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::ml::ParamGrid> * dst_ = nullptr;
        if (evision_ml_ParamGrid_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::ml::ParamGrid> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// ml_RTrees (Generic)
//================================================================================

// GetSet (ml_RTrees)



// Methods (ml_RTrees)

static ERL_NIF_TERM evision_cv_ml_ml_RTrees_calcError(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::RTrees> * self1 = 0;
    if (!evision_ml_RTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::RTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::RTrees> _self_ = *(self1);

    {
    Ptr<TrainData> data;
    bool test=0;
    Mat resp;
    float retval;

    // const char* keywords[] = { "data", "test", "resp", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "data"), data, ArgInfo("data", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "test"), test, ArgInfo("test", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "resp"), resp, ArgInfo("resp", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->calcError(data, test, resp), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, resp));
        }
    }

    }
    

    {
    Ptr<TrainData> data;
    bool test=0;
    UMat resp;
    float retval;

    // const char* keywords[] = { "data", "test", "resp", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "data"), data, ArgInfo("data", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "test"), test, ArgInfo("test", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "resp"), resp, ArgInfo("resp", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->calcError(data, test, resp), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, resp));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_RTrees_clear(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::RTrees> * self1 = 0;
    if (!evision_ml_RTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::RTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::RTrees> _self_ = *(self1);

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::clear(), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.RTrees", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_RTrees_create_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    Ptr<RTrees> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::ml::RTrees::create(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_RTrees_empty(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::RTrees> * self1 = 0;
    if (!evision_ml_RTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::RTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::RTrees> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->empty(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_RTrees_getActiveVarCount(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::RTrees> * self1 = 0;
    if (!evision_ml_RTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::RTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::RTrees> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getActiveVarCount(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_RTrees_getCVFolds(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::RTrees> * self1 = 0;
    if (!evision_ml_RTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::RTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::RTrees> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getCVFolds(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_RTrees_getCalculateVarImportance(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::RTrees> * self1 = 0;
    if (!evision_ml_RTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::RTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::RTrees> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getCalculateVarImportance(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_RTrees_getDefaultName(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::RTrees> * self1 = 0;
    if (!evision_ml_RTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::RTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::RTrees> _self_ = *(self1);
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->Algorithm::getDefaultName(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_RTrees_getMaxCategories(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::RTrees> * self1 = 0;
    if (!evision_ml_RTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::RTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::RTrees> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getMaxCategories(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_RTrees_getMaxDepth(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::RTrees> * self1 = 0;
    if (!evision_ml_RTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::RTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::RTrees> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getMaxDepth(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_RTrees_getMinSampleCount(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::RTrees> * self1 = 0;
    if (!evision_ml_RTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::RTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::RTrees> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getMinSampleCount(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_RTrees_getOOBError(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::RTrees> * self1 = 0;
    if (!evision_ml_RTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::RTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::RTrees> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getOOBError(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_RTrees_getPriors(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::RTrees> * self1 = 0;
    if (!evision_ml_RTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::RTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::RTrees> _self_ = *(self1);
    cv::Mat retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getPriors(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_RTrees_getRegressionAccuracy(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::RTrees> * self1 = 0;
    if (!evision_ml_RTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::RTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::RTrees> _self_ = *(self1);
    float retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getRegressionAccuracy(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_RTrees_getTermCriteria(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::RTrees> * self1 = 0;
    if (!evision_ml_RTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::RTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::RTrees> _self_ = *(self1);
    TermCriteria retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getTermCriteria(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_RTrees_getTruncatePrunedTree(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::RTrees> * self1 = 0;
    if (!evision_ml_RTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::RTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::RTrees> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getTruncatePrunedTree(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_RTrees_getUse1SERule(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::RTrees> * self1 = 0;
    if (!evision_ml_RTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::RTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::RTrees> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getUse1SERule(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_RTrees_getUseSurrogates(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::RTrees> * self1 = 0;
    if (!evision_ml_RTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::RTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::RTrees> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getUseSurrogates(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_RTrees_getVarCount(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::RTrees> * self1 = 0;
    if (!evision_ml_RTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::RTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::RTrees> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getVarCount(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_RTrees_getVarImportance(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::RTrees> * self1 = 0;
    if (!evision_ml_RTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::RTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::RTrees> _self_ = *(self1);
    Mat retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getVarImportance(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_RTrees_getVotes(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::RTrees> * self1 = 0;
    if (!evision_ml_RTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::RTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::RTrees> _self_ = *(self1);

    {
    Mat samples;
    Mat results;
    int flags=0;

    // const char* keywords[] = { "samples", "flags", "results", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "results"), results, ArgInfo("results", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->getVotes(samples, results, flags), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, results);
        }
    }

    }
    

    {
    UMat samples;
    UMat results;
    int flags=0;

    // const char* keywords[] = { "samples", "flags", "results", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "results"), results, ArgInfo("results", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->getVotes(samples, results, flags), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, results);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_RTrees_isClassifier(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::RTrees> * self1 = 0;
    if (!evision_ml_RTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::RTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::RTrees> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->isClassifier(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_RTrees_isTrained(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::RTrees> * self1 = 0;
    if (!evision_ml_RTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::RTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::RTrees> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->isTrained(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_RTrees_load_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    String filepath;
    String nodeName = String();
    Ptr<RTrees> retval;

    // const char* keywords[] = { "filepath", "nodeName", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filepath"), filepath, ArgInfo("filepath", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nodeName"), nodeName, ArgInfo("nodeName", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::ml::RTrees::load(filepath, nodeName), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_RTrees_predict(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::RTrees> * self1 = 0;
    if (!evision_ml_RTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::RTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::RTrees> _self_ = *(self1);

    {
    Mat samples;
    Mat results;
    int flags=0;
    float retval;

    // const char* keywords[] = { "samples", "results", "flags", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "results"), results, ArgInfo("results", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->predict(samples, results, flags), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, results));
        }
    }

    }
    

    {
    UMat samples;
    UMat results;
    int flags=0;
    float retval;

    // const char* keywords[] = { "samples", "results", "flags", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "results"), results, ArgInfo("results", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->predict(samples, results, flags), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, results));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_RTrees_read(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::RTrees> * self1 = 0;
    if (!evision_ml_RTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::RTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::RTrees> _self_ = *(self1);
    FileNode fn_;

    // const char* keywords[] = { "fn_", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fn_"), fn_, ArgInfo("fn_", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::read(fn_), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.RTrees", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_RTrees_save(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::RTrees> * self1 = 0;
    if (!evision_ml_RTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::RTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::RTrees> _self_ = *(self1);
    String filename;

    // const char* keywords[] = { "filename", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::save(filename), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.RTrees", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_RTrees_setActiveVarCount(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::RTrees> * self1 = 0;
    if (!evision_ml_RTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::RTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::RTrees> _self_ = *(self1);
    int val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setActiveVarCount(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.RTrees", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_RTrees_setCVFolds(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::RTrees> * self1 = 0;
    if (!evision_ml_RTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::RTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::RTrees> _self_ = *(self1);
    int val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setCVFolds(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.RTrees", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_RTrees_setCalculateVarImportance(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::RTrees> * self1 = 0;
    if (!evision_ml_RTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::RTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::RTrees> _self_ = *(self1);
    bool val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setCalculateVarImportance(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.RTrees", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_RTrees_setMaxCategories(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::RTrees> * self1 = 0;
    if (!evision_ml_RTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::RTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::RTrees> _self_ = *(self1);
    int val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setMaxCategories(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.RTrees", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_RTrees_setMaxDepth(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::RTrees> * self1 = 0;
    if (!evision_ml_RTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::RTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::RTrees> _self_ = *(self1);
    int val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setMaxDepth(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.RTrees", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_RTrees_setMinSampleCount(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::RTrees> * self1 = 0;
    if (!evision_ml_RTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::RTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::RTrees> _self_ = *(self1);
    int val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setMinSampleCount(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.RTrees", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_RTrees_setPriors(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::RTrees> * self1 = 0;
    if (!evision_ml_RTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::RTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::RTrees> _self_ = *(self1);
    Mat val;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setPriors(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.RTrees", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_RTrees_setRegressionAccuracy(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::RTrees> * self1 = 0;
    if (!evision_ml_RTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::RTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::RTrees> _self_ = *(self1);
    float val=0.f;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setRegressionAccuracy(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.RTrees", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_RTrees_setTermCriteria(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::RTrees> * self1 = 0;
    if (!evision_ml_RTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::RTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::RTrees> _self_ = *(self1);
    TermCriteria val;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setTermCriteria(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.RTrees", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_RTrees_setTruncatePrunedTree(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::RTrees> * self1 = 0;
    if (!evision_ml_RTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::RTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::RTrees> _self_ = *(self1);
    bool val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setTruncatePrunedTree(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.RTrees", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_RTrees_setUse1SERule(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::RTrees> * self1 = 0;
    if (!evision_ml_RTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::RTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::RTrees> _self_ = *(self1);
    bool val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setUse1SERule(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.RTrees", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_RTrees_setUseSurrogates(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::RTrees> * self1 = 0;
    if (!evision_ml_RTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::RTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::RTrees> _self_ = *(self1);
    bool val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setUseSurrogates(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.RTrees", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_RTrees_train(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::RTrees> * self1 = 0;
    if (!evision_ml_RTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::RTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::RTrees> _self_ = *(self1);

    {
    Ptr<TrainData> trainData;
    int flags=0;
    bool retval;

    // const char* keywords[] = { "trainData", "flags", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "trainData"), trainData, ArgInfo("trainData", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->train(trainData, flags), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    Mat samples;
    int layout=0;
    Mat responses;
    bool retval;

    // const char* keywords[] = { "samples", "layout", "responses", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "layout"), layout, ArgInfo("layout", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "responses"), responses, ArgInfo("responses", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->train(samples, layout, responses), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    UMat samples;
    int layout=0;
    UMat responses;
    bool retval;

    // const char* keywords[] = { "samples", "layout", "responses", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "layout"), layout, ArgInfo("layout", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "responses"), responses, ArgInfo("responses", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->train(samples, layout, responses), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_RTrees_write(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::RTrees> * self1 = 0;
    if (!evision_ml_RTrees_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::RTrees>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::RTrees> _self_ = *(self1);
    Ptr<FileStorage> fs;
    String name;

    // const char* keywords[] = { "fs", "name", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fs"), fs, ArgInfo("fs", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "name"), name, ArgInfo("name", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::write(fs, name), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.RTrees", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (ml_RTrees)

template<>
struct Evision_Converter< Ptr<cv::ml::RTrees> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::ml::RTrees>& r)
    {
        return evision_ml_RTrees_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::ml::RTrees>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::ml::RTrees> * dst_ = nullptr;
        if (evision_ml_RTrees_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::ml::RTrees> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// ml_SVM (Generic)
//================================================================================

// GetSet (ml_SVM)



// Methods (ml_SVM)

static ERL_NIF_TERM evision_cv_ml_ml_SVM_calcError(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVM> * self1 = 0;
    if (!evision_ml_SVM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVM> _self_ = *(self1);

    {
    Ptr<TrainData> data;
    bool test=0;
    Mat resp;
    float retval;

    // const char* keywords[] = { "data", "test", "resp", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "data"), data, ArgInfo("data", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "test"), test, ArgInfo("test", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "resp"), resp, ArgInfo("resp", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->calcError(data, test, resp), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, resp));
        }
    }

    }
    

    {
    Ptr<TrainData> data;
    bool test=0;
    UMat resp;
    float retval;

    // const char* keywords[] = { "data", "test", "resp", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "data"), data, ArgInfo("data", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "test"), test, ArgInfo("test", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "resp"), resp, ArgInfo("resp", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->calcError(data, test, resp), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, resp));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_SVM_clear(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVM> * self1 = 0;
    if (!evision_ml_SVM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVM> _self_ = *(self1);

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::clear(), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.SVM", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_SVM_create_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    Ptr<SVM> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::ml::SVM::create(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_SVM_empty(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVM> * self1 = 0;
    if (!evision_ml_SVM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVM> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->empty(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_SVM_getC(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVM> * self1 = 0;
    if (!evision_ml_SVM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVM> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getC(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_SVM_getClassWeights(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVM> * self1 = 0;
    if (!evision_ml_SVM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVM> _self_ = *(self1);
    cv::Mat retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getClassWeights(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_SVM_getCoef0(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVM> * self1 = 0;
    if (!evision_ml_SVM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVM> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getCoef0(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_SVM_getDecisionFunction(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVM> * self1 = 0;
    if (!evision_ml_SVM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVM> _self_ = *(self1);

    {
    int i=0;
    Mat alpha;
    Mat svidx;
    double retval;

    // const char* keywords[] = { "i", "alpha", "svidx", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "i"), i, ArgInfo("i", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "alpha"), alpha, ArgInfo("alpha", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "svidx"), svidx, ArgInfo("svidx", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getDecisionFunction(i, alpha, svidx), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, retval), evision_from(env, alpha), evision_from(env, svidx));
        }
    }

    }
    

    {
    int i=0;
    UMat alpha;
    UMat svidx;
    double retval;

    // const char* keywords[] = { "i", "alpha", "svidx", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "i"), i, ArgInfo("i", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "alpha"), alpha, ArgInfo("alpha", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "svidx"), svidx, ArgInfo("svidx", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getDecisionFunction(i, alpha, svidx), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, retval), evision_from(env, alpha), evision_from(env, svidx));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_SVM_getDefaultGridPtr_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    int param_id=0;
    Ptr<ParamGrid> retval;

    // const char* keywords[] = { "param_id", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "param_id"), param_id, ArgInfo("param_id", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::ml::SVM::getDefaultGridPtr(param_id), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_SVM_getDefaultName(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVM> * self1 = 0;
    if (!evision_ml_SVM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVM> _self_ = *(self1);
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->Algorithm::getDefaultName(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_SVM_getDegree(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVM> * self1 = 0;
    if (!evision_ml_SVM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVM> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getDegree(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_SVM_getGamma(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVM> * self1 = 0;
    if (!evision_ml_SVM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVM> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getGamma(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_SVM_getKernelType(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVM> * self1 = 0;
    if (!evision_ml_SVM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVM> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getKernelType(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_SVM_getNu(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVM> * self1 = 0;
    if (!evision_ml_SVM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVM> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getNu(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_SVM_getP(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVM> * self1 = 0;
    if (!evision_ml_SVM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVM> _self_ = *(self1);
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getP(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_SVM_getSupportVectors(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVM> * self1 = 0;
    if (!evision_ml_SVM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVM> _self_ = *(self1);
    Mat retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getSupportVectors(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_SVM_getTermCriteria(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVM> * self1 = 0;
    if (!evision_ml_SVM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVM> _self_ = *(self1);
    cv::TermCriteria retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getTermCriteria(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_SVM_getType(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVM> * self1 = 0;
    if (!evision_ml_SVM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVM> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getType(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_SVM_getUncompressedSupportVectors(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVM> * self1 = 0;
    if (!evision_ml_SVM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVM> _self_ = *(self1);
    Mat retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getUncompressedSupportVectors(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_SVM_getVarCount(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVM> * self1 = 0;
    if (!evision_ml_SVM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVM> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getVarCount(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_SVM_isClassifier(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVM> * self1 = 0;
    if (!evision_ml_SVM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVM> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->isClassifier(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_SVM_isTrained(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVM> * self1 = 0;
    if (!evision_ml_SVM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVM> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->isTrained(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_SVM_load_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    String filepath;
    Ptr<SVM> retval;

    // const char* keywords[] = { "filepath", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filepath"), filepath, ArgInfo("filepath", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::ml::SVM::load(filepath), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_SVM_predict(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVM> * self1 = 0;
    if (!evision_ml_SVM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVM> _self_ = *(self1);

    {
    Mat samples;
    Mat results;
    int flags=0;
    float retval;

    // const char* keywords[] = { "samples", "results", "flags", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "results"), results, ArgInfo("results", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->predict(samples, results, flags), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, results));
        }
    }

    }
    

    {
    UMat samples;
    UMat results;
    int flags=0;
    float retval;

    // const char* keywords[] = { "samples", "results", "flags", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "results"), results, ArgInfo("results", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->predict(samples, results, flags), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, results));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_SVM_read(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVM> * self1 = 0;
    if (!evision_ml_SVM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVM> _self_ = *(self1);
    FileNode fn_;

    // const char* keywords[] = { "fn_", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fn_"), fn_, ArgInfo("fn_", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::read(fn_), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.SVM", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_SVM_save(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVM> * self1 = 0;
    if (!evision_ml_SVM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVM> _self_ = *(self1);
    String filename;

    // const char* keywords[] = { "filename", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::save(filename), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.SVM", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_SVM_setC(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVM> * self1 = 0;
    if (!evision_ml_SVM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVM> _self_ = *(self1);
    double val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setC(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.SVM", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_SVM_setClassWeights(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVM> * self1 = 0;
    if (!evision_ml_SVM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVM> _self_ = *(self1);
    Mat val;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setClassWeights(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.SVM", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_SVM_setCoef0(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVM> * self1 = 0;
    if (!evision_ml_SVM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVM> _self_ = *(self1);
    double val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setCoef0(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.SVM", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_SVM_setDegree(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVM> * self1 = 0;
    if (!evision_ml_SVM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVM> _self_ = *(self1);
    double val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setDegree(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.SVM", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_SVM_setGamma(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVM> * self1 = 0;
    if (!evision_ml_SVM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVM> _self_ = *(self1);
    double val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setGamma(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.SVM", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_SVM_setKernel(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVM> * self1 = 0;
    if (!evision_ml_SVM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVM> _self_ = *(self1);
    int kernelType=0;

    // const char* keywords[] = { "kernelType", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "kernelType"), kernelType, ArgInfo("kernelType", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setKernel(kernelType), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.SVM", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_SVM_setNu(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVM> * self1 = 0;
    if (!evision_ml_SVM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVM> _self_ = *(self1);
    double val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setNu(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.SVM", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_SVM_setP(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVM> * self1 = 0;
    if (!evision_ml_SVM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVM> _self_ = *(self1);
    double val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setP(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.SVM", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_SVM_setTermCriteria(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVM> * self1 = 0;
    if (!evision_ml_SVM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVM> _self_ = *(self1);
    TermCriteria val;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setTermCriteria(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.SVM", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_SVM_setType(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVM> * self1 = 0;
    if (!evision_ml_SVM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVM> _self_ = *(self1);
    int val=0;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setType(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.SVM", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_SVM_train(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVM> * self1 = 0;
    if (!evision_ml_SVM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVM> _self_ = *(self1);

    {
    Ptr<TrainData> trainData;
    int flags=0;
    bool retval;

    // const char* keywords[] = { "trainData", "flags", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "trainData"), trainData, ArgInfo("trainData", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->train(trainData, flags), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    Mat samples;
    int layout=0;
    Mat responses;
    bool retval;

    // const char* keywords[] = { "samples", "layout", "responses", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "layout"), layout, ArgInfo("layout", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "responses"), responses, ArgInfo("responses", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->train(samples, layout, responses), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    UMat samples;
    int layout=0;
    UMat responses;
    bool retval;

    // const char* keywords[] = { "samples", "layout", "responses", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "layout"), layout, ArgInfo("layout", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "responses"), responses, ArgInfo("responses", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->train(samples, layout, responses), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_SVM_trainAuto(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVM> * self1 = 0;
    if (!evision_ml_SVM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVM> _self_ = *(self1);

    {
    Mat samples;
    int layout=0;
    Mat responses;
    int kFold=10;
    Ptr<ParamGrid> Cgrid=SVM::getDefaultGridPtr(SVM::C);
    Ptr<ParamGrid> gammaGrid=SVM::getDefaultGridPtr(SVM::GAMMA);
    Ptr<ParamGrid> pGrid=SVM::getDefaultGridPtr(SVM::P);
    Ptr<ParamGrid> nuGrid=SVM::getDefaultGridPtr(SVM::NU);
    Ptr<ParamGrid> coeffGrid=SVM::getDefaultGridPtr(SVM::COEF);
    Ptr<ParamGrid> degreeGrid=SVM::getDefaultGridPtr(SVM::DEGREE);
    bool balanced=false;
    bool retval;

    // const char* keywords[] = { "samples", "layout", "responses", "kFold", "Cgrid", "gammaGrid", "pGrid", "nuGrid", "coeffGrid", "degreeGrid", "balanced", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "layout"), layout, ArgInfo("layout", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "responses"), responses, ArgInfo("responses", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "kFold"), kFold, ArgInfo("kFold", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cgrid"), Cgrid, ArgInfo("Cgrid", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "gammaGrid"), gammaGrid, ArgInfo("gammaGrid", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pGrid"), pGrid, ArgInfo("pGrid", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nuGrid"), nuGrid, ArgInfo("nuGrid", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "coeffGrid"), coeffGrid, ArgInfo("coeffGrid", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "degreeGrid"), degreeGrid, ArgInfo("degreeGrid", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "balanced"), balanced, ArgInfo("balanced", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->trainAuto(samples, layout, responses, kFold, Cgrid, gammaGrid, pGrid, nuGrid, coeffGrid, degreeGrid, balanced), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    UMat samples;
    int layout=0;
    UMat responses;
    int kFold=10;
    Ptr<ParamGrid> Cgrid=SVM::getDefaultGridPtr(SVM::C);
    Ptr<ParamGrid> gammaGrid=SVM::getDefaultGridPtr(SVM::GAMMA);
    Ptr<ParamGrid> pGrid=SVM::getDefaultGridPtr(SVM::P);
    Ptr<ParamGrid> nuGrid=SVM::getDefaultGridPtr(SVM::NU);
    Ptr<ParamGrid> coeffGrid=SVM::getDefaultGridPtr(SVM::COEF);
    Ptr<ParamGrid> degreeGrid=SVM::getDefaultGridPtr(SVM::DEGREE);
    bool balanced=false;
    bool retval;

    // const char* keywords[] = { "samples", "layout", "responses", "kFold", "Cgrid", "gammaGrid", "pGrid", "nuGrid", "coeffGrid", "degreeGrid", "balanced", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "layout"), layout, ArgInfo("layout", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "responses"), responses, ArgInfo("responses", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "kFold"), kFold, ArgInfo("kFold", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cgrid"), Cgrid, ArgInfo("Cgrid", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "gammaGrid"), gammaGrid, ArgInfo("gammaGrid", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pGrid"), pGrid, ArgInfo("pGrid", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nuGrid"), nuGrid, ArgInfo("nuGrid", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "coeffGrid"), coeffGrid, ArgInfo("coeffGrid", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "degreeGrid"), degreeGrid, ArgInfo("degreeGrid", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "balanced"), balanced, ArgInfo("balanced", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->trainAuto(samples, layout, responses, kFold, Cgrid, gammaGrid, pGrid, nuGrid, coeffGrid, degreeGrid, balanced), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_SVM_write(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVM> * self1 = 0;
    if (!evision_ml_SVM_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVM>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVM> _self_ = *(self1);
    Ptr<FileStorage> fs;
    String name;

    // const char* keywords[] = { "fs", "name", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fs"), fs, ArgInfo("fs", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "name"), name, ArgInfo("name", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::write(fs, name), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.SVM", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (ml_SVM)

template<>
struct Evision_Converter< Ptr<cv::ml::SVM> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::ml::SVM>& r)
    {
        return evision_ml_SVM_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::ml::SVM>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::ml::SVM> * dst_ = nullptr;
        if (evision_ml_SVM_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::ml::SVM> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// ml_SVMSGD (Generic)
//================================================================================

// GetSet (ml_SVMSGD)



// Methods (ml_SVMSGD)

static ERL_NIF_TERM evision_cv_ml_ml_SVMSGD_calcError(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVMSGD> * self1 = 0;
    if (!evision_ml_SVMSGD_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVMSGD>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVMSGD> _self_ = *(self1);

    {
    Ptr<TrainData> data;
    bool test=0;
    Mat resp;
    float retval;

    // const char* keywords[] = { "data", "test", "resp", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "data"), data, ArgInfo("data", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "test"), test, ArgInfo("test", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "resp"), resp, ArgInfo("resp", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->calcError(data, test, resp), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, resp));
        }
    }

    }
    

    {
    Ptr<TrainData> data;
    bool test=0;
    UMat resp;
    float retval;

    // const char* keywords[] = { "data", "test", "resp", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "data"), data, ArgInfo("data", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "test"), test, ArgInfo("test", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "resp"), resp, ArgInfo("resp", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->calcError(data, test, resp), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, resp));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_SVMSGD_clear(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVMSGD> * self1 = 0;
    if (!evision_ml_SVMSGD_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVMSGD>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVMSGD> _self_ = *(self1);

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::clear(), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.SVMSGD", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_SVMSGD_create_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    Ptr<SVMSGD> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::ml::SVMSGD::create(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_SVMSGD_empty(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVMSGD> * self1 = 0;
    if (!evision_ml_SVMSGD_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVMSGD>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVMSGD> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->empty(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_SVMSGD_getDefaultName(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVMSGD> * self1 = 0;
    if (!evision_ml_SVMSGD_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVMSGD>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVMSGD> _self_ = *(self1);
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->Algorithm::getDefaultName(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_SVMSGD_getInitialStepSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVMSGD> * self1 = 0;
    if (!evision_ml_SVMSGD_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVMSGD>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVMSGD> _self_ = *(self1);
    float retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getInitialStepSize(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_SVMSGD_getMarginRegularization(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVMSGD> * self1 = 0;
    if (!evision_ml_SVMSGD_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVMSGD>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVMSGD> _self_ = *(self1);
    float retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getMarginRegularization(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_SVMSGD_getMarginType(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVMSGD> * self1 = 0;
    if (!evision_ml_SVMSGD_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVMSGD>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVMSGD> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getMarginType(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_SVMSGD_getShift(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVMSGD> * self1 = 0;
    if (!evision_ml_SVMSGD_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVMSGD>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVMSGD> _self_ = *(self1);
    float retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getShift(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_SVMSGD_getStepDecreasingPower(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVMSGD> * self1 = 0;
    if (!evision_ml_SVMSGD_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVMSGD>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVMSGD> _self_ = *(self1);
    float retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getStepDecreasingPower(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_SVMSGD_getSvmsgdType(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVMSGD> * self1 = 0;
    if (!evision_ml_SVMSGD_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVMSGD>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVMSGD> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getSvmsgdType(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_SVMSGD_getTermCriteria(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVMSGD> * self1 = 0;
    if (!evision_ml_SVMSGD_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVMSGD>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVMSGD> _self_ = *(self1);
    TermCriteria retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getTermCriteria(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_SVMSGD_getVarCount(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVMSGD> * self1 = 0;
    if (!evision_ml_SVMSGD_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVMSGD>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVMSGD> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getVarCount(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_SVMSGD_getWeights(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVMSGD> * self1 = 0;
    if (!evision_ml_SVMSGD_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVMSGD>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVMSGD> _self_ = *(self1);
    Mat retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getWeights(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_SVMSGD_isClassifier(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVMSGD> * self1 = 0;
    if (!evision_ml_SVMSGD_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVMSGD>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVMSGD> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->isClassifier(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_SVMSGD_isTrained(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVMSGD> * self1 = 0;
    if (!evision_ml_SVMSGD_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVMSGD>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVMSGD> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->isTrained(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_SVMSGD_load_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    String filepath;
    String nodeName = String();
    Ptr<SVMSGD> retval;

    // const char* keywords[] = { "filepath", "nodeName", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filepath"), filepath, ArgInfo("filepath", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nodeName"), nodeName, ArgInfo("nodeName", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::ml::SVMSGD::load(filepath, nodeName), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_SVMSGD_predict(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVMSGD> * self1 = 0;
    if (!evision_ml_SVMSGD_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVMSGD>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVMSGD> _self_ = *(self1);

    {
    Mat samples;
    Mat results;
    int flags=0;
    float retval;

    // const char* keywords[] = { "samples", "results", "flags", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "results"), results, ArgInfo("results", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->predict(samples, results, flags), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, results));
        }
    }

    }
    

    {
    UMat samples;
    UMat results;
    int flags=0;
    float retval;

    // const char* keywords[] = { "samples", "results", "flags", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "results"), results, ArgInfo("results", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->predict(samples, results, flags), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, results));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_SVMSGD_read(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVMSGD> * self1 = 0;
    if (!evision_ml_SVMSGD_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVMSGD>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVMSGD> _self_ = *(self1);
    FileNode fn_;

    // const char* keywords[] = { "fn_", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fn_"), fn_, ArgInfo("fn_", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::read(fn_), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.SVMSGD", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_SVMSGD_save(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVMSGD> * self1 = 0;
    if (!evision_ml_SVMSGD_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVMSGD>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVMSGD> _self_ = *(self1);
    String filename;

    // const char* keywords[] = { "filename", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::save(filename), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.SVMSGD", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_SVMSGD_setInitialStepSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVMSGD> * self1 = 0;
    if (!evision_ml_SVMSGD_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVMSGD>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVMSGD> _self_ = *(self1);
    float InitialStepSize=0.f;

    // const char* keywords[] = { "InitialStepSize", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "initialStepSize"), InitialStepSize, ArgInfo("InitialStepSize", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setInitialStepSize(InitialStepSize), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.SVMSGD", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_SVMSGD_setMarginRegularization(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVMSGD> * self1 = 0;
    if (!evision_ml_SVMSGD_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVMSGD>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVMSGD> _self_ = *(self1);
    float marginRegularization=0.f;

    // const char* keywords[] = { "marginRegularization", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "marginRegularization"), marginRegularization, ArgInfo("marginRegularization", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setMarginRegularization(marginRegularization), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.SVMSGD", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_SVMSGD_setMarginType(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVMSGD> * self1 = 0;
    if (!evision_ml_SVMSGD_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVMSGD>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVMSGD> _self_ = *(self1);
    int marginType=0;

    // const char* keywords[] = { "marginType", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "marginType"), marginType, ArgInfo("marginType", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setMarginType(marginType), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.SVMSGD", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_SVMSGD_setOptimalParameters(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVMSGD> * self1 = 0;
    if (!evision_ml_SVMSGD_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVMSGD>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVMSGD> _self_ = *(self1);
    int svmsgdType=SVMSGD::ASGD;
    int marginType=SVMSGD::SOFT_MARGIN;

    // const char* keywords[] = { "svmsgdType", "marginType", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "svmsgdType"), svmsgdType, ArgInfo("svmsgdType", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "marginType"), marginType, ArgInfo("marginType", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setOptimalParameters(svmsgdType, marginType), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.SVMSGD", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_SVMSGD_setStepDecreasingPower(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVMSGD> * self1 = 0;
    if (!evision_ml_SVMSGD_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVMSGD>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVMSGD> _self_ = *(self1);
    float stepDecreasingPower=0.f;

    // const char* keywords[] = { "stepDecreasingPower", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "stepDecreasingPower"), stepDecreasingPower, ArgInfo("stepDecreasingPower", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setStepDecreasingPower(stepDecreasingPower), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.SVMSGD", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_SVMSGD_setSvmsgdType(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVMSGD> * self1 = 0;
    if (!evision_ml_SVMSGD_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVMSGD>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVMSGD> _self_ = *(self1);
    int svmsgdType=0;

    // const char* keywords[] = { "svmsgdType", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "svmsgdType"), svmsgdType, ArgInfo("svmsgdType", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setSvmsgdType(svmsgdType), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.SVMSGD", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_SVMSGD_setTermCriteria(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVMSGD> * self1 = 0;
    if (!evision_ml_SVMSGD_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVMSGD>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVMSGD> _self_ = *(self1);
    TermCriteria val;

    // const char* keywords[] = { "val", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setTermCriteria(val), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.SVMSGD", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_SVMSGD_train(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVMSGD> * self1 = 0;
    if (!evision_ml_SVMSGD_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVMSGD>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVMSGD> _self_ = *(self1);

    {
    Ptr<TrainData> trainData;
    int flags=0;
    bool retval;

    // const char* keywords[] = { "trainData", "flags", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "trainData"), trainData, ArgInfo("trainData", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->train(trainData, flags), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    Mat samples;
    int layout=0;
    Mat responses;
    bool retval;

    // const char* keywords[] = { "samples", "layout", "responses", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "layout"), layout, ArgInfo("layout", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "responses"), responses, ArgInfo("responses", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->train(samples, layout, responses), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    UMat samples;
    int layout=0;
    UMat responses;
    bool retval;

    // const char* keywords[] = { "samples", "layout", "responses", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "layout"), layout, ArgInfo("layout", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "responses"), responses, ArgInfo("responses", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->train(samples, layout, responses), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_SVMSGD_write(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::SVMSGD> * self1 = 0;
    if (!evision_ml_SVMSGD_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::SVMSGD>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::SVMSGD> _self_ = *(self1);
    Ptr<FileStorage> fs;
    String name;

    // const char* keywords[] = { "fs", "name", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fs"), fs, ArgInfo("fs", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "name"), name, ArgInfo("name", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::write(fs, name), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.SVMSGD", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (ml_SVMSGD)

template<>
struct Evision_Converter< Ptr<cv::ml::SVMSGD> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::ml::SVMSGD>& r)
    {
        return evision_ml_SVMSGD_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::ml::SVMSGD>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::ml::SVMSGD> * dst_ = nullptr;
        if (evision_ml_SVMSGD_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::ml::SVMSGD> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// ml_StatModel (Generic)
//================================================================================

// GetSet (ml_StatModel)



// Methods (ml_StatModel)

static ERL_NIF_TERM evision_cv_ml_ml_StatModel_calcError(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::StatModel> * self1 = 0;
    if (!evision_ml_StatModel_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::StatModel>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::StatModel> _self_ = *(self1);

    {
    Ptr<TrainData> data;
    bool test=0;
    Mat resp;
    float retval;

    // const char* keywords[] = { "data", "test", "resp", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "data"), data, ArgInfo("data", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "test"), test, ArgInfo("test", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "resp"), resp, ArgInfo("resp", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->calcError(data, test, resp), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, resp));
        }
    }

    }
    

    {
    Ptr<TrainData> data;
    bool test=0;
    UMat resp;
    float retval;

    // const char* keywords[] = { "data", "test", "resp", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "data"), data, ArgInfo("data", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "test"), test, ArgInfo("test", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "resp"), resp, ArgInfo("resp", 1)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->calcError(data, test, resp), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, resp));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_StatModel_clear(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::StatModel> * self1 = 0;
    if (!evision_ml_StatModel_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::StatModel>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::StatModel> _self_ = *(self1);

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::clear(), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.StatModel", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_StatModel_empty(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::StatModel> * self1 = 0;
    if (!evision_ml_StatModel_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::StatModel>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::StatModel> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->empty(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_StatModel_getDefaultName(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::StatModel> * self1 = 0;
    if (!evision_ml_StatModel_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::StatModel>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::StatModel> _self_ = *(self1);
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->Algorithm::getDefaultName(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_StatModel_getVarCount(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::StatModel> * self1 = 0;
    if (!evision_ml_StatModel_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::StatModel>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::StatModel> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getVarCount(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_StatModel_isClassifier(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::StatModel> * self1 = 0;
    if (!evision_ml_StatModel_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::StatModel>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::StatModel> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->isClassifier(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_StatModel_isTrained(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::StatModel> * self1 = 0;
    if (!evision_ml_StatModel_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::StatModel>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::StatModel> _self_ = *(self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->isTrained(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_StatModel_predict(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::StatModel> * self1 = 0;
    if (!evision_ml_StatModel_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::StatModel>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::StatModel> _self_ = *(self1);

    {
    Mat samples;
    Mat results;
    int flags=0;
    float retval;

    // const char* keywords[] = { "samples", "results", "flags", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "results"), results, ArgInfo("results", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->predict(samples, results, flags), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, results));
        }
    }

    }
    

    {
    UMat samples;
    UMat results;
    int flags=0;
    float retval;

    // const char* keywords[] = { "samples", "results", "flags", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "results"), results, ArgInfo("results", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->predict(samples, results, flags), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, results));
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_StatModel_read(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::StatModel> * self1 = 0;
    if (!evision_ml_StatModel_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::StatModel>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::StatModel> _self_ = *(self1);
    FileNode fn_;

    // const char* keywords[] = { "fn_", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fn_"), fn_, ArgInfo("fn_", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::read(fn_), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.StatModel", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_StatModel_save(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::StatModel> * self1 = 0;
    if (!evision_ml_StatModel_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::StatModel>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::StatModel> _self_ = *(self1);
    String filename;

    // const char* keywords[] = { "filename", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::save(filename), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.StatModel", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_StatModel_train(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::StatModel> * self1 = 0;
    if (!evision_ml_StatModel_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::StatModel>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::StatModel> _self_ = *(self1);

    {
    Ptr<TrainData> trainData;
    int flags=0;
    bool retval;

    // const char* keywords[] = { "trainData", "flags", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "trainData"), trainData, ArgInfo("trainData", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->train(trainData, flags), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    Mat samples;
    int layout=0;
    Mat responses;
    bool retval;

    // const char* keywords[] = { "samples", "layout", "responses", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "layout"), layout, ArgInfo("layout", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "responses"), responses, ArgInfo("responses", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->train(samples, layout, responses), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    UMat samples;
    int layout=0;
    UMat responses;
    bool retval;

    // const char* keywords[] = { "samples", "layout", "responses", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "layout"), layout, ArgInfo("layout", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "responses"), responses, ArgInfo("responses", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->train(samples, layout, responses), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_StatModel_write(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::StatModel> * self1 = 0;
    if (!evision_ml_StatModel_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::StatModel>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::StatModel> _self_ = *(self1);
    Ptr<FileStorage> fs;
    String name;

    // const char* keywords[] = { "fs", "name", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "fs"), fs, ArgInfo("fs", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "name"), name, ArgInfo("name", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->Algorithm::write(fs, name), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.StatModel", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (ml_StatModel)

template<>
struct Evision_Converter< Ptr<cv::ml::StatModel> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::ml::StatModel>& r)
    {
        return evision_ml_StatModel_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::ml::StatModel>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::ml::StatModel> * dst_ = nullptr;
        if (evision_ml_StatModel_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::ml::StatModel> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// ml_TrainData (Generic)
//================================================================================

// GetSet (ml_TrainData)



// Methods (ml_TrainData)

static ERL_NIF_TERM evision_cv_ml_ml_TrainData_create_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    {
    Mat samples;
    int layout=0;
    Mat responses;
    Mat varIdx;
    Mat sampleIdx;
    Mat sampleWeights;
    Mat varType;
    Ptr<TrainData> retval;

    // const char* keywords[] = { "samples", "layout", "responses", "varIdx", "sampleIdx", "sampleWeights", "varType", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "layout"), layout, ArgInfo("layout", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "responses"), responses, ArgInfo("responses", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "varIdx"), varIdx, ArgInfo("varIdx", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sampleIdx"), sampleIdx, ArgInfo("sampleIdx", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sampleWeights"), sampleWeights, ArgInfo("sampleWeights", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "varType"), varType, ArgInfo("varType", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::ml::TrainData::create(samples, layout, responses, varIdx, sampleIdx, sampleWeights, varType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    UMat samples;
    int layout=0;
    UMat responses;
    UMat varIdx;
    UMat sampleIdx;
    UMat sampleWeights;
    UMat varType;
    Ptr<TrainData> retval;

    // const char* keywords[] = { "samples", "layout", "responses", "varIdx", "sampleIdx", "sampleWeights", "varType", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "layout"), layout, ArgInfo("layout", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "responses"), responses, ArgInfo("responses", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "varIdx"), varIdx, ArgInfo("varIdx", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sampleIdx"), sampleIdx, ArgInfo("sampleIdx", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sampleWeights"), sampleWeights, ArgInfo("sampleWeights", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "varType"), varType, ArgInfo("varType", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::ml::TrainData::create(samples, layout, responses, varIdx, sampleIdx, sampleWeights, varType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_TrainData_getCatCount(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!evision_ml_TrainData_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::TrainData>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    int vi=0;
    int retval;

    // const char* keywords[] = { "vi", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "vi"), vi, ArgInfo("vi", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getCatCount(vi), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_TrainData_getCatMap(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!evision_ml_TrainData_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::TrainData>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    Mat retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getCatMap(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_TrainData_getCatOfs(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!evision_ml_TrainData_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::TrainData>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    Mat retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getCatOfs(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_TrainData_getClassLabels(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!evision_ml_TrainData_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::TrainData>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    Mat retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getClassLabels(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_TrainData_getDefaultSubstValues(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!evision_ml_TrainData_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::TrainData>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    Mat retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getDefaultSubstValues(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_TrainData_getLayout(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!evision_ml_TrainData_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::TrainData>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getLayout(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_TrainData_getMissing(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!evision_ml_TrainData_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::TrainData>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    Mat retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getMissing(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_TrainData_getNAllVars(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!evision_ml_TrainData_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::TrainData>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getNAllVars(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_TrainData_getNSamples(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!evision_ml_TrainData_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::TrainData>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getNSamples(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_TrainData_getNTestSamples(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!evision_ml_TrainData_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::TrainData>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getNTestSamples(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_TrainData_getNTrainSamples(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!evision_ml_TrainData_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::TrainData>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getNTrainSamples(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_TrainData_getNVars(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!evision_ml_TrainData_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::TrainData>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getNVars(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_TrainData_getNames(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!evision_ml_TrainData_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::TrainData>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    vector_String names;

    // const char* keywords[] = { "names", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "names"), names, ArgInfo("names", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->getNames(names), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.TrainData", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_TrainData_getNormCatResponses(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!evision_ml_TrainData_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::TrainData>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    Mat retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getNormCatResponses(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_TrainData_getResponseType(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!evision_ml_TrainData_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::TrainData>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getResponseType(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_TrainData_getResponses(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!evision_ml_TrainData_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::TrainData>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    Mat retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getResponses(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_TrainData_getSample(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!evision_ml_TrainData_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::TrainData>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::TrainData> _self_ = *(self1);

    {
    Mat varIdx;
    int sidx=0;
    float buf=0.f;

    // const char* keywords[] = { "varIdx", "sidx", "buf", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "varIdx"), varIdx, ArgInfo("varIdx", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sidx"), sidx, ArgInfo("sidx", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "buf"), buf, ArgInfo("buf", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->getSample(varIdx, sidx, &buf), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.TrainData", success);
        }
    }

    }
    

    {
    UMat varIdx;
    int sidx=0;
    float buf=0.f;

    // const char* keywords[] = { "varIdx", "sidx", "buf", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "varIdx"), varIdx, ArgInfo("varIdx", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sidx"), sidx, ArgInfo("sidx", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "buf"), buf, ArgInfo("buf", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->getSample(varIdx, sidx, &buf), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.TrainData", success);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_TrainData_getSampleWeights(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!evision_ml_TrainData_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::TrainData>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    Mat retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getSampleWeights(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_TrainData_getSamples(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!evision_ml_TrainData_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::TrainData>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    Mat retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getSamples(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_TrainData_getSubMatrix_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    Mat matrix;
    Mat idx;
    int layout=0;
    Mat retval;

    // const char* keywords[] = { "matrix", "idx", "layout", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "matrix"), matrix, ArgInfo("matrix", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "idx"), idx, ArgInfo("idx", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "layout"), layout, ArgInfo("layout", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::ml::TrainData::getSubMatrix(matrix, idx, layout), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_TrainData_getSubVector_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    Mat vec;
    Mat idx;
    Mat retval;

    // const char* keywords[] = { "vec", "idx", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "vec"), vec, ArgInfo("vec", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "idx"), idx, ArgInfo("idx", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::ml::TrainData::getSubVector(vec, idx), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_TrainData_getTestNormCatResponses(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!evision_ml_TrainData_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::TrainData>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    Mat retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getTestNormCatResponses(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_TrainData_getTestResponses(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!evision_ml_TrainData_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::TrainData>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    Mat retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getTestResponses(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_TrainData_getTestSampleIdx(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!evision_ml_TrainData_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::TrainData>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    Mat retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getTestSampleIdx(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_TrainData_getTestSampleWeights(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!evision_ml_TrainData_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::TrainData>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    Mat retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getTestSampleWeights(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_TrainData_getTestSamples(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!evision_ml_TrainData_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::TrainData>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    Mat retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getTestSamples(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_TrainData_getTrainNormCatResponses(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!evision_ml_TrainData_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::TrainData>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    Mat retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getTrainNormCatResponses(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_TrainData_getTrainResponses(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!evision_ml_TrainData_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::TrainData>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    Mat retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getTrainResponses(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_TrainData_getTrainSampleIdx(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!evision_ml_TrainData_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::TrainData>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    Mat retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getTrainSampleIdx(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_TrainData_getTrainSampleWeights(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!evision_ml_TrainData_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::TrainData>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    Mat retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getTrainSampleWeights(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_TrainData_getTrainSamples(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!evision_ml_TrainData_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::TrainData>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    int layout=ROW_SAMPLE;
    bool compressSamples=true;
    bool compressVars=true;
    Mat retval;

    // const char* keywords[] = { "layout", "compressSamples", "compressVars", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "layout"), layout, ArgInfo("layout", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "compressSamples"), compressSamples, ArgInfo("compressSamples", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "compressVars"), compressVars, ArgInfo("compressVars", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getTrainSamples(layout, compressSamples, compressVars), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_TrainData_getValues(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!evision_ml_TrainData_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::TrainData>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::TrainData> _self_ = *(self1);

    {
    int vi=0;
    Mat sidx;
    float values=0.f;

    // const char* keywords[] = { "vi", "sidx", "values", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "vi"), vi, ArgInfo("vi", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sidx"), sidx, ArgInfo("sidx", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "values"), values, ArgInfo("values", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->getValues(vi, sidx, &values), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.TrainData", success);
        }
    }

    }
    

    {
    int vi=0;
    UMat sidx;
    float values=0.f;

    // const char* keywords[] = { "vi", "sidx", "values", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "vi"), vi, ArgInfo("vi", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sidx"), sidx, ArgInfo("sidx", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "values"), values, ArgInfo("values", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->getValues(vi, sidx, &values), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.TrainData", success);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_TrainData_getVarIdx(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!evision_ml_TrainData_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::TrainData>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    Mat retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getVarIdx(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_TrainData_getVarSymbolFlags(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!evision_ml_TrainData_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::TrainData>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    Mat retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getVarSymbolFlags(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_TrainData_getVarType(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!evision_ml_TrainData_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::TrainData>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    Mat retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getVarType(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_TrainData_setTrainTestSplit(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!evision_ml_TrainData_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::TrainData>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    int count=0;
    bool shuffle=true;

    // const char* keywords[] = { "count", "shuffle", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "count"), count, ArgInfo("count", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "shuffle"), shuffle, ArgInfo("shuffle", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setTrainTestSplit(count, shuffle), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.TrainData", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_TrainData_setTrainTestSplitRatio(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!evision_ml_TrainData_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::TrainData>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    double ratio=0;
    bool shuffle=true;

    // const char* keywords[] = { "ratio", "shuffle", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "ratio"), ratio, ArgInfo("ratio", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "shuffle"), shuffle, ArgInfo("shuffle", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->setTrainTestSplitRatio(ratio, shuffle), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.TrainData", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ml_TrainData_shuffleTrainTest(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!evision_ml_TrainData_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::ml::TrainData>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::ml::TrainData> _self_ = *(self1);

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(_self_->shuffleTrainTest(), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "ML.TrainData", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (ml_TrainData)

template<>
struct Evision_Converter< Ptr<cv::ml::TrainData> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::ml::TrainData>& r)
    {
        return evision_ml_TrainData_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::ml::TrainData>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::ml::TrainData> * dst_ = nullptr;
        if (evision_ml_TrainData_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::ml::TrainData> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// ocl_Device (Generic)
//================================================================================

// GetSet (ocl_Device)



// Methods (ocl_Device)

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_Device(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        evision_res<cv::ocl::Device> * self = nullptr;
        if (alloc_resource(&self)) ERRWRAP2(new (&(self->val)) cv::ocl::Device(), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<cv::ocl::Device>(env, self->val, ret, "OCL.Device", success);;
        }
    }

    return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_OpenCLVersion(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->OpenCLVersion(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_OpenCL_C_Version(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->OpenCL_C_Version(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_addressBits(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->addressBits(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_available(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->available(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_compilerAvailable(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->compilerAvailable(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_deviceVersionMajor(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->deviceVersionMajor(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_deviceVersionMinor(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->deviceVersionMinor(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_doubleFPConfig(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->doubleFPConfig(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_driverVersion(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->driverVersion(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_endianLittle(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->endianLittle(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_errorCorrectionSupport(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->errorCorrectionSupport(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_executionCapabilities(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->executionCapabilities(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_extensions(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->extensions(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_getDefault_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    Device retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::ocl::Device::getDefault(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_globalMemCacheLineSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->globalMemCacheLineSize(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_globalMemCacheSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    size_t retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->globalMemCacheSize(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_globalMemCacheType(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->globalMemCacheType(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_globalMemSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    size_t retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->globalMemSize(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_halfFPConfig(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->halfFPConfig(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_hostUnifiedMemory(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->hostUnifiedMemory(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_image2DMaxHeight(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    size_t retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->image2DMaxHeight(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_image2DMaxWidth(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    size_t retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->image2DMaxWidth(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_image3DMaxDepth(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    size_t retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->image3DMaxDepth(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_image3DMaxHeight(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    size_t retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->image3DMaxHeight(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_image3DMaxWidth(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    size_t retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->image3DMaxWidth(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_imageFromBufferSupport(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->imageFromBufferSupport(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_imageMaxArraySize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    size_t retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->imageMaxArraySize(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_imageMaxBufferSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    size_t retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->imageMaxBufferSize(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_imageSupport(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->imageSupport(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_intelSubgroupsSupport(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->intelSubgroupsSupport(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_isAMD(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->isAMD(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_isExtensionSupported(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    String extensionName;
    bool retval;

    // const char* keywords[] = { "extensionName", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "extensionName"), extensionName, ArgInfo("extensionName", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->isExtensionSupported(extensionName), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_isIntel(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->isIntel(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_isNVidia(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->isNVidia(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_linkerAvailable(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->linkerAvailable(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_localMemSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    size_t retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->localMemSize(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_localMemType(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->localMemType(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_maxClockFrequency(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->maxClockFrequency(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_maxComputeUnits(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->maxComputeUnits(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_maxConstantArgs(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->maxConstantArgs(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_maxConstantBufferSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    size_t retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->maxConstantBufferSize(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_maxMemAllocSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    size_t retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->maxMemAllocSize(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_maxParameterSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    size_t retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->maxParameterSize(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_maxReadImageArgs(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->maxReadImageArgs(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_maxSamplers(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->maxSamplers(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_maxWorkGroupSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    size_t retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->maxWorkGroupSize(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_maxWorkItemDims(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->maxWorkItemDims(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_maxWriteImageArgs(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->maxWriteImageArgs(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_memBaseAddrAlign(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->memBaseAddrAlign(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_name(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->name(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_nativeVectorWidthChar(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->nativeVectorWidthChar(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_nativeVectorWidthDouble(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->nativeVectorWidthDouble(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_nativeVectorWidthFloat(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->nativeVectorWidthFloat(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_nativeVectorWidthHalf(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->nativeVectorWidthHalf(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_nativeVectorWidthInt(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->nativeVectorWidthInt(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_nativeVectorWidthLong(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->nativeVectorWidthLong(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_nativeVectorWidthShort(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->nativeVectorWidthShort(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_preferredVectorWidthChar(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->preferredVectorWidthChar(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_preferredVectorWidthDouble(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->preferredVectorWidthDouble(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_preferredVectorWidthFloat(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->preferredVectorWidthFloat(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_preferredVectorWidthHalf(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->preferredVectorWidthHalf(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_preferredVectorWidthInt(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->preferredVectorWidthInt(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_preferredVectorWidthLong(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->preferredVectorWidthLong(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_preferredVectorWidthShort(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->preferredVectorWidthShort(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_printfBufferSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    size_t retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->printfBufferSize(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_profilingTimerResolution(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    size_t retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->profilingTimerResolution(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_singleFPConfig(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->singleFPConfig(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_type(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->type(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_vendorID(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->vendorID(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_vendorName(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->vendorName(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_ocl_Device_version(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::ocl::Device * self1 = 0;
    if (!evision_ocl_Device_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::ocl::Device` from `self`: mismatched type or invalid resource?");
    }
    cv::ocl::Device* _self_ = (self1);
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->version(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (ocl_Device)

template<>
struct Evision_Converter< cv::ocl::Device >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const cv::ocl::Device& r)
    {
        return evision_ocl_Device_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, cv::ocl::Device& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        cv::ocl::Device * dst_ = nullptr;
        if (evision_ocl_Device_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected cv::ocl::Device for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// ocl_OpenCLExecutionContext (Generic)
//================================================================================

// GetSet (ocl_OpenCLExecutionContext)



// Methods (ocl_OpenCLExecutionContext)



// Converter (ocl_OpenCLExecutionContext)

template<>
struct Evision_Converter< Ptr<cv::ocl::OpenCLExecutionContext> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::ocl::OpenCLExecutionContext>& r)
    {
        return evision_ocl_OpenCLExecutionContext_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::ocl::OpenCLExecutionContext>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::ocl::OpenCLExecutionContext> * dst_ = nullptr;
        if (evision_ocl_OpenCLExecutionContext_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::ocl::OpenCLExecutionContext> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// segmentation_IntelligentScissorsMB (Generic)
//================================================================================

// GetSet (segmentation_IntelligentScissorsMB)



// Methods (segmentation_IntelligentScissorsMB)

static ERL_NIF_TERM evision_cv_segmentation_segmentation_IntelligentScissorsMB_IntelligentScissorsMB(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::segmentation;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        evision_res<cv::segmentation::IntelligentScissorsMB> * self = nullptr;
        if (alloc_resource(&self)) ERRWRAP2(new (&(self->val)) cv::segmentation::IntelligentScissorsMB(), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<cv::segmentation::IntelligentScissorsMB>(env, self->val, ret, "Segmentation.IntelligentScissorsMB", success);;
        }
    }

    return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_segmentation_segmentation_IntelligentScissorsMB_applyImage(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::segmentation;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::segmentation::IntelligentScissorsMB * self1 = 0;
    if (!evision_segmentation_IntelligentScissorsMB_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::segmentation::IntelligentScissorsMB` from `self`: mismatched type or invalid resource?");
    }
    cv::segmentation::IntelligentScissorsMB* _self_ = (self1);

    {
    Mat image;
    IntelligentScissorsMB retval;

    // const char* keywords[] = { "image", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->applyImage(image), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    UMat image;
    IntelligentScissorsMB retval;

    // const char* keywords[] = { "image", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->applyImage(image), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_segmentation_segmentation_IntelligentScissorsMB_applyImageFeatures(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::segmentation;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::segmentation::IntelligentScissorsMB * self1 = 0;
    if (!evision_segmentation_IntelligentScissorsMB_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::segmentation::IntelligentScissorsMB` from `self`: mismatched type or invalid resource?");
    }
    cv::segmentation::IntelligentScissorsMB* _self_ = (self1);

    {
    Mat non_edge;
    Mat gradient_direction;
    Mat gradient_magnitude;
    Mat image;
    IntelligentScissorsMB retval;

    // const char* keywords[] = { "non_edge", "gradient_direction", "gradient_magnitude", "image", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "non_edge"), non_edge, ArgInfo("non_edge", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "gradient_direction"), gradient_direction, ArgInfo("gradient_direction", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "gradient_magnitude"), gradient_magnitude, ArgInfo("gradient_magnitude", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->applyImageFeatures(non_edge, gradient_direction, gradient_magnitude, image), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    UMat non_edge;
    UMat gradient_direction;
    UMat gradient_magnitude;
    UMat image;
    IntelligentScissorsMB retval;

    // const char* keywords[] = { "non_edge", "gradient_direction", "gradient_magnitude", "image", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "non_edge"), non_edge, ArgInfo("non_edge", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "gradient_direction"), gradient_direction, ArgInfo("gradient_direction", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "gradient_magnitude"), gradient_magnitude, ArgInfo("gradient_magnitude", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->applyImageFeatures(non_edge, gradient_direction, gradient_magnitude, image), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_segmentation_segmentation_IntelligentScissorsMB_buildMap(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::segmentation;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::segmentation::IntelligentScissorsMB * self1 = 0;
    if (!evision_segmentation_IntelligentScissorsMB_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::segmentation::IntelligentScissorsMB` from `self`: mismatched type or invalid resource?");
    }
    cv::segmentation::IntelligentScissorsMB* _self_ = (self1);
    Point sourcePt;

    // const char* keywords[] = { "sourcePt", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "sourcePt"), sourcePt, ArgInfo("sourcePt", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->buildMap(sourcePt), env, error_flag, error_term);
        if (!error_flag) {
            bool success;
            return evision_from_as_map(env, _self_, self, "Segmentation.IntelligentScissorsMB", success);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_segmentation_segmentation_IntelligentScissorsMB_getContour(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::segmentation;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::segmentation::IntelligentScissorsMB * self1 = 0;
    if (!evision_segmentation_IntelligentScissorsMB_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::segmentation::IntelligentScissorsMB` from `self`: mismatched type or invalid resource?");
    }
    cv::segmentation::IntelligentScissorsMB* _self_ = (self1);

    {
    Point targetPt;
    Mat contour;
    bool backward=false;

    // const char* keywords[] = { "targetPt", "contour", "backward", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "targetPt"), targetPt, ArgInfo("targetPt", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "contour"), contour, ArgInfo("contour", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "backward"), backward, ArgInfo("backward", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->getContour(targetPt, contour, backward), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, contour);
        }
    }

    }
    

    {
    Point targetPt;
    UMat contour;
    bool backward=false;

    // const char* keywords[] = { "targetPt", "contour", "backward", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "targetPt"), targetPt, ArgInfo("targetPt", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "contour"), contour, ArgInfo("contour", 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "backward"), backward, ArgInfo("backward", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(_self_->getContour(targetPt, contour, backward), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, contour);
        }
    }

    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_segmentation_segmentation_IntelligentScissorsMB_setEdgeFeatureCannyParameters(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::segmentation;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::segmentation::IntelligentScissorsMB * self1 = 0;
    if (!evision_segmentation_IntelligentScissorsMB_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::segmentation::IntelligentScissorsMB` from `self`: mismatched type or invalid resource?");
    }
    cv::segmentation::IntelligentScissorsMB* _self_ = (self1);
    double threshold1=0;
    double threshold2=0;
    int apertureSize=3;
    bool L2gradient=false;
    IntelligentScissorsMB retval;

    // const char* keywords[] = { "threshold1", "threshold2", "apertureSize", "L2gradient", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "threshold1"), threshold1, ArgInfo("threshold1", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "threshold2"), threshold2, ArgInfo("threshold2", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "apertureSize"), apertureSize, ArgInfo("apertureSize", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "l2gradient"), L2gradient, ArgInfo("L2gradient", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->setEdgeFeatureCannyParameters(threshold1, threshold2, apertureSize, L2gradient), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_segmentation_segmentation_IntelligentScissorsMB_setEdgeFeatureZeroCrossingParameters(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::segmentation;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::segmentation::IntelligentScissorsMB * self1 = 0;
    if (!evision_segmentation_IntelligentScissorsMB_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::segmentation::IntelligentScissorsMB` from `self`: mismatched type or invalid resource?");
    }
    cv::segmentation::IntelligentScissorsMB* _self_ = (self1);
    float gradient_magnitude_min_value=0.0f;
    IntelligentScissorsMB retval;

    // const char* keywords[] = { "gradient_magnitude_min_value", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "gradient_magnitude_min_value"), gradient_magnitude_min_value, ArgInfo("gradient_magnitude_min_value", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->setEdgeFeatureZeroCrossingParameters(gradient_magnitude_min_value), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_segmentation_segmentation_IntelligentScissorsMB_setGradientMagnitudeMaxLimit(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::segmentation;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::segmentation::IntelligentScissorsMB * self1 = 0;
    if (!evision_segmentation_IntelligentScissorsMB_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::segmentation::IntelligentScissorsMB` from `self`: mismatched type or invalid resource?");
    }
    cv::segmentation::IntelligentScissorsMB* _self_ = (self1);
    float gradient_magnitude_threshold_max=0.0f;
    IntelligentScissorsMB retval;

    // const char* keywords[] = { "gradient_magnitude_threshold_max", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "gradient_magnitude_threshold_max"), gradient_magnitude_threshold_max, ArgInfo("gradient_magnitude_threshold_max", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->setGradientMagnitudeMaxLimit(gradient_magnitude_threshold_max), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_segmentation_segmentation_IntelligentScissorsMB_setWeights(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::segmentation;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    cv::segmentation::IntelligentScissorsMB * self1 = 0;
    if (!evision_segmentation_IntelligentScissorsMB_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `cv::segmentation::IntelligentScissorsMB` from `self`: mismatched type or invalid resource?");
    }
    cv::segmentation::IntelligentScissorsMB* _self_ = (self1);
    float weight_non_edge=0.f;
    float weight_gradient_direction=0.f;
    float weight_gradient_magnitude=0.f;
    IntelligentScissorsMB retval;

    // const char* keywords[] = { "weight_non_edge", "weight_gradient_direction", "weight_gradient_magnitude", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "weight_non_edge"), weight_non_edge, ArgInfo("weight_non_edge", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "weight_gradient_direction"), weight_gradient_direction, ArgInfo("weight_gradient_direction", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "weight_gradient_magnitude"), weight_gradient_magnitude, ArgInfo("weight_gradient_magnitude", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->setWeights(weight_non_edge, weight_gradient_direction, weight_gradient_magnitude), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (segmentation_IntelligentScissorsMB)

template<>
struct Evision_Converter< cv::segmentation::IntelligentScissorsMB >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const cv::segmentation::IntelligentScissorsMB& r)
    {
        return evision_segmentation_IntelligentScissorsMB_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, cv::segmentation::IntelligentScissorsMB& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        cv::segmentation::IntelligentScissorsMB * dst_ = nullptr;
        if (evision_segmentation_IntelligentScissorsMB_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected cv::segmentation::IntelligentScissorsMB for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// utils_nested_OriginalClassName (Generic)
//================================================================================

// GetSet (utils_nested_OriginalClassName)



// Methods (utils_nested_OriginalClassName)

static ERL_NIF_TERM evision_cv_utils_nested_utils_nested_OriginalClassName_create_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::utils::nested;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    OriginalClassName_Params params=OriginalClassName::Params();
    Ptr<OriginalClassName> retval;

    // const char* keywords[] = { "params", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "params"), params, ArgInfo("params", 0)) )
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::utils::nested::OriginalClassName::create(params), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_utils_nested_utils_nested_OriginalClassName_getFloatParam(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::utils::nested;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::utils::nested::OriginalClassName> * self1 = 0;
    if (!evision_utils_nested_OriginalClassName_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::utils::nested::OriginalClassName>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::utils::nested::OriginalClassName> _self_ = *(self1);
    float retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getFloatParam(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_utils_nested_utils_nested_OriginalClassName_getIntParam(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::utils::nested;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 1; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }

    ERL_NIF_TERM self = argv[0];
    Ptr<cv::utils::nested::OriginalClassName> * self1 = 0;
    if (!evision_utils_nested_OriginalClassName_getp(env, self, self1)) {
        return failmsgp(env, "cannot get `Ptr<cv::utils::nested::OriginalClassName>` from `self`: mismatched type or invalid resource?");
    }
    Ptr<cv::utils::nested::OriginalClassName> _self_ = *(self1);
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = _self_->getIntParam(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_utils_nested_utils_nested_OriginalClassName_originalName_static(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::utils::nested;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    std::string retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        int error_flag = false;
        ERRWRAP2(retval = cv::utils::nested::OriginalClassName::originalName(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}



// Converter (utils_nested_OriginalClassName)

template<>
struct Evision_Converter< Ptr<cv::utils::nested::OriginalClassName> >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const Ptr<cv::utils::nested::OriginalClassName>& r)
    {
        return evision_utils_nested_OriginalClassName_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, Ptr<cv::utils::nested::OriginalClassName>& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        Ptr<cv::utils::nested::OriginalClassName> * dst_ = nullptr;
        if (evision_utils_nested_OriginalClassName_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected Ptr<cv::utils::nested::OriginalClassName> for argument '%s'", info.name);
        return false;
    }
};

//================================================================================
// utils_nested_OriginalClassName_Params (Generic)
//================================================================================

// GetSet (utils_nested_OriginalClassName_Params)


static ERL_NIF_TERM evision_utils_nested_OriginalClassName_Params_get_float_value(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::utils::nested::OriginalClassName::Params* self_ptr = 0;
    if (!evision_utils_nested_OriginalClassName_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::utils::nested::OriginalClassName::Params` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->float_value);
}

static ERL_NIF_TERM evision_utils_nested_OriginalClassName_Params_set_float_value(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::utils::nested::OriginalClassName::Params* self_ptr = 0;

    if (!evision_utils_nested_OriginalClassName_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::utils::nested::OriginalClassName::Params` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->float_value, ArgInfo("float_value", false))) {
        bool success;
        return evision_from_as_map<cv::utils::nested::OriginalClassName::Params>(env, *self_ptr, self, "\"Utils.Nested.OriginalClassName.Params\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}

static ERL_NIF_TERM evision_utils_nested_OriginalClassName_Params_get_int_value(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::utils::nested::OriginalClassName::Params* self_ptr = 0;
    if (!evision_utils_nested_OriginalClassName_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::utils::nested::OriginalClassName::Params` from `self`: mismatched type or invalid resource?");
    }

    return evision_from(env, self_ptr->int_value);
}

static ERL_NIF_TERM evision_utils_nested_OriginalClassName_Params_set_int_value(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM self = argv[0];
    cv::utils::nested::OriginalClassName::Params* self_ptr = 0;

    if (!evision_utils_nested_OriginalClassName_Params_getp(env, self, self_ptr) && !self_ptr) {
        return failmsgp(env, "cannot get `cv::utils::nested::OriginalClassName::Params` from `self`: mismatched type or invalid resource?");
    }

    if (evision_to_safe(env, argv[1], self_ptr->int_value, ArgInfo("int_value", false))) {
        bool success;
        return evision_from_as_map<cv::utils::nested::OriginalClassName::Params>(env, *self_ptr, self, "\"Utils.Nested.OriginalClassName.Params\"", success);
    }

    return failmsgp(env, "cannot assign new value, mismatched type?");
}


// Methods (utils_nested_OriginalClassName_Params)

static ERL_NIF_TERM evision_cv_utils_nested_utils_nested_OriginalClassName_Params_OriginalClassName_Params(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::utils::nested;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    int int_param=123;
    float float_param=3.5f;

    // const char* keywords[] = { "int_param", "float_param", NULL }; // <- no more in use, left for debugging purpose
    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "int_param"), int_param, ArgInfo("int_param", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "float_param"), float_param, ArgInfo("float_param", 0)) )
    {
        int error_flag = false;
        evision_res<cv::utils::nested::OriginalClassName::Params> * self = nullptr;
        if (alloc_resource(&self)) ERRWRAP2(new (&(self->val)) cv::utils::nested::OriginalClassName::Params(int_param, float_param), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM ret = enif_make_resource(env, self);
            enif_release_resource(self);
            bool success;
            return evision_from_as_map<cv::utils::nested::OriginalClassName::Params>(env, self->val, ret, "Utils.Nested.OriginalClassName.Params", success);;
        }
    }

    return enif_make_badarg(env);
}



// Converter (utils_nested_OriginalClassName_Params)

template<>
struct Evision_Converter< cv::utils::nested::OriginalClassName::Params >
{
    static ERL_NIF_TERM from(ErlNifEnv *env, const cv::utils::nested::OriginalClassName::Params& r)
    {
        return evision_utils_nested_OriginalClassName_Params_Instance(env, r);
    }
    static bool to(ErlNifEnv *env, ERL_NIF_TERM src, cv::utils::nested::OriginalClassName::Params& dst, const ArgInfo& info)
    {
        if(!src || evision::nif::check_nil(env, src))
            return true;
        cv::utils::nested::OriginalClassName::Params * dst_ = nullptr;
        if (evision_utils_nested_OriginalClassName_Params_getp(env, src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg(env, "Expected cv::utils::nested::OriginalClassName::Params for argument '%s'", info.name);
        return false;
    }
};

